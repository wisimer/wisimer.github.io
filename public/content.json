{"meta":{"title":"W","subtitle":null,"description":"This is AI of Wisimer","author":"Wisimer","url":"http://ai.wisim.me"},"pages":[{"title":"Categories","date":"2017-09-27T16:42:32.000Z","updated":"2017-09-26T23:53:00.000Z","comments":true,"path":"categories/index.html","permalink":"http://ai.wisim.me/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-09-27T16:42:32.000Z","updated":"2017-09-26T23:53:00.000Z","comments":true,"path":"tags/index.html","permalink":"http://ai.wisim.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"平衡二叉树的旋转及其代码实现","slug":"2018-03-13_AVL","date":"2018-03-13T12:49:57.000Z","updated":"2018-03-14T00:58:12.000Z","comments":true,"path":"2018/03/13/2018-03-13_AVL/","link":"","permalink":"http://ai.wisim.me/2018/03/13/2018-03-13_AVL/","excerpt":"平衡二叉树的构造问题以及为了维护它的平衡所要进行的LL旋转、RR旋转、LR旋转、RL旋转。","text":"平衡二叉树的构造问题以及为了维护它的平衡所要进行的LL旋转、RR旋转、LR旋转、RL旋转。 一、平衡二叉树的构造1234567891011121314151617181920node *insert(node *root, int x) &#123; if (root == 0) &#123; root = &amp;all[total++]; root-&gt;left = root-&gt;right = 0; root-&gt;val = x; root-&gt;height = 0; &#125; else if (x &lt; root-&gt;val) &#123; root-&gt;left = insert(root-&gt;left, x); if (height(root-&gt;left) - height(root-&gt;right) == 2) &#123; root = (x &lt; root-&gt;left-&gt;val) ? LL(root) : LR(root); &#125; &#125; else &#123; root-&gt;right = insert(root-&gt;right, x); if (height(root-&gt;right) - height(root-&gt;left) == 2) &#123; root = (x &gt; root-&gt;right-&gt;val) ? RR(root) : RL(root); &#125; &#125; root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + 1; return root;&#125; 二、LL旋转所谓LL旋转并不是指旋转方向，而是指新插入导致不平衡的元素位于左子树的左儿子位置，也就是LeftLeft。 看一下这种旋转的示意图： 12345678node *LL(node *k2) &#123; node *k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; return k1;&#125; 三、RR旋转同样LL旋转是指新插入导致不平衡的元素位于右子树的右儿子位置，也就是RightRight。 看一下这种旋转的方式示意图： 12345678node *RR(node *k1) &#123; node *k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; return k2;&#125; 四、LR旋转和RL旋转LR和RL则分别表示位于左子树的右儿子和右子树的左儿子。 1.对于LR旋转，首先将最近的不平衡结点k3的左子树进行RR旋转，再将k3本身进行LL旋转。 1234node *LR(node *k3) &#123; k3-&gt;left = RR(k3-&gt;left); return LL(k3);&#125; 2.对于RL旋转，首先将最近的不平衡结点k3的右子树进行LL旋转，再将k3本身进行RR旋转。 1234node *RL(node *k1) &#123; k1-&gt;right = LL(k1-&gt;right); return RR(k1);&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://ai.wisim.me/tags/二叉树/"}]},{"title":"机器学习构建chatbot","slug":"2018-02-24_chatbot","date":"2018-02-24T16:00:00.000Z","updated":"2018-03-12T13:20:32.000Z","comments":true,"path":"2018/02/25/2018-02-24_chatbot/","link":"","permalink":"http://ai.wisim.me/2018/02/25/2018-02-24_chatbot/","excerpt":"预备知识机器人应答逻辑（Logic Adapter），针对每个部分设计了不同的适配器 Closet Match Adapter:字符串模糊匹配（编辑距离） Closet Meaning Adapter:借助nltk的WordNet，近义词评估 Time Logic Adapter:处理涉及实践的提问 Mathematical Evaluation Adapter:涉及数学运算 存储器后段（Storage Adapter） Read Only Mode:只读模式 Json Database Mode:Json格式存储对话数据 Mongo Database Mode:以MongoDb方式存储对话数据库 输入形式（Input Adapter） Variable input type Adapter:允许chatbot接收不同类型的输入 Terminal Adapter:以终端方式进行对话 HipChat Adapter:通过HipChat聊天室和chatbo进行对话 Speech recognition:语音识别输入 输出形式（Output Adapters） Output format adapter:支持text，json和object格式的输出 Terminal adapter HipChat Adapter Mailgun adapter:允许chat bot基于Mailgun API进行邮件的发送 Speech synthesis TTS(Text to speech)部分，详见chatterbot-voice","text":"预备知识机器人应答逻辑（Logic Adapter），针对每个部分设计了不同的适配器 Closet Match Adapter:字符串模糊匹配（编辑距离） Closet Meaning Adapter:借助nltk的WordNet，近义词评估 Time Logic Adapter:处理涉及实践的提问 Mathematical Evaluation Adapter:涉及数学运算 存储器后段（Storage Adapter） Read Only Mode:只读模式 Json Database Mode:Json格式存储对话数据 Mongo Database Mode:以MongoDb方式存储对话数据库 输入形式（Input Adapter） Variable input type Adapter:允许chatbot接收不同类型的输入 Terminal Adapter:以终端方式进行对话 HipChat Adapter:通过HipChat聊天室和chatbo进行对话 Speech recognition:语音识别输入 输出形式（Output Adapters） Output format adapter:支持text，json和object格式的输出 Terminal adapter HipChat Adapter Mailgun adapter:允许chat bot基于Mailgun API进行邮件的发送 Speech synthesis TTS(Text to speech)部分，详见chatterbot-voice 使用ChatterBot构建聊天机器人1. 首先构建ChatBot并指定Adapter123456789101112131415161718# -*- coding: utf-8 -*-from chatterbot import ChatBotbot = ChatBot( 'Default Response Example Bot', #置信度低于0.65时回复default_response logic_adapters=[ &#123; 'import_path': 'chatterbot.logic.BestMatch' &#125;, &#123; 'import_path': 'chatterbot.logic.LowConfidenceAdapter', 'threshold': 0.65, 'default_response': 'I am sorry, but I do not understand.' &#125; ], #指定对话类型是列表 trainer='chatterbot.trainers.ListTrainer') 2. 接着手动给定一点语料用于训练1234567bot.train([ 'How can I help you?', 'I want to create a chat bot', 'Have you read the documentation?', 'No, I have not', 'This should help get you started: http://chatterbot.rtfd.org/en/latest/quickstart.html']) 3. 给定问题并取回结果12345678910question = 'How do I make an omelette?'print(question)response = bot.get_response(question)print(response)print(\"\\n\")question = 'how to make a chat bot?'print(question)response = bot.get_response(question)print(response) 各自输出： 123456How do I make an omelette?I am sorry, but I do not understand.how to make a chat bot?Have you read the documentation? 4. 使用chatterbot自带的中文语料库训练1234567891011121314#!/usr/bin/python# -*- coding: utf-8 -*-from chatterbot import ChatBotfrom chatterbot.trainers import ChatterBotCorpusTrainerchatbot = ChatBot(\"ChineseChatBot\")chatbot.set_trainer(ChatterBotCorpusTrainer)# 使用中文语料库训练它chatbot.train(\"chatterbot.corpus.chinese\")# 开始对话while True: print(chatbot.get_response(input(\"&gt;\"))) 试了一下，问答比较二。。。 seq2seq LSTM THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[]},{"title":"NLP基础","slug":"2018-02-25_nltk","date":"2018-02-23T16:00:00.000Z","updated":"2018-03-12T12:00:19.000Z","comments":true,"path":"2018/02/24/2018-02-25_nltk/","link":"","permalink":"http://ai.wisim.me/2018/02/24/2018-02-25_nltk/","excerpt":"NLTKNLTK在NLP上的应用 情感分析 文本相似度 文本分类","text":"NLTKNLTK在NLP上的应用 情感分析 文本相似度 文本分类 一、安装NLTK1234sudo pip install nltkpython3&gt;&gt;&gt; import nltk&gt;&gt;&gt; nltk.download() 其中 nltk.download() 用来下载nltk自带的一些语料库 测试布朗大学的语料库： 1234567&gt;&gt;&gt; from nltk.corpus import brown&gt;&gt;&gt; brown.categories()[&apos;adventure&apos;, &apos;belles_lettres&apos;, &apos;editorial&apos;, &apos;fiction&apos;, &apos;government&apos;, &apos;hobbies&apos;, &apos;humor&apos;, &apos;learned&apos;, &apos;lore&apos;, &apos;mystery&apos;, &apos;news&apos;, &apos;religion&apos;, &apos;reviews&apos;, &apos;romance&apos;, &apos;science_fiction&apos;]&gt;&gt;&gt; len(brown.sents())57340 #句子长度&gt;&gt;&gt; len(brown.words())1161192 #单词个数 二、文本处理流程1. 文本预处理（1）Tokenize:把长句子拆分成“有意义”的小部分 12345&gt;&gt;&gt; import nltk&gt;&gt;&gt; sentence = “hello, world&quot;&gt;&gt;&gt; tokens = nltk.word_tokenize(sentence)&gt;&gt;&gt; tokens[&apos;hello&apos;, ‘,&apos;, &apos;world&apos;] （2）词形归一化，包括Stemming和Lemmatization Stemming 词干提取:一般来说，就是把不影响词性的inflection的小尾巴砍掉 可以使用nltk中的 PorterStemmer/LancasterStemmer/SnowballStemmer/PorterStemmer Lemmatization 词形归一:把各种类型的词的变形，都归为一个形式 可以使用nltk中的 WordNetLemmatizer Part-Of-Speech:NLTK更好地实现Lemma （3）去除停止词 1234from nltk.corpus import stopwords# 先token得到word_list,再去除停止词filtered_words =[word for word in word_list if word not in stopwords.words('english')] （4）最终得到一个干净的word list 分词的方式：启发式Heuristic（查数据库）机器学习／统计方法：HMM、CRF 三、应用：情感分析最简单的方法是给每个词打分，然后判断句子总的分数。 配上ML的情感分析： 123456# 把训练集给做成标准形式 training_data = [[preprocess(s1), 'pos'], [preprocess(s2), 'pos'], [preprocess(s3), 'neg'], [preprocess(s4), 'neg']]# 构建modelmodel = NaiveBayesClassifier.train(training_data) # 测试结果 print(model.classify(preprocess('this is a good book'))) 四：应用:文本相似度用元素频率表示文本特征 原理就是使用余弦定理来计算文本相似度: $similarity = cos( \\theta ) = \\dfrac{A \\cdot B}{||A|| \\: ||B||}$ 使用NLTK中的FreqDist包来进行频率统计 12345678&gt;&gt;&gt; from nltk.corpus import stopwords&gt;&gt;&gt; from nltk import FreqDist&gt;&gt;&gt; corpus = &apos;this is my sentence this is my life this is the day&apos;&gt;&gt;&gt; tokens = nltk.word_tokenize(corpus)&gt;&gt;&gt; fdist = FreqDist(tokens)&gt;&gt;&gt; standard_freq_vector = fdist.most_common(50)&gt;&gt;&gt; print(standard_freq_vector)[(&apos;this&apos;, 3), (&apos;is&apos;, 3), (&apos;my&apos;, 2), (&apos;sentence&apos;, 1), (&apos;life&apos;, 1), (&apos;the&apos;, 1), (&apos;day&apos;, 1)] 这一步得到了一个类似词典的东西，里面保存了我们给出的句子里面每个单词出现的频率，并且取出来出现频率最高的50个单词。 然后按照出现频率 ,记录下每个单词的位置： 1234567891011def position_lookup(v): res = &#123;&#125; counter = 0 for word in v: res[word[0]] = counter counter += 1 return res# 把标准的单词位置记录下来standard_position_dict = position_lookup(standard_freq_vector) print(standard_position_dict)# 得到 个位置对照表# &#123;'is': 0, 'the': 3, 'day': 4, 'this': 1,'sentence': 5, 'my': 2, 'life': 6&#125; 这时如果我们有个新句子，对于这个新句子的每个单词如果在我们的词库出现过那么就在”标准位置”上+1 1234567891011sentence = 'this is cool'# 先新建个跟我们的标准vector同样的向量 freq_vector = [0] * size# 简单的Preprocessingtokens = nltk.word_tokenize(sentence)for word in tokens: try: freq_vector[standard_position_dict[word]] += 1 except KeyError: # 如果是个新词就pass掉 continueprint(freq_vector)# [1, 1, 0, 0, 0, 0, 0] 结巴分词 Word2Vec THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"NLTK","slug":"NLTK","permalink":"http://ai.wisim.me/tags/NLTK/"}]},{"title":"KNN","slug":"2018-02-23_knn","date":"2018-02-22T16:00:00.000Z","updated":"2018-02-24T01:16:54.000Z","comments":true,"path":"2018/02/23/2018-02-23_knn/","link":"","permalink":"http://ai.wisim.me/2018/02/23/2018-02-23_knn/","excerpt":"","text":"K邻近算法，或者说K最近邻(kNN，k-NearestNeighbor)分类算法 THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"KNN","slug":"KNN","permalink":"http://ai.wisim.me/tags/KNN/"}]},{"title":"感知机","slug":"2018-02-19_perceptron","date":"2018-02-18T16:00:00.000Z","updated":"2018-02-25T12:05:39.000Z","comments":true,"path":"2018/02/19/2018-02-19_perceptron/","link":"","permalink":"http://ai.wisim.me/2018/02/19/2018-02-19_perceptron/","excerpt":"感知机感知机（perceptron）是一种二分类的线性分类模型，输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的分离超平面。感知机旨在求出该超平面，为求得超平面导入了基于误分类的损失函数，利用梯度下降法 对损失函数进行最优化（最优化）。","text":"感知机感知机（perceptron）是一种二分类的线性分类模型，输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的分离超平面。感知机旨在求出该超平面，为求得超平面导入了基于误分类的损失函数，利用梯度下降法 对损失函数进行最优化（最优化）。 感知机的损失函数$L(w,b)=-\\sum_{i=1}^{M} {y_i(w*x_i+b)}$ 显然，损失函数L(w,b)是非负的。如果没有误分类点，那么L(w,b)为0，误分类点数越少，L(w,b)值越小。一个特定的损失函数：在误分类时是参数w,b的线性函数，在正确分类时，是0。 损失函数L(w,b)的梯度： $\\nabla_w L(w,b)=-\\sum_{i=1}^{M}y_i\\:x_i$ $\\nabla_b L(w,b)=-\\sum_{i=1}^{M}y_i$ 求解损失函数极小值的过程： 首先，任意选定w0、b0，然后用梯度下降法不断极小化目标损失函数，极小化的过程不是一次性的把M中的所有误分类点梯度下降，而是一次随机选取一个误分类点使其梯度下降： $w=w+\\eta y_i\\:x_i$ $b=b+\\eta y_i$ 式中η（0≤η≤1）是步长，在统计学是中成为学习速率。步长越大，梯度下降的速度越快，更能接近极小点。如果步长过大，有可能导致跨过极小点，导致函数发散；如果步长过小，有可能会耗很长时间才能达到极小点。 实现代码从输入参数得到训练文件和模型文件： 123n = float(sys.argv[1])trainFile = open(sys.argv[2])modelFile= open(sys.argv[3], 'w') 从训练文件中读取训练数据： 123456789101112for line in trainFile: chunk = line.strip().split(' ') #每行的数据 lens = len(chunk) - 1 #最后一行是训练输出 tmp_all = [] tmp = [] for i in range(1, lens+1): tmp.append(int(chunk[i])) tmp_all.append(tmp) tmp_all.append(int(chunk[0])) training_set.append(tmp_all)trainFile.close() 训练数据：1231 3 31 4 3-1 1 1 计算点到超平面的距离：12345678def cal(item): global w, b res = 0 for i in range(len(item[0])): res += item[0][i] * w[i] #w和xi的内积 res += b res *= item[1] return res 判断是否是误分类点，如果是误分类点则更新参数:1234for item in training_set: if cal(item) &lt;= 0: flag = True update(item) 使用随机梯度下降法更新参数：12345def update(item): global w, b, lens, n #n就是学习速率η for i in range(lens): w[i] = w[i] + n * item[1] * item[0][i] b = b + n * item[1] 疑问：感知机的对偶形式 参考：http://www.cnblogs.com/kaituorensheng/p/3561091.html THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"感知机","slug":"感知机","permalink":"http://ai.wisim.me/tags/感知机/"}]},{"title":"线性代数陌生公式","slug":"2017-12-25","date":"2017-12-24T16:00:00.000Z","updated":"2017-11-26T14:20:58.000Z","comments":true,"path":"2017/12/25/2017-12-25/","link":"","permalink":"http://ai.wisim.me/2017/12/25/2017-12-25/","excerpt":"$\\left(kA\\right)^{\\ast}=k^{n-1}A^{\\ast}$ $|A^{\\ast}|=|A|^{n-1}$ $|kA|=k^{n}|A|$","text":"$\\left(kA\\right)^{\\ast}=k^{n-1}A^{\\ast}$ $|A^{\\ast}|=|A|^{n-1}$ $|kA|=k^{n}|A|$ $\\begin{vmatrix}A &amp; O \\\\O &amp; B\\end{vmatrix}^{-1}=\\begin{vmatrix}A^{-1} &amp; O \\\\O &amp; B^{-1}\\end{vmatrix}$ $\\begin{vmatrix}O &amp; A \\\\B &amp; O\\end{vmatrix}^{-1}=\\begin{vmatrix}O &amp; B^{-1} \\\\A^{-1} &amp; O\\end{vmatrix}$ $A^{-1}=\\dfrac{A^{\\ast}}{|A|} &lt;=&gt; (A^{\\ast})^{-1}=\\dfrac{A}{|A|} &lt;=&gt; AA^{\\ast}=|A|E$ $(A^{T})^{\\ast}=(A^{\\ast})^{T}$ $(A^{T})^{-1}=(A^{-1})^{T}$ $(A^{-1})^{\\ast}=(A^{\\ast})^{-1}$ $(A^{\\ast})^{\\ast}=|A|^{n-2}A$ $(AB)^{\\ast}=B^{\\ast}A^{\\ast}$ $r(A^{\\ast})=\\begin{cases}n,r(A)=n\\\\1,r(A)=n-1\\\\0,r(A)&lt;n-1 \\end{cases}$ $r(AB)\\geq r(A)+r(B)-n$ $r(A)=r(A^{T}A)$ $r(A|B)\\leq r(A)+r(B)$ $r(A|B)\\geq r(A)$ $(A+B)^n=A^n+C_n^1A^{n-1}B+C_n^{2}A^{n-2}B^2+…+C_n^{n-1}AB^{n-1}+B^n$ THE END.","categories":[{"name":"线性代数","slug":"线性代数","permalink":"http://ai.wisim.me/categories/线性代数/"}],"tags":[{"name":"公式","slug":"公式","permalink":"http://ai.wisim.me/tags/公式/"}]},{"title":"线性代数难点题型","slug":"2017-12-24","date":"2017-12-23T16:00:00.000Z","updated":"2017-11-26T14:19:49.000Z","comments":true,"path":"2017/12/24/2017-12-24/","link":"","permalink":"http://ai.wisim.me/2017/12/24/2017-12-24/","excerpt":"1. 关于矩阵的n阶的题型(1) 如果$A=αβ^{T}$,其中α和β是n维非零列向量，则$A^{n}=l^{n-1}A$,其中$l=β^{T}α=tr(A)$ (2) 如果$A=\\begin{pmatrix}0 &amp; a &amp; c \\\\0 &amp; 0 &amp; b \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,则$A^{2}=\\begin{pmatrix}0 &amp; 0 &amp; ab \\\\0 &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,$A^{3}=0$,$A^{4}=0$… (3) 如果$A \\sim B$,则$A^{n} \\sim B^{n}$,于是$A^{n} \\sim P^{-1}B^{n}P$,其中B是对角矩阵。 (4) 用归纳法：先求 $A^{2},A^{3}$ 等,看出规律，再求 $A^{n}$","text":"1. 关于矩阵的n阶的题型(1) 如果$A=αβ^{T}$,其中α和β是n维非零列向量，则$A^{n}=l^{n-1}A$,其中$l=β^{T}α=tr(A)$ (2) 如果$A=\\begin{pmatrix}0 &amp; a &amp; c \\\\0 &amp; 0 &amp; b \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,则$A^{2}=\\begin{pmatrix}0 &amp; 0 &amp; ab \\\\0 &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,$A^{3}=0$,$A^{4}=0$… (3) 如果$A \\sim B$,则$A^{n} \\sim B^{n}$,于是$A^{n} \\sim P^{-1}B^{n}P$,其中B是对角矩阵。 (4) 用归纳法：先求 $A^{2},A^{3}$ 等,看出规律，再求 $A^{n}$ 2. 证明可逆的方法主要有：n阶矩阵A可逆 &lt;=&gt; $|A|\\neq0$ &lt;=&gt; r(A)=n &lt;=&gt; A的列（行）向量组线性无关 &lt;=&gt; Ax=0只有0解 &lt;=&gt; 0不是矩阵A的特征值 3. 关于两个矩阵的和的公式只有：$(A+B)^T=A^T+B^T$ 4. 满足交换律的一些特殊矩阵：(1) $AA^2=A^2A=A^3$ (2) $AA^{\\ast}=A^{\\ast}A=|A|E$ (3) $AE=EA=A$ (4) $AA^{-1}=A^{-1}A=E$ (5) $AB=aA+bB(ab\\neq0)$ (6) $A^2-kAB=E(k\\neq0)$ 注：一般矩阵不满足交换律。 THE END.","categories":[{"name":"线性代数","slug":"线性代数","permalink":"http://ai.wisim.me/categories/线性代数/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://ai.wisim.me/tags/线性代数/"}]},{"title":"动态规划-数对之差最大值","slug":"2017-11-22-DynamicProgrammingMaxDiff","date":"2017-11-21T16:00:00.000Z","updated":"2018-03-13T12:48:33.000Z","comments":true,"path":"2017/11/22/2017-11-22-DynamicProgrammingMaxDiff/","link":"","permalink":"http://ai.wisim.me/2017/11/22/2017-11-22-DynamicProgrammingMaxDiff/","excerpt":"题目描述 在数组中，某个数字减去它右边的数字得到一个数对之差。求所有数对之差的最大值。例如，在数组{2,4,1,16,7,5,11,9}中，数对之差的最大值是11，是16减去5的结果。","text":"题目描述 在数组中，某个数字减去它右边的数字得到一个数对之差。求所有数对之差的最大值。例如，在数组{2,4,1,16,7,5,11,9}中，数对之差的最大值是11，是16减去5的结果。 分析 定义D[i]是以数组中第i个数字为减数的所有数对之差的最大值。根据题意，用N[i]表示数组的第i个元素，就是说对于任意h=N[h]-N[i]。所以D[i]的最大值就是整个数组的最大的数对之差。来手写求一下最大数对之差的过程。 123456789101112131415161718192021222324252627M[0] = 2;D[1] = M[0] - N[1] = 2 - 4 = -2;maxDiff = 2;M[1] = max&#123;M[0],N[1]&#125; = max&#123;2,4&#125; = 4;D[2] = M[1] - N[2] = 4 - 1 = 3;maxDiff = max&#123;maxDiff,D[2]&#125; = 3;M[2] = max&#123;M[1],N[2]&#125; = max&#123;4,1&#125; = 4;D[3] = M[2] - N[3] = -12;maxDiff = max&#123;maxDiff,D[3]&#125; = 3;M[3] =16;D[4] = 9;maxDiff = 9;M[4] = 16;D[5] = 11;maxDiff = 11;M[5] = 16;D[6] = 5;maxDiff = 11;M[6] = 16;D[7] = 7;maxDiff = 11; 这里的 M[i-1] 表示的是当前第i个元素之前的i-1个元素中的最大值。而maxDiff则是i之前包括位置i在内的最大数对之差的值。 C代码实现12345678910111213141516int MaxDiff(int numbers[], int length) &#123; if(numbers == NULL || length &lt; 2) return 0; int max = numbers[0]; int maxDiff = max - numbers[1]; for(int i=2;i&lt;length;++i) &#123; if(numbers[i] &lt; max) &#123; max = numbers[i]; &#125; int curDiff = max - numbers[i]; if(curDiff &gt; maxDiff) &#123; maxDiff = curDiff; &#125; &#125; return maxDiff;&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://ai.wisim.me/tags/DP/"}]},{"title":"201709304","slug":"2017-09-30-4","date":"2017-09-29T16:00:00.000Z","updated":"2017-10-05T06:44:41.000Z","comments":true,"path":"2017/09/30/2017-09-30-4/","link":"","permalink":"http://ai.wisim.me/2017/09/30/2017-09-30-4/","excerpt":"题 4:设 f(x) 在[0,1] 上有二阶导数，f(0)=f(1)=f’(0)=f’(1)=0，证明存在 𝛏∈(0,1)，使得f’’(𝛏)=f(𝛏).","text":"题 4:设 f(x) 在[0,1] 上有二阶导数，f(0)=f(1)=f’(0)=f’(1)=0，证明存在 𝛏∈(0,1)，使得f’’(𝛏)=f(𝛏). 证明构造辅助函数 $F(x)=[f(x)+f’(x)]e^{-x}$. 由题设可知F(x)在[0,1]上连续，在(0,1)可导，且F(0)=F(1).由罗尔定理可知至少存在一点 𝛏∈(0,1)，使得F’(𝛏)=0. 又 $F’(x)=[f’(x)+f’’(x)]e^{-x}-[f(x)+f’(x)]e^{-x}=[f’’(x)-f(x)]e^{-x}$.由于 $e^{-x}\\neq0，可知有f’’(𝛏)-f(𝛏)=0，即f’’(𝛏)=f(𝛏).$ THE END.","categories":[{"name":"中值定理","slug":"中值定理","permalink":"http://ai.wisim.me/categories/中值定理/"}],"tags":[{"name":"罗尔定理","slug":"罗尔定理","permalink":"http://ai.wisim.me/tags/罗尔定理/"}]},{"title":"20170929.3","slug":"2017-09-29-3","date":"2017-09-28T16:00:00.000Z","updated":"2017-09-30T23:44:18.000Z","comments":true,"path":"2017/09/29/2017-09-29-3/","link":"","permalink":"http://ai.wisim.me/2017/09/29/2017-09-29-3/","excerpt":"题 3:求极限 $\\lim _{\\tiny{x\\rightarrow\\infty}} {(b^{\\tiny{\\dfrac{1}{n}}}-1)}\\sum_{j=0}^{n-1} {b^{\\tiny{\\dfrac{i}{n}}} \\: sin\\: b^{\\tiny{\\dfrac{2i+1}{2n}}}(b&gt;1).}$","text":"题 3:求极限 $\\lim _{\\tiny{x\\rightarrow\\infty}} {(b^{\\tiny{\\dfrac{1}{n}}}-1)}\\sum_{j=0}^{n-1} {b^{\\tiny{\\dfrac{i}{n}}} \\: sin\\: b^{\\tiny{\\dfrac{2i+1}{2n}}}(b&gt;1).}$ 证明:原式 = $\\lim _{\\tiny{x\\rightarrow\\infty}}(b^{\\tiny{\\dfrac {i+1} {n}}}-b^{\\tiny{\\dfrac{i}{n}}})\\sum _{i=0}^{n-1}{sin\\: b^{\\tiny{\\dfrac{2i+1}{2n}}}}$ ,这里的和式可以看作sin x 在[1,b]上划分所做的积分和,区间划分如下: $1=b^{\\tiny\\dfrac{0}{n}}&lt;b^{\\tiny\\dfrac{1}{n}}&lt;b^{\\tiny\\dfrac{2}{n}}&lt;…&lt;b^{\\tiny\\dfrac{n}{n}}=b$ 其中 $\\Delta x_{i}=b^{\\tiny{\\dfrac {i+1} {n}}}-b^{\\tiny{\\dfrac{1}{n}}}$ 是区间 $[b^{\\tiny{\\dfrac{i}{n}}},b^{\\tiny{\\dfrac{i+1}{n}}}]$ 的长度，最大的长度: $\\lambda=max_{\\tiny{0\\leq i \\leq n-1}}\\Delta x_i\\leq b(b^{\\tiny\\dfrac{1}{n}}-1)\\rightarrow0$, $\\xi_i=b^{\\tiny\\dfrac{2i+1}{2n}}\\in[b^{\\tiny{\\dfrac{i}{n}}},b^{\\tiny{\\dfrac{i+1}{n}}}]$ 是小区间两端点的比例中项. 因此原极限= $\\int _{1}^{b}sin\\: xdx=cos\\:1-cos\\:b$. THE END.","categories":[{"name":"定积分","slug":"定积分","permalink":"http://ai.wisim.me/categories/定积分/"}],"tags":[{"name":"定积分的精确定义","slug":"定积分的精确定义","permalink":"http://ai.wisim.me/tags/定积分的精确定义/"}]},{"title":"20170928.2","slug":"2017-09-28-2","date":"2017-09-27T17:06:37.000Z","updated":"2017-09-30T14:08:47.000Z","comments":true,"path":"2017/09/28/2017-09-28-2/","link":"","permalink":"http://ai.wisim.me/2017/09/28/2017-09-28-2/","excerpt":"题 2:设 y=f(x) 在(-1,1)内有二阶连续导数，且f’’(x)≠0. 证明 (1) 对于任意非零x∈(-1,1),存在唯一 θ(x)∈(0,1), 使得 f(x)=f(0)+xf’[ θ(x),x] 成立； (2) $\\lim _{x\\rightarrow 0^{+}}\\theta \\left( x\\right) =\\dfrac {1} {2}$.","text":"题 2:设 y=f(x) 在(-1,1)内有二阶连续导数，且f’’(x)≠0. 证明 (1) 对于任意非零x∈(-1,1),存在唯一 θ(x)∈(0,1), 使得 f(x)=f(0)+xf’[ θ(x),x] 成立； (2) $\\lim _{x\\rightarrow 0^{+}}\\theta \\left( x\\right) =\\dfrac {1} {2}$. 证明:(1) 对于f(x)在[0,1]上使用拉格朗日定理，得:f(x)-f(0)=xf’[0+θ(x)*(x-0)], f(x)=f(0)+xf’(θ(x)*x). 又f’’(x)≠在[0,1]内连续且f’’(x)≠0,故保号，于是不妨设f’’(x)&gt;0.所以f’(x)严格单调，所以θ(x)唯一. (2) 由泰勒公式有 $f\\left( x\\right) =f\\left( 0\\right) +f’\\left( 0\\right)x +\\dfrac {1} {2}f’’(\\varepsilon )x ^{2}$ 又由(1)中的拉格朗日定理可知：f(x)=f(0)+xf’[θ(x)]. 所以: $f(0)+xf’[θ(x)*x] =f\\left( 0\\right) +f’\\left( 0\\right)x +\\dfrac {1} {2}f’’(\\varepsilon )x ^{2}$ =&gt; $xf’[θ(x)*x] =f’\\left( 0\\right)x +\\dfrac {1} {2}f’’(\\varepsilon )x ^{2}$ =&gt; $\\dfrac {f’[θ(x)*x]-f’(0)}{x} =\\dfrac {1} {2}f’’(\\varepsilon )$ =&gt; $\\lim _{x\\rightarrow 0^{+}} \\dfrac {f’[0+θ(x)*x]-f’(0)} {θ(x)x} θ(x)$ $=\\lim _{x\\rightarrow 0^{+}}f’’(0)*θ(x)$ $=\\lim _{x\\rightarrow 0^{+}}\\dfrac {1} {2}f’’(\\varepsilon ) =\\dfrac {1} {2}f’’(0)$ =&gt; $\\lim _{x\\rightarrow 0^{+}}f’’(0)*θ(x)=\\dfrac {1} {2}f’’(0)$ 因此 $\\lim _{x\\rightarrow 0^{+}}θ(x)=\\dfrac {1} {2}$ THE END.","categories":[{"name":"中值定理","slug":"中值定理","permalink":"http://ai.wisim.me/categories/中值定理/"}],"tags":[{"name":"拉格朗日定理","slug":"拉格朗日定理","permalink":"http://ai.wisim.me/tags/拉格朗日定理/"},{"name":"泰勒公式","slug":"泰勒公式","permalink":"http://ai.wisim.me/tags/泰勒公式/"}]},{"title":"20170927.1","slug":"2017-09-27-1","date":"2017-09-26T16:00:00.000Z","updated":"2017-09-30T14:08:40.000Z","comments":true,"path":"2017/09/27/2017-09-27-1/","link":"","permalink":"http://ai.wisim.me/2017/09/27/2017-09-27-1/","excerpt":"题 1:设 $0 &lt; a &lt; b$ ,证明：$\\ln \\dfrac {b} {a}&gt;2\\dfrac {b-a} {b+a}$.","text":"题 1:设 $0 &lt; a &lt; b$ ,证明：$\\ln \\dfrac {b} {a}&gt;2\\dfrac {b-a} {b+a}$. 证明:$\\ln \\dfrac {b} {a}&gt;\\dfrac {\\dfrac {b} {a}-1} {\\dfrac {b} {a}+1}$ , 令 $\\dfrac {b} {a}=x$ , 即证 $\\ln x&gt;2\\dfrac {x-1} {x+1}$。 令 F(x) = (1+x)lnx-2(x-1) ，则：$F’\\left( x\\right) =\\dfrac {1} {x}+\\ln x-1$$F’’\\left( x\\right) =-\\dfrac {1} {x^{2}}+\\dfrac {1} {x}=\\dfrac {1} {x}\\left( 1-\\dfrac {1} {x}\\right) &gt; 0$ 因此 F’(x) &gt; F’(1) = 0 ,故 F(x) &gt;F(1)=0。得证。 THE END.","categories":[{"name":"微分不等式","slug":"微分不等式","permalink":"http://ai.wisim.me/categories/微分不等式/"}],"tags":[]},{"title":"Sunday 算法","slug":"2017-04-17-AlogrithmSunday","date":"2017-04-16T16:00:00.000Z","updated":"2018-03-13T12:46:42.000Z","comments":true,"path":"2017/04/17/2017-04-17-AlogrithmSunday/","link":"","permalink":"http://ai.wisim.me/2017/04/17/2017-04-17-AlogrithmSunday/","excerpt":"KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，有一种比BM算法更快的查找算法即Sunday算法。","text":"KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，有一种比BM算法更快的查找算法即Sunday算法。 Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似： 只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1； 否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。 下面举个例子说明下Sunday算法。假定现在要在文本串”substring searching algorithm”中查找模式串”search”。 1.刚开始时，把模式串与文本串左边对齐： 2.结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图： 3.结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下： 4.匹配成功。 回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。 THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://ai.wisim.me/tags/字符串匹配/"}]},{"title":"Print all sub-array with 0 sum","slug":"2017-04-19-AlogrithmPrintSubarray ","date":"2017-04-16T16:00:00.000Z","updated":"2018-03-13T12:46:11.000Z","comments":true,"path":"2017/04/17/2017-04-19-AlogrithmPrintSubarray /","link":"","permalink":"http://ai.wisim.me/2017/04/17/2017-04-19-AlogrithmPrintSubarray /","excerpt":"1234567891011121314151617Given an array of integers, print all subarrays having 0 sum.For example,Input: &#123; 4, 2, -3, -1, 0, 4 &#125;Sub-arrays with 0 sum are&#123; -3, -1, 0, 4 &#125;&#123; 0 &#125;Input: &#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125;Sub-arrays with 0 sum are&#123; 3, 4, -7 &#125;&#123; 4, -7, 3 &#125;&#123; -7, 3, 1, 3 &#125;&#123; 3, 1, -4 &#125;&#123; 3, 1, 3, 1, -4, -2, -2 &#125;&#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125;","text":"1234567891011121314151617Given an array of integers, print all subarrays having 0 sum.For example,Input: &#123; 4, 2, -3, -1, 0, 4 &#125;Sub-arrays with 0 sum are&#123; -3, -1, 0, 4 &#125;&#123; 0 &#125;Input: &#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125;Sub-arrays with 0 sum are&#123; 3, 4, -7 &#125;&#123; 4, -7, 3 &#125;&#123; -7, 3, 1, 3 &#125;&#123; 3, 1, -4 &#125;&#123; 3, 1, 3, 1, -4, -2, -2 &#125;&#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125; 意思就是给定一个数组，找到所有和为0的子数组。 解法1：暴力求解双重循环，从当前数组开始往后遍历，找到和为0的子数组。时间复杂度是O(n^3)，其中O(n^2)用于遍历出子数组，O(n)用于计算和。 解法2：使用HashMap来解决构造一个 Map&lt;Integer, ArrayList&gt; hashMap 用来存放遍历数组，以当前位置（包含当前位置）之前的所有元素之和sum为key，如果hashMap中不存在这个key，则将这个key插入到hashMap中，并将这个元素所在位置插入到对应的ArrayList中。如果hashMap中已经存在这个key，则遍历key对应的ArrayList，以ArrayList中(每个元素所在位置+1)为起始值，当前元素所在位置为结束值，这之间的子数组的和就是0，接着还是要把当前位置插入到已经存在的key所对应的ArrayList中。 举个例子：数组{ 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 }我们来一步一步的分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374(1)首先初始化的时候插入key为0，对应的ArrayList中插入-1，这样以后如果找到子数组就是从位置0开始了。插入之后hashMap的内容是：&#123;0,[-1]&#125;(2)位置0的元素为3，hashMap中不含(0+3=3)。插入之后hashMap的内容是：&#123;0,[-1]&#125;,&#123;3,[0]&#125;(3)位置1的元素是4,hashMap中不含(3+4=7)，插入之后hashMap的内容是：&#123;0,[-1]&#125;,&#123;3,[0]&#125;,&#123;7,[1]&#125;(4)位置2的元素是-7,hashMap包含(-7+7=0)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0]&#125;,&#123;7,[1]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[0,1,2](5)位置3的元素是3,hashMap包含(0+3=3)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[1,2,3](6)位置4的元素是1,hashMap不含(1+3=4)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1]&#125;,&#123;4,[4]&#125;(7)位置5的元素是3,hashMap包含(4+3=7)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[2,3,4,5](8)位置6的元素是1,hashMap不含(7+1=8)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4]&#125;,&#123;8,[6]&#125;(9)位置7的元素是-4,hashMap包含(-4+8=4)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4,7]&#125;,&#123;8,[6]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[5,6,7](10)位置8的元素是-2,hashMap包含(-2+4=2)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4,7]&#125;,&#123;8,[6]&#125;,&#123;2,[8]&#125;(11)位置9的元素是-2,hashMap包含(-2+2=0)，插入之后hashMap的内容是：&#123;0,[-1,2,9]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4,7]&#125;,&#123;8,[6]&#125;,&#123;2,[8]&#125;并且此时有两个满足条件的子数组，对应的位置序列：[0,1,2,3,4,5,6,7,8,9][3,4,5,6,7,8,9] 来总结一下这种解法的:这种解法的时间复杂度是O(n)。初始化的时候向hashMap中插入了key为0的一个元素，这一步很重要。之后从数组中遍历出的元素累加，每次累加得到的结果肯定会发生变化。如果发现某一次累加之后的值之前已经出现过一次，说明什么，说明在第一次出现这个值之后中间的累加操作一定会使得第一次之后（不包含第一次）到第二次（包含第二次）的和的值为0。 ￼￼结合下面这张折线图来看一下： 从-1位置开始，初始sum为0，经过了0，1，2三个位置的元素累加之后，sum又重新变为0。这期间发生了什么呢，依次发生了+3，+4，-7的操作，所以一旦发现两次的累加的和相等的话，表明这之间一定经过了和为0的加减操作。同理，其他几个位置的变化也是如此。 我们再用数学公式抽象一下：设从 0 到 i 位置的累加和为 Si且i位置的元素为e[i]，从 0 到 n 位置的累加和为 Sn且n位置的元素为e[n]，Si = Sn。 从累加的定义我们知道： S_{i} + e[i+1] = S_{i+1}于是可以得到： S_i + e[i+1] + e[i+2] + ... + e[n] = S_n又有：S_i = S_n 所以 e[i+1] + e[i+2] + ... + e[n] = 0 。也就是从 i+1 开始到 n 的子数组之和为0 Link : find-sub-array-with-0-sum THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://ai.wisim.me/tags/DP/"}]},{"title":"学习MachineLearning过程中的一些问题","slug":"2017-03-05-MachineLearningFAQ","date":"2017-03-04T16:00:00.000Z","updated":"2018-03-13T12:46:59.000Z","comments":true,"path":"2017/03/05/2017-03-05-MachineLearningFAQ/","link":"","permalink":"http://ai.wisim.me/2017/03/05/2017-03-05-MachineLearningFAQ/","excerpt":"环境相关 python Anaconda Anaconda 本质上是一个软件发行版 ，包含了 conda、Python 等 180 多个科学包及其依赖项。 pydot pydot是用python实现的绘制graphviz的接口。 graphviz Graphviz的是AT&amp;T Labs Research开发的图形绘制工具软件如果运行过程中报出 Exception: &quot;dot&quot; not found in path. 则需要安装 graphviz，如果已经安装了Anacoda，直接执行 conda install graphviz。","text":"环境相关 python Anaconda Anaconda 本质上是一个软件发行版 ，包含了 conda、Python 等 180 多个科学包及其依赖项。 pydot pydot是用python实现的绘制graphviz的接口。 graphviz Graphviz的是AT&amp;T Labs Research开发的图形绘制工具软件如果运行过程中报出 Exception: &quot;dot&quot; not found in path. 则需要安装 graphviz，如果已经安装了Anacoda，直接执行 conda install graphviz。 概念问题 分类 聚类 回归 异常检测 关联规则 强化学习 结构预测 特征学习 在线学习 半监督学习 语法归纳 监督学习 分类 ： 输出值如果是不连续的监督学习算法称为分类器（classifier）。 回归 ： 输出值连续的监督学习算法称为回归函数（regression function）。 线性回归 代价函数 ： J(\\theta)=\\frac{1}{2m}\\sum_{i=1}^m{({h_\\theta }({x^{(i)}})-{y^{(i)}})^{2}}向量化实现 : J(\\theta)=\\frac{1}{2m}(X*\\theta-\\vec{y})^{T} (X*\\theta-\\vec{y}) 归一化 : y_{i}=\\frac{x_{i}-\\overline{x}}{s(x)} 梯度下降算法 : 代价函数对 \\theta_j 求偏导得到 : \\frac{\\partial{J(\\theta)}}{\\partial{\\theta_j}} = \\frac{1}{m}\\sum\\limits_{i = 1}^m {[({h_\\theta }({x^{(i)}})-{y^{(i)}})x_j^{(i)}]}所以对 \\theta 的更新可以写为 : {\\theta_j}={\\theta_j}-\\alpha\\frac{1}{m}\\sum\\limits_{i=1}^m {[({h_\\theta }({x^{(i)}})-{y^{(i)}})x_j^{(i)}]} 向量化实现 : {\\theta_j} = {\\theta_j}-{\\alpha\\frac{1}{m}(X^T(X*{\\theta- \\vec{y}}))} 分类器 人工神经网络 支持向量机（support vector machine） 最邻近法 高斯混合模型 朴素贝叶斯法 决策树（decision tree） 径向量函数分类 解决步骤 决定训练的样本类型 搜集训练集 决定学习函数的特征表示 决定学习函数的结构以及对应的学习算法 完成设计 评价学习函数的准确性 决策树 表征（装袋, 提升，随机森林） k-NN 线性回归 朴素贝叶斯 神经网络 逻辑回归 感知器 支持向量机（SVM） 相关向量机（RVM） 聚类 BIRCH 层次 k平均 期望最大化（EM） DBSCAN OPTICS 均值飘移 降维 因子分析 CCA ICA LDA NMF PCA LASSO t-SNE 结构预测 概率图模型（贝叶斯网络，CRF, HMM） 异常检测 k-NN 局部离群因子 神经网络 自编码 深度学习 多层感知机 RNN 受限玻尔兹曼机 SOM CNN 理论 偏差/方差偏置(Bias-Variance Tradeoff)：一般而言高偏差意味着欠拟合，高方差意味着过拟合 计算学习理论 经验风险最小化 PAC学习 统计学习 VC理论 THE END.","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://ai.wisim.me/categories/MachineLearning/"}],"tags":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://ai.wisim.me/tags/MachineLearning/"}]},{"title":"LeetCode:70. Climbing Stairs","slug":"2016-08-21-LeetCodeClimbingStairs","date":"2016-08-20T16:00:00.000Z","updated":"2018-03-13T12:48:20.000Z","comments":true,"path":"2016/08/21/2016-08-21-LeetCodeClimbingStairs/","link":"","permalink":"http://ai.wisim.me/2016/08/21/2016-08-21-LeetCodeClimbingStairs/","excerpt":"LeetCode:70. Climbing Stairs12You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?","text":"LeetCode:70. Climbing Stairs12You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 题目的意思就是让你爬n阶提子，但是每次只能爬一个阶梯或者两个阶梯。让你求出所有的可能性。 想想看，由于只能爬1或者2，所以我们爬一个阶梯只有一种可能性，但是爬两个阶梯就有两种可能，也就是两个1或者一个2。 这样举个例子，思考一下，因为只能爬1或者2个阶梯，所以爬到4只有两个可能，就是从3爬一步爬到4或者从2爬两步爬到4。因此爬到4的可能性也就确定了，也就是从0爬到3的可能性以及从0爬到2的可能性之和。再往前看，爬到3有几种可能：从1爬两步爬到3，以及从2爬一步爬到3。爬到2的可能性：从1爬一步到2或者从0爬两步到2。这样就可以算到从0爬到4的可能性了。来看一下Java代码实现 ： 123456789101112131415161718192021222324252627public class Solution &#123; public int climbStairs(int n) &#123; //将1，2两种步伐抽象成一个数组，这样下面的代码对其他的步伐也适用 int[] arr = new int[]&#123;1,2&#125;; //每个阶梯的可能的情况都放在res数组对应的位置 int[] res = new int[n+1]; if(n &lt; arr[0]) &#123; return 0; &#125; for(int i = 1 ; i &lt; n+1 ; i++) &#123; //循环每种步伐 for(int j = 0 ; j &lt; arr.length;j++) &#123; if(i == arr[j]) &#123; //如果等于步伐中的某一步，则该位置的结果增加自身这一种可能性 res[i]+=1; &#125; else if(i &gt; arr[j])&#123; //如果大于步伐，则减去该步伐所得位置的可能性要加在当前位置的可能性里面。 res[i]+=res[i-arr[j]]; &#125; else &#123; break; &#125; &#125; //System.out.println(i+ \" : \" +res[i]); &#125; return res[n]; &#125;&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:377. Combination Sum IV","slug":"2016-08-20-LeetCodeCombinationSumIV","date":"2016-08-19T16:00:00.000Z","updated":"2018-03-13T12:48:24.000Z","comments":true,"path":"2016/08/20/2016-08-20-LeetCodeCombinationSumIV/","link":"","permalink":"http://ai.wisim.me/2016/08/20/2016-08-20-LeetCodeCombinationSumIV/","excerpt":"LeetCode:377. Combination Sum IV12345678910111213141516171819Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.Example:nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7.","text":"LeetCode:377. Combination Sum IV12345678910111213141516171819Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.Example:nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. 题目的意思就是给你一个正整数数组，里面的元素不重复（未排序）。再给你一个目标数值，要你用数组里面的数组合起来的和是目标数值，求出有多少种可能。 这道题目有点像那个爬梯子的题目。同时也可以看看这篇文章ClimbingStairs。 两道题目有异曲同工之妙，我们来思考一下这道题目。如果我要求和为4的所有可能性，首先要求(4-1),(4-2),(4-3)的可能性，它们的和就是4的可能性。来看一下Java代码实现： 123456789101112131415161718public class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; Arrays.sort(nums); int[] res = new int[target+1]; for (int i = 1 ; i &lt; target+1;i++) &#123; for(int num : nums) &#123; if(i == num) &#123; res[i]+=1; &#125; else if(i &gt; num) &#123; res[i]+= res[i-num]; &#125; else &#123; break; &#125; &#125; &#125; return res[target]; &#125;&#125; THE END","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:385. Mini Parser","slug":"2016-08-18-LeetCodeMinParser","date":"2016-08-17T16:00:00.000Z","updated":"2018-03-13T12:48:36.000Z","comments":true,"path":"2016/08/18/2016-08-18-LeetCodeMinParser/","link":"","permalink":"http://ai.wisim.me/2016/08/18/2016-08-18-LeetCodeMinParser/","excerpt":"LeetCode:385. Mini Parser123456789Given a nested list of integers represented as a string, implement a parser to deserialize it.Each element is either an integer, or a list -- whose elements may also be integers or other lists.Note: You may assume that the string is well-formed:String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,, ].","text":"LeetCode:385. Mini Parser123456789Given a nested list of integers represented as a string, implement a parser to deserialize it.Each element is either an integer, or a list -- whose elements may also be integers or other lists.Note: You may assume that the string is well-formed:String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,, ]. 题目的意思就是给你一个由好多int值嵌套在一起的字符串。让你写一个解析器，把里面的元素解析出来。每个元素呢，要么是一个int值，要么是一个列表，而这个列表的元素又可以是int或者其他列表，如此嵌套而成。几个注意点：给定的字符创不为空且不含空格，只包含0-9以及[]还有,和-。 讲讲思路先 遇到’[‘字符肯定是要产生一个新的 NestedInteger 对象的。 遇到’]’字符则表明上一个元素可以结束了，此时要处理这里面的整型字符串，将其解析成int值再传给当前的NestedInteger对象。并且呢，由于当前元素已经结束解析，还需要将它传给它的父NestedInteger。 遇到’,’字符要分情况了，如果它的前一个字符是’]’则表明在步骤2种已经做了处理了，否则的话说明之前的整型字符串还没有解析。 如果遇到了0到9还有－，则暂时不作处理，将其拼接到一个StringBuilder里面。 看看Java代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public NestedInteger deserialize(String s) &#123; if (s.isEmpty()) return null; if (s.charAt(0) != '[') // ERROR: special case return new NestedInteger(Integer.valueOf(s)); //stack 用于保存上一个 NI 对象 Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;(); //curNi用于保存当前 NI 对象 NestedInteger curNi = null; StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; s.length() ; i++ ) &#123; char c = s.charAt(i); if(c == '[') &#123; //如果当前 curNi 不为空，则 curNi 临时push进 stack if(curNi != null) &#123; stack.push(curNi); &#125; //并且遇到'['之后要实例化新的 curNi curNi = new NestedInteger(); &#125; else if (c == ']') &#123; //遇到']'之后，就要把之前的字符串解析成int了 if(sb.length() &gt;0) &#123; curNi.add(new NestedInteger(Integer.parseInt(sb.toString()))); sb.setLength(0); &#125; //如果 stack 不为空则把 curNi 添加到 stack的顶层NI 中。 if(!stack.empty()) &#123; NestedInteger popNi = stack.pop(); popNi.add(curNi); curNi = popNi; &#125; &#125; else if (c == ',')&#123; //如果前一个元素是]，则已经处理；如果不是，则要把前面的元素解析成int if(s.charAt(i-1) != ']') &#123; curNi.add(new NestedInteger(Integer.parseInt(sb.toString()))); sb.setLength(0); &#125; &#125; else &#123; sb.append(c); &#125; &#125; return curNi; &#125;&#125; 我们这里再来拿一个字符串来讨论看看，对于字符串”[-1,[123],[[3]]]” 首先遇到’[‘产生一个NestedInteger，对应着最外层的NestedInteger， 记作NI1，并赋值给curNi(NI1)； 接着向后遍历，直到遇到了第一个’,’，此时要为前面的整型值’-1’实例化一个NestedInteger对象，并插入到最外层的curNi(NI1)； 继续向后遍历，遇到第二个’[‘，先将curNi(NI1)压入stack中，再实例化一个新的NestedInteger对象，记作NI2，且令赋值给curNi(NI2)； 向后遍历，遇到第二个’[‘所对应的’]’，为前面的整型值’123’实例化一个NestedInteger对象，add进curNI(NI2)中。再弹出stack中的NI1对象，将curNI(NI2)add到NI中，再令curNi ＝ NI1，注意此时stack中已空； 继续，遇到第二个’,’但是发现它的前一个字符是’]’，不作处理； 继续遍历，遇到第三个’[‘，先将curNI(NI1)压入stack中。再实例化一个新的NestedInteger对象，记作NI3，令curNI = NI3； 继续遍历，遇到第四个’[‘，先将curNI(NI3)压入stack中。再实例化一个新的NestedInteger对象，记作NI4，令curNI = NI4； 继续遍历，遇到第四个’[‘所对应的’]’，为’3’实例化一个NestedInteger对象，插入到curNI(NI4)中。从stack中弹出NI3，将curNI(NI4)插入到NI3中，且令curNI = NI3； 继续遍历，遇到第三个’[‘所对应的’]’，前面没有未处理的整型字符串。此时stack里面还有一个NI1，弹出NI1，将curNI(NI3)add给NI1，且令curNI = NI1； 到了最后一个’]’，也对应了第一个’]’，此时stack为空，且没有未处理的字符串了。此时，curNI就对应了最外层的那个NestedInteger，是不是很神奇。结束。 THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:378. Kth Smallest Element in a Sorted Matrix","slug":"2016-08-13-LeetCodeKthSmallest","date":"2016-08-12T16:00:00.000Z","updated":"2018-03-13T12:48:39.000Z","comments":true,"path":"2016/08/13/2016-08-13-LeetCodeKthSmallest/","link":"","permalink":"http://ai.wisim.me/2016/08/13/2016-08-13-LeetCodeKthSmallest/","excerpt":"LeetCode:378. Kth Smallest Element in a Sorted Matrix12345678910111213Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.Note that it is the kth smallest element in the sorted order, not the kth distinct element.Example:matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13.Note:You may assume k is always valid, 1 ≤ k ≤ n2.","text":"LeetCode:378. Kth Smallest Element in a Sorted Matrix12345678910111213Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.Note that it is the kth smallest element in the sorted order, not the kth distinct element.Example:matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13.Note:You may assume k is always valid, 1 ≤ k ≤ n2. 题目的意思呢就是给你一个n x n的矩阵，而这个矩阵的每一行以及每一列的元素大小都是递增（也可以相等）。让你找到第k小的那个元素。值得注意的是第k小的意思并不是绝对第k小。怎么讲呢，比如上面的example中的两个13，它们分别是第7小和第8小。也就是想等的元素也各自算一个k。 拿到手第一个想到的动态规划，不过后来发现题目理解错了，那就快排呗，不过这也达不到hard的level啊。构造一个搜索二叉树？嗯也是可以的，不过代价还是有点大。看了讨论之后发现居然直接可以使用 PriorityQueue 来解决。我真是越来越不懂这套路了。 优先队列PriorityQueue的本质是最小堆，每次插入和删除时都会动态更新堆中元素的位置。这就给我们提供了方便的解法了。 后来转念一想，干嘛不直接放到List里面，然后一顿排序。岂不快哉。 看一下Java代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class KthSmallest &#123; public int kthSmallest(int[][] matrix, int k) &#123; Comparator&lt;Integer&gt; comparator = new IntegerLengthComparator(); PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(10, comparator); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; queue.add(matrix[i][j]); &#125; &#125; int pos=0; while (queue.size() &gt; 0) &#123; pos++; if (pos == k) &#123; return queue.poll(); &#125; queue.poll(); &#125; return -1; &#125; public int kthSmallestList(int[][] matrix, int k) &#123; Comparator&lt;Integer&gt; comparator = new IntegerLengthComparator(); List&lt;Integer&gt; queue = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; queue.add(matrix[i][j]); &#125; &#125; Collections.sort(queue,comparator); return queue.get(k-1); &#125; public static class IntegerLengthComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer x, Integer y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0; &#125; &#125;&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:384. Shuffle an Array","slug":"2016-08-12-LeetCodeShuffleArray","date":"2016-08-11T16:00:00.000Z","updated":"2018-03-13T12:48:41.000Z","comments":true,"path":"2016/08/12/2016-08-12-LeetCodeShuffleArray/","link":"","permalink":"http://ai.wisim.me/2016/08/12/2016-08-12-LeetCodeShuffleArray/","excerpt":"LeetCode:384. Shuffle an Array Shuffle a set of numbers without duplicates.","text":"LeetCode:384. Shuffle an Array Shuffle a set of numbers without duplicates. 洗牌算法，题目的意思就是交换数组元素的位置，并且保证每种情况出现的概率是一样大。 一开始的思路呢，就是生成一个随机数(0到数组长度之间)，把这个随机数对应位置元素插入到一个等长的新数组中，如果生成的随机数已经出现过，则继续生成。直到新的数组放满。 后来呢，发现重复生成随机数会导致Time Limit Exceeded。值得再考虑考虑了。怎样才能保证生成的随机数即使重复了也有效呢。 首先在数组末尾设置一个标兵。每次生成的随机数（0到标兵位置之间）,把对应位置的元素和数组的标兵元素交换，标兵再向前移动一位。 这样就保证了即使随机数重复，对应位置的元素由于之前已经交换过，所以实际位置的元素并不会重复。而标兵位置之后的元素都是已经出现过的不会再出现了。看一下Java代码实现： 12345678910111213141516171819202122232425262728293031import java.util.Random;public class Solution &#123; private int[] mNums; public Solution(int[] nums) &#123; mNums = nums; &#125; public int[] reset() &#123; return mNums; &#125; public int[] shuffle() &#123; int len = mNums.length; int pos = len-1; int[] arr = new int[len]; for(int i = 0 ; i &lt; len;i++) &#123; arr[i] = mNums[i]; &#125; Random random = new Random(); while(pos &gt; 0) &#123; int ranNum = random.nextInt(pos+1); int temp = arr[pos]; arr[pos] = arr[ranNum]; arr[ranNum] = temp; pos--; &#125; return arr; &#125;&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:381. Insert Delete GetRandom O(1)","slug":"2016-08-12-LeetCodeInsertDeleteGetRandom","date":"2016-08-11T16:00:00.000Z","updated":"2018-03-13T12:48:46.000Z","comments":true,"path":"2016/08/12/2016-08-12-LeetCodeInsertDeleteGetRandom/","link":"","permalink":"http://ai.wisim.me/2016/08/12/2016-08-12-LeetCodeInsertDeleteGetRandom/","excerpt":"LeetCode:381. Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time.Note: Duplicate elements are allowed.insert(val): Inserts an item val to the collection.remove(val): Removes an item val from the collection if present.getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.","text":"LeetCode:381. Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time.Note: Duplicate elements are allowed.insert(val): Inserts an item val to the collection.remove(val): Removes an item val from the collection if present.getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains. 题目的意思是要你设计一个数据结构，使得它的插入和删除时间复杂度都是O(1)，并且能够随机返回一个元素，而返回这个元素的概率也是和这个元素的个数是线性相关的。允许插入相同的元素。 说实话一看到这个题目我是没有思路的。我想这总不至于让你设计一个和HashMap一样的数据结构吧。看了一下别人的解法，确实不至于。要说的是这个数据结构内部可以使用HashMap，而不必自己从0开始写一个。 来说一下大概的思路吧，这个数据结构暂且就叫 RandomizedCollection ，它有一个 Map","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:383. Ransom Note","slug":"2016-08-11-LeetCodeRansomNote","date":"2016-08-10T16:00:00.000Z","updated":"2018-03-13T12:48:48.000Z","comments":true,"path":"2016/08/11/2016-08-11-LeetCodeRansomNote/","link":"","permalink":"http://ai.wisim.me/2016/08/11/2016-08-11-LeetCodeRansomNote/","excerpt":"eetCode:383. Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines,write a function that will return true if the ransom note can be constructed from the magazines ;otherwise,it will return false.Each letter in the magazine string can only be used once in your ransom note.Note:You may assume that both strings contain only lowercase letters.","text":"eetCode:383. Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines,write a function that will return true if the ransom note can be constructed from the magazines ;otherwise,it will return false.Each letter in the magazine string can only be used once in your ransom note.Note:You may assume that both strings contain only lowercase letters. 题目的意思就是给你两个字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，第二个字符里的每个字符只能使用一次。（假设只包含小写字母） 那么首先想到的就是穷举法了，两层遍历即可，也就是下面的 canConstruct 方法了。 再思考一下，有个小技巧。这里只要判断两个字符串中每个字母出现的次数即可解决问题。对于某个字母来说，如果第ransom字符串中出现的次数比magazines中出现的次数要多，很显然就直接返回false了。 看一下 canConstructBetter 方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.List;import java.util.ArrayList;public class Solution &#123; public boolean canConstructBetter(String ransomNote, String magazine) &#123; if (ransomNote.equals(magazine) || \"\".equals(ransomNote)) &#123; return true; &#125; if (\"\".equals(magazine) &amp;&amp; !\"\".equals(ransomNote)) &#123; return false; &#125; int[] ransomNoteCharCount = new int[26]; int[] magazineCharCount = new int[26]; for(int i = 0 ; i &lt; ransomNote.length() ; i++) &#123; ransomNoteCharCount[ransomNote.charAt(i)-'a']++; &#125; for(int i = 0 ; i &lt; magazine.length() ; i++) &#123; magazineCharCount[magazine.charAt(i)-'a']++; &#125; for(int i = 0 ; i &lt; 26 ; i++) &#123; if(ransomNoteCharCount[i] &gt; magazineCharCount[i] ) &#123; return false; &#125; &#125; return true; &#125; public boolean canConstruct(String ransomNote, String magazine) &#123; if (ransomNote.equals(magazine)) &#123; return true; &#125; if (\"\".equals(ransomNote)) &#123; return true; &#125; List&lt;Character&gt; ransomNodeChars = new ArrayList&lt;&gt;(); List&lt;Character&gt; magazineChars = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; ransomNote.length() ; i++) &#123; ransomNodeChars.add(ransomNote.charAt(i)); &#125; this.printList(ransomNodeChars); for(int j = 0 ; j &lt; magazine.length() ; j++) &#123; magazineChars.add(magazine.charAt(j)); &#125; boolean flag = false; Character c = null; for(int m = 0 ; m &lt; ransomNote.length() ; m++) &#123; c = ransomNodeChars.get(m); flag = false; for(int n = 0 ; n &lt; magazineChars.size() ; n++) &#123; if(magazineChars.get(n) == c) &#123; flag = true; magazineChars.remove(n); break; &#125; &#125; if (flag == false) &#123; break; &#125; &#125; return flag; &#125;&#125; THE END","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:382. Linked List Random Node","slug":"2016-08-10-LeetCodeLinkedListRandomNode","date":"2016-08-09T16:00:00.000Z","updated":"2018-03-13T12:48:51.000Z","comments":true,"path":"2016/08/10/2016-08-10-LeetCodeLinkedListRandomNode/","link":"","permalink":"http://ai.wisim.me/2016/08/10/2016-08-10-LeetCodeLinkedListRandomNode/","excerpt":"LeetCode:382. Linked List Random Node Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?","text":"LeetCode:382. Linked List Random Node Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? 题目的意思就是给你一个链表，要你从链表中取出一个值，并且保证取到每个元素的概率都是相等的。还要思考如果链表长度极其大，咋办。能不能不使用额外的空间就能达到目的。 一开始我的想法就是直接遍历一次拿到链表的长度，再生成一个随机值，拿到这个值对应位置的元素即可。但是我觉得这种解法完全达不到Medium的难度啊。看了讨论学又到一个新词：蓄水池抽样算法。 蓄水池抽样算法的结论就是：在N（N不确定）个元素中取出K个元素的概率就是 K/N。这里我们令K等于1，就可以用来解上面的这道题目了。Java代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Random;public class Solution &#123; private Random mRandom; private ListNode head; public Solution(ListNode head) &#123; this.head=head; &#125; /** *蓄水池抽样算法 */ public int getRandom() &#123; mRandom=new Random(); int pos = 1; ListNode node = head; ListNode res = head; while(node != null) &#123; //一直取最末尾的一个数 if (mRandom.nextInt(pos) == (pos-1)) &#123; res = node;//此处不可直接return。取第一个值的时候概率是百分之百，直接返回。 &#125; pos = pos+1; node = node.next; &#125; return res == null ? head.val : res.val; &#125; /** *先获取长度再取随机值的方法 */ public int getRandomXX() &#123; int randomVaule = mRandom.nextInt(this.getLength()); int pos = 0; ListNode res = head; while(res != null) &#123; if(pos == randomVaule) &#123; return res.val; &#125; res = res.next; pos++; &#125; return res.val; &#125; public int getLength() &#123; int len = 0; ListNode node = head; while(node != null) &#123; len++; node = node.next; &#125; return len; &#125;&#125; 那么为什么蓄水池抽样算法会保证每个元素被取到的概率是一样的呢？让我们一步一步来验证一下。 我们这里来考察选择最后一个元素的概率。 首先如果只有一个元素的时候，概率是1； 如果有两个元素，取到第二个元素的概率是1/2； 如果有三个元素，要保证每个元素取到的概率都是一样，有两种情况，第一种就是取第三个元素，取到的概率是1/3。但是如果不是取到第三个元素，而是取到第二个呢？那就是下面这种情况 ： 取不到第三个元素的概率 x 取到第二个元素的概率 = (2/3) x (1/2) = 1/3 可以用数学归纳法来证明一下： 假设已经读取n个数，现在保留的数是An，取到An的概率为(1/n)。 123456789101112131415对于第n+1个数An+1，以1/(n+1)的概率取An+1，否则仍然取An。依次类推，可以保证取到数据的随机性。数学归纳法证明如下： 当n=1时，显然，取A1。取A1的概率为1/1。 假设当n=Max时，取到的数据AMax。取AMax的概率为1/Max。 当n=Max+1时，以1/(Max+1)的概率取AMax+1，否则仍然取AMax。 (1)如果取AMax+1，则概率为1/(Max+1)； (2)如果不取AMax+1而仍然取AMax，则概率为(1/Max)*(Max/(Max+1))=1/(Max+1)所以，对于之后的第n+1个数An+1，以1/(n+1)的概率取An+1，否则仍然取An。依次类推，可以保证取到数据的随机性。 THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"常用的Latex公式","slug":"1970-01-01-01","date":"1969-12-31T16:00:00.000Z","updated":"2017-09-30T23:39:35.000Z","comments":true,"path":"1970/01/01/1970-01-01-01/","link":"","permalink":"http://ai.wisim.me/1970/01/01/1970-01-01-01/","excerpt":"空格直接是 \\:","text":"空格直接是 \\: 1. 极限$\\lim _{\\tiny{x\\rightarrow \\infty} }( b^{\\tiny{\\dfrac {1} {n}}}-1)$ 1$\\lim _&#123;\\tiny&#123;x\\rightarrow \\infty&#125; &#125;(...)$ 2. 字体大小(1) 极小的字体 1\\tiny 3. 角标(1) 右上角 : $b^{\\tiny{\\dfrac {1} {n}}}$ 1$b^&#123;\\tiny&#123;...&#125;&#125;$ (2) 右下角 : $b_{\\tiny{\\dfrac {1} {n}}}$ 1$b_&#123;\\tiny&#123;\\dfrac &#123;1&#125; &#123;n&#125;&#125;&#125;$ 4. 分数形式(1) $\\dfrac{a}{b}$1$\\dfrac&#123;...&#125;&#123;...&#125;$ 5. 希腊字母 字母 源码 $\\pi$ \\pi $\\alpha$ \\alpha $\\beta$ \\beta $\\theta$ \\theta $\\varepsilon$ \\varepsilon $\\delta$ \\delta $\\eta$ \\eta $\\lambda$ \\lambda $\\xi$ \\xi $\\tau$ \\tau $\\psi$ \\psi $\\phi$ \\phi 6. 数学符号 符号 说明 源码 $\\leq$ 小于等于 \\leq $\\geq$ 大于等于 \\geq $\\neq$ 不等于 \\neq $\\in$ 在区间内 \\in $\\cdot$ 点乘 \\cdot $\\sum ^{n}_{i=0} {i\\cdot n}$ 累加 \\sum ^{...}_{...} {...} $\\Delta x_{i}$ delta \\Delta $\\int _{a}^{b}$ 积分 \\int _{a}^{b} THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://ai.wisim.me/tags/TOOLS/"}]}]}