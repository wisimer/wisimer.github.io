{"meta":{"title":"W","subtitle":null,"description":"This is AI of Wisimer","author":"Wisimer","url":"http://ai.wisim.me"},"pages":[{"title":"Categories","date":"2018-02-24T05:24:41.195Z","updated":"2018-02-24T05:24:41.195Z","comments":true,"path":"categories/index.html","permalink":"http://ai.wisim.me/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-02-24T05:24:41.195Z","updated":"2018-02-24T05:24:41.195Z","comments":true,"path":"tags/index.html","permalink":"http://ai.wisim.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Numpy","slug":"2018-05-03_Numpy","date":"2018-05-02T16:00:00.000Z","updated":"2018-05-07T03:08:07.917Z","comments":true,"path":"2018/05/03/2018-05-03_Numpy/","link":"","permalink":"http://ai.wisim.me/2018/05/03/2018-05-03_Numpy/","excerpt":"一、创建ndarray123456789101112131415161718192021222324252627282930import numpy as npa = np.array([1, 2, 3, 4])b = np.array([[1, 2, 3, 4],[4, 5, 6, 7], [7, 8, 9, 10]])# np.ones(x):创建一个长度为x，且元素全为1的ndarrayc = np.ones(2,dtype = np.int)[1, 1]# np.ones(x，y):创建一个长度为x行y列，且元素全为1的ndarrayd = np.ones((3,2))[[1., 1.], [1., 1.], [1., 1.]]# np.zeros(x,y):创建一个x行y列且元素全为0的ndarraye = np.zeros((3,2))[[0., 0.], [0., 0.], [0., 0.]]# np.empty(x,y):创建一个x行y列且未初始化的ndarray(随机数填充数据)f = np.empty((1,2), dtype = int)[[4607182418800017408, 4607182418800017408]]# 使用 np.arange 生成连续元素的ndarrayg = np.arange(6) #从0到6，默认间隔(步长)为1[0, 1, 2, 3, 4, 5]h = np.arange(0,6,2) #从0到6，间隔为2，不包括6[0, 2, 4]","text":"一、创建ndarray123456789101112131415161718192021222324252627282930import numpy as npa = np.array([1, 2, 3, 4])b = np.array([[1, 2, 3, 4],[4, 5, 6, 7], [7, 8, 9, 10]])# np.ones(x):创建一个长度为x，且元素全为1的ndarrayc = np.ones(2,dtype = np.int)[1, 1]# np.ones(x，y):创建一个长度为x行y列，且元素全为1的ndarrayd = np.ones((3,2))[[1., 1.], [1., 1.], [1., 1.]]# np.zeros(x,y):创建一个x行y列且元素全为0的ndarraye = np.zeros((3,2))[[0., 0.], [0., 0.], [0., 0.]]# np.empty(x,y):创建一个x行y列且未初始化的ndarray(随机数填充数据)f = np.empty((1,2), dtype = int)[[4607182418800017408, 4607182418800017408]]# 使用 np.arange 生成连续元素的ndarrayg = np.arange(6) #从0到6，默认间隔(步长)为1[0, 1, 2, 3, 4, 5]h = np.arange(0,6,2) #从0到6，间隔为2，不包括6[0, 2, 4] 1234567# 使用 np.linspace(start, stop, num, endpoint, retstep, dtype) 生成ndarray,num:生成ndarray的元素个数a = np.linspace(1.0, 2.0, num = 10)[1.,1.11111111,1.22222222,1.33333333,1.44444444,1.55555556,1.66666667,1.77777778,1.88888889,2.]# np.logspace(start, stop, num, endpoint, base, dtype) ： 返回一个 ndarray 对象，其实就是linespace生成的元素值对应的base作为底数的幂y = np.logspace(1.0, 2.0, num = 10)[ 10.,12.91549665,16.68100537,21.5443469,27.82559402,35.93813664,46.41588834,59.94842503,77.42636827,100.] 我们来看一下上面生成的两个ndarray所画出的函数是不是10的幂函数图像： 对应代码：123456789plt.subplot(2, 1, 1)plt.xlabel('linspace')plt.ylabel('logspace')plt.plot(a,b,'b-',label='logspace')plt.legend()plt.subplot(2, 1, 2)plt.plot(a,np.power(10,a),'r-',label='10^a')plt.legend()plt.show() 12345678910# np.fromiter(iterable, dtype, count = -1) : 从任何可迭代对象构建一个ndarray对象list = range(5)it = iter(list)# 使用迭代器创建 ndarrayx = np.fromiter(it, dtype = int)[0 1 2 3 4]# np.frombuffer():此函数将缓冲区解释为一维ndarray。但是参数是String类型的会报错误，原因如下：https://stackoverflow.com/questions/43362986/numpy-frombuffer-attributeerror-str-object-has-no-attribute-buffer 二、ndarray的属性1234567891011121314151617181920212223# array.size ndarray元素个数a.size4# array.dtype ndarray元素的类型a.dtypedtype('int64')# array.itemsize ndarray每个元素所占字节大小a.itemsize8 # int64类型大小为8字节# array.ndim ndarray纬度a.nidm1b.ndim2# array.shape ：ndarray各个维度的长度a.shape(4,)b.shape(3,4) 三、ndarray操作单个ndarray操作123456789101112131415161718192021222324252627282930313233# array.sum()：求ndarray所有元素的和值。也可以加上axis参数，求各行或者各列的元素和值# array.min()：求ndarray所有元素中的最小值。也可以加上axis参数，求各行或者各列的元素最小值# array.max()：求ndarray所有元素中的最大值。也可以加上axis参数，求各行或者各列的元素最大值# array.shape = x,y : 通过改变ndarray的shape值，可以改变ndarray的行数和列数.（总数必须一致）b.shape = 4,3[[ 1, 2, 3], [ 4, 4, 5], [ 6, 7, 7], [ 8, 9, 10]]# array.reshape(x,y) 的作用和指定shape值的效果一样，但是会返回一个新的ndarray，并且这个ndarray和原ndarray共享内存，无论修改哪一个ndarray都会引起另外一个ndarray的变化b.reshape(3,4)# array.resize(x,y) 用于原地设置形状,也就是修改的是原ndarray。而reshape和shape都是修改之后返回一个新ndarrayb.resize(2,6)[[ 1, -1, 4, 6, 7, 9], [ 2, 4, 5, 7, 8, 10]]# array.ravel() 将ndarray展开，创建视图,视图和原ndarray共享内存，无论修改哪一个ndarray都会引起另外一个ndarray的变化i = b.ravel()[ 1, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10]# array.flatten() 将ndarray展开，创建副本,副本修改不影响原ndarray变化j = b.flatten()[ 1, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10]# array.transpose() 用于转置矩阵k = b.transpose()[[ 1, 4, 7], [ 2, 5, 8], [-1, 6, 9], [ 4, 7, 10]] 多个ndarray操作1234567891011121314151617181920# np.vstack(a1,a2) : 纵向（vertical）合并两个ndarraya1 = np.array([1,2,3])a2 = np.array([4,5,6])np.vstack((a1,a2))[[1, 2, 3], [4, 5, 6]]# np.hstack(a1,a2) : 横向（horizontal）合并两个ndarraya1 = np.array([1,2,3])a2 = np.array([4,5,6])np.hstack((a1,a2))[1, 2, 3, 4, 5, 6]# np.stach((a1,a2),axis = 1) : axis可以设置堆叠的维度,默认是0，效果和vstack相同，如果设置为1，则是vstack的转置矩阵。a1 = np.array([1,2,3])a2 = np.array([4,5,6])np.stack((a1,a2),axis = 1)[[1, 4], [2, 5], [3, 6]] ndarray分割123456789101112131415# np.vsplit(a,num) : 纵向分割a= np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])np.vsplit(a,3)[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]# np.hsplit(a,num) : 横向分割a= np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])np.hsplit(a,3)[array([[0],[3],[6]]), array([[1],[4],[7]]), array([[2],[5],[8]])]# 也可使用np.split(a, 3, axis=1) 指定axis作为分割方向 四、矩阵运算12345678910111213141516171819202122232425262728293031323334353637# ndarray相乘# *操作符：每个位置的元素对应相乘.术语广播a = np.array([[2,3],[3,4]])b = np.array([[3,4],[5,6]])a * b[[ 6, 12], [15, 24]]a = np.array([[2,3],[3,4]])b = np.array([[3,4],[5,6]])a+b[[ 5, 7], [ 8, 10]]a = np.array([[2,3],[3,4]])b = np.array([[3,4],[5,6]])a-b[[-1, -1], [-2, -2]]a = np.array([[2,3],[3,4]])b = np.array([[3,4],[5,6]])a&gt;b[[False, False], [False, False]]# dot操作符：按照矩阵乘法规则相乘a.dot(b) # 或者np.dot(a,b)[[21, 26], [29, 36]]# 使用 linalg 模块求逆矩阵。import numpy.linalg as nlax = np.array([[1,1],[1,2]])y = nla.inv(x)[[ 2., -1.], [-1., 1.]] linalg 还有其他多种功能。比如：trace:对角线元素之和， det:计算矩阵行列式，等。 五、ndarray数组的基本索引和切片ndarray的基本索引1234x = np.array([[1,2],[3,4],[5,6]])x[0] # [1, 2]x[0][1] # 2 ,普通python数组的索引x[0,1] # 2 ,同x[0][1],ndarray数组的索引 ndarray的切片123456789x = np.array([1,2,3,4,5])x[1:3] # [2, 3], 左闭右开的区间x[:3] # [1,2,3], 左边默认为 0，仍然是左闭右开x[1:] # [2,3,4,5], 右边默认为数组的长度，仍然是左闭右开x = np.array([[1,2],[3,4],[5,6]])x[:2] # [[1, 2],[3, 4]],x[:2,:1] # [[1],[3]]x[:2,:1] = 0 # 用标量赋值,x=[[0, 2],[0, 4],[5, 6]] 六、其他用法12345678# 使用 where 进行 ndarray 的条件应用cond = np.array([True,False,True,False])x = np.where(cond,-2,2)[-2, 2, -2, 2]cond = np.array([1,2,3,4])x = np.where(cond&gt;2,-2,2)[ 2, 2, -2, -2] THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"Numpy","slug":"Numpy","permalink":"http://ai.wisim.me/tags/Numpy/"}]},{"title":"Matplotlib","slug":"2018-05-03_Matplotlib","date":"2018-05-02T16:00:00.000Z","updated":"2018-05-07T03:08:07.917Z","comments":true,"path":"2018/05/03/2018-05-03_Matplotlib/","link":"","permalink":"http://ai.wisim.me/2018/05/03/2018-05-03_Matplotlib/","excerpt":"画一个简单的图形1234567import matplotlib.pyplot as pltimport numpy as npx = np.linspace(0, 2 * np.pi, 50) #生成一个包含 50 个元素的数组，这 50 个元素均匀的分布在 [0, 2pi] 的区间上。plt.plot(x, np.sin(x)) # 如果没有第一个参数 x，图形的 x 坐标默认为数组的索引plt.plot(x, np.sin(x), x, np.sin(2 * x)) #绘制两个数据集plt.show() # 显示图形","text":"画一个简单的图形1234567import matplotlib.pyplot as pltimport numpy as npx = np.linspace(0, 2 * np.pi, 50) #生成一个包含 50 个元素的数组，这 50 个元素均匀的分布在 [0, 2pi] 的区间上。plt.plot(x, np.sin(x)) # 如果没有第一个参数 x，图形的 x 坐标默认为数组的索引plt.plot(x, np.sin(x), x, np.sin(2 * x)) #绘制两个数据集plt.show() # 显示图形 自定义图形的外观1234x = np.linspace(0, 2 * np.pi, 50)plt.plot(x, np.sin(x), 'r-o', x, np.cos(x), 'g--') #'r' 和 'g' 代表线条的颜色，'-o' 代表包含实心点标记的实线，'--' 代表虚线plt.show() 使用子图，可以在一个窗口绘制多张图。123456x = np.linspace(0, 2 * np.pi, 50)plt.subplot(2, 1, 1) # （行，列，活跃区）plt.plot(x, np.sin(x), 'r')plt.subplot(2, 1, 2) #在调用 plot() 函数之前需要先调用 subplot() 函数。plt.plot(x, np.cos(x), 'g')plt.show() 简单散点图1234x = np.linspace(0, 2 * np.pi, 50)y = np.sin(x)plt.scatter(x,y) #通过 plot 命令并将线的样式设置为 'bo' 也可以实现同样的效果。实际设置'o'就可以，'bo'表示蓝色的点。plt.show() 直方图123x = np.random.randn(1000)plt.hist(x, 50)plt.show() 彩色映射散点图1234567x = np.random.rand(1000)y = np.random.rand(1000)size = np.random.rand(1000) * 50colour = np.random.rand(1000)plt.scatter(x, y, size, colour)plt.colorbar() #加了一个颜色栏。plt.show() 添加标题，坐标轴标记和图例12345678x = np.linspace(0, 2 * np.pi, 50)plt.plot(x, np.sin(x), 'r-x', label='Sin(x)')plt.plot(x, np.cos(x), 'g-^', label='Cos(x)')plt.legend() # 应用label，展示图例plt.xlabel('Rads') # 给 x 轴添加标签plt.ylabel('Amplitude') # 给 y 轴添加标签plt.title('Sin and Cos Waves') # 添加图形标题plt.show() 饼图1234567891011121314slices = [7,2,2,13]activities = ['sleeping','eating','working','playing']cols = ['c','m','r','b']plt.pie(slices, labels=activities, colors=cols, startangle=90, shadow= True, explode=(0,0.1,0,0), autopct='%1.1f%%')plt.title('Interesting Graph\\nCheck it out')plt.show() 从文件读取数据123456789101112131415161718192021import numpy as npimport matplotlib.pyplot as pltimport random%matplotlib inlineimport csvx = []y = []with open('example.txt','r') as csvfile: plots = csv.reader(csvfile, delimiter=',') for row in plots: x.append(int(row[0])) y.append(int(row[1]))plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\\nCheck it out')plt.legend()plt.show() 附：code THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://ai.wisim.me/tags/Matplotlib/"}]},{"title":"基本概念","slug":"2018-05-02_BaseConcept","date":"2018-05-01T16:00:00.000Z","updated":"2018-05-03T08:51:45.014Z","comments":true,"path":"2018/05/02/2018-05-02_BaseConcept/","link":"","permalink":"http://ai.wisim.me/2018/05/02/2018-05-02_BaseConcept/","excerpt":"假设空间假设空间是指所有可能的能满足样本输入和输出的假设函数h(x)的集合。注意，假设函数一定是一个无穷大的集合。也就是说，如果样本是一串有穷的离散点（xi，yi），i属于1到N，那么能够拟合这这些点的无穷多个函数都是可能的假设函数。 那么，怎样的假设函数是最合理呢？这就涉及到归纳偏好的概念了。","text":"假设空间假设空间是指所有可能的能满足样本输入和输出的假设函数h(x)的集合。注意，假设函数一定是一个无穷大的集合。也就是说，如果样本是一串有穷的离散点（xi，yi），i属于1到N，那么能够拟合这这些点的无穷多个函数都是可能的假设函数。 那么，怎样的假设函数是最合理呢？这就涉及到归纳偏好的概念了。 损失函数对于给定的输入X和假设空间中选择的决策函数模型f，由f(X)给出相应的输入Y，这个输出的预没值f(X)与真实值Y可能一致，也可能不一致，用一个损失函数或代价函数来度量预测的错误程度。损失函数是f(x)和Y的非负实值函数，记作L(Y,f(X)) 几种常用的损失函数： 0-1损失函数(0-1 loss function) $L(Y,f(X)) = \\begin{cases}1, &amp;Y\\neq f(X) \\\\ 0, &amp; Y=f(X)\\end{cases}$ 平方损失函数（quadratic loss function） $L(Y,f(X)) = (Y – f(X))^2$ 绝对损失函数（absolute loss function） $L(Y,f(X)) = |Y-f(X)|$ 对数损失函数（logarithmic loss function）或对数似然损失函数 $L(Y,P(Y|X)) = –logP(Y|X)$ 风险函数损失函数值越小，模型就越好。由于模型的输入、输出(X,Y)是随机变量，遵循联合分布P(X,Y)，所以损失函数的期望是 : $R_{exp}(f)=E_P[L(Y,f(X))]=\\int_{\\mathcal{X}\\times\\mathcal{Y}}L(y,f(x))P(x,y)dxdy$ 这是理论上模型f(X)关于联合分布P(X,Y)的平均意义下的损失，称为风险函数(risk function)或期望损失(expected loss)。 学习的目标就是选择期望风险最小的模型。由于联合分布P(X,Y)是所有样本所遵循的统计规律，它是未知的，所以Rexp(f)不能直接计算。实际上如果知道了联合分布，那么可以直接计算出P(Y|X)=∫P(x,y)dx，也就不需要学习了。所以用上面那种方式定义风险函数是不行的，那样的话监督学习变成了一个病态问题。 对于给定的训练数据集 T=(x1,y1),(x2,y2),…,(xN,yN),模型f(X)关于训练数据集的平均损失称为经验风险（empirical risk）或经验损失（empirical loss），记作Remp： $R_{emp}(f) = \\frac{1}{N}\\sum_{i=1}^NL(y_i,f(x_i))$ 期望风险Rexp(f)是模型关于联合分布的期望损失，经验风险Remp(f)是模型关于训练样本集的平均损失。根据大数定律，当样本容量N趋于无穷时，经验风险Remp(f)趋向于期望风险Rexp(f)。 所以，一个很自然的想法是用经验风险估计期望风险。但是，由于现实中训练样本数目很有限，所以用经验风险估计期望风险常常不理想，要对经验风险进行一定的矫正。这就关系到监督学习的两个基本策略：经验风险最小化和结构风险最小化。 经验风险最小化在假设空间、损失函数以及训练数据集确定的情况下，经验风险函数式就可以确定。经验风险最小化的策略认为，经验风险最小的模型就是最优的模型。根据这一策略，按照经验风险最小化求最佳模型就是求解最优化问题： $\\min_{f\\in\\mathcal{F}}\\frac{1}{N}\\sum_{i=1}^NL(y_i,f(x_i))$ 其中F是假设空间。 当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中广泛采用。比如极大似然估计就是经验风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。但是当样本容量很小时，经验风险最小化学习效果就未必很好，会产生“过拟合(over-fitting)”现象。 结构风险最小化结构风险最小化（structural risk minimization SRM）是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化。结构风险在经验风险上加上表示模型复杂度的正则化项或罚项。在假设空间，损失函数以及训练样本集确定的情况下，结构风险的定义是 $R_{srm}(f) = \\frac{1}{N}\\sum_{i=1}^NL(y_i,f(x_i))+\\lambda J(f)$ 其中J(f)为模型的复杂度，是定义在假设空间F上的泛函。模型f越复杂，复杂度J(f)就越大；反之，模型f越简单，复杂度J(f)就越小。也就是说复杂度表示了对复杂模型的惩罚。λ≥0是系数，用以权衡经验风险和模型的复杂度。结构风险小需要经验风险与模型复杂度同时小。结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。比如，贝叶斯估计中的最大后验概率估计（maximum posterior probability estimation,MAP）就是结构风险最小化的例子。当模型是条件概率分布、损失函数就是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。 结构风险最小化的策略认为结构风险最小的模型是最优的模型。所以求最优化模型时，就是求解最优化问题： $\\min_{f\\in\\mathcal{F}}\\frac{1}{N}L(y_i,f(x_i))+\\lambda J(f)$ 这样，监督学习问题就变成了经验风险或结构风险函数的最优化问题。这时经验或结构风险函数是最优化的目标函数。 监督学习 分类 ： 输出值如果是不连续的监督学习算法称为分类器（classifier）。 回归 ： 输出值连续的监督学习算法称为回归函数（regression function）。 归纳偏好归纳偏好是一个能挑选最佳假设函数的基准。以韦小宝的7个老婆为例，这7个老婆均满足小宝的要求，因此构成了大小为7的假设空间。（实际上，假设空间的大小一定是无穷大的。为了说明问题，我们暂时以7为大小）。那么，如何衡量哪一个假设空间中哪一个假设函数（老婆）最好呢？如果以温柔体贴为偏好来选，当然是小双；如果以小宝的迷恋为偏好来讲，假设函数就是阿珂。说白了，归纳偏好就是一个用于挑选假设函数的基准。 一般情况下，我们都使用“奥卡姆剃刀”原则，也就是选择最简单的假设函数。也就是变量最少，变量的幂指数最小的函数。也就是说，一次函数能拟合时就不选二次函数作为假设函数。 极大似然估计极大似然估计是根据样本(x1,x2，…，xi，…，xn)的值来估计样本模型中参数（θ1,θ2，…，θi，…，θn）的。是一种参数估计方法。 其中，似然是似然函数的简称。可由L(x1,x2，…，xi，…，xn,θ1,θ2，…，θi，…，θn )来表示。实际上，样本一旦确定，人们一般会假设一个可拟合这些样本的模型，即参数个数是确定的，待求的是参数的具体值。比如，基于班上同学的身高数据，一般会假设身高是符合正态分布(μ,σ)，待求的是这两个参数具体的值。 那么，如何基于已有的样本数据来求得模型中参数得具体值呢？ 极大似然估计的意思是说，你只要能使L(x1,x2，…，xi，…，xn,θ1,θ2，…，θi，…，θn )最大，你的参数θ1,θ2，…，θi，…，θn 就是有效的。以身高样本为例（假定身高样本是独立同分布的）。即当L(x1,x2，…，xi，…，xn,μ,σ )最大时，(μ,σ)被估计的是准确的。 求极大似然函数估计值的一般步骤： 写出似然函数； 对似然函数取对数，并整理； 求导数 ； 导数为零时，似然函数取得极大值 。 THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/tags/机器学习/"}]},{"title":"朴素贝叶斯分类算法","slug":"2018-03-17_Bayes","date":"2018-03-26T16:00:00.000Z","updated":"2018-05-09T09:35:35.193Z","comments":true,"path":"2018/03/27/2018-03-17_Bayes/","link":"","permalink":"http://ai.wisim.me/2018/03/27/2018-03-17_Bayes/","excerpt":"一、朴素贝叶斯分类 简介 朴素贝叶斯（Naive Bayesian）是基于贝叶斯定理和特征条件独立假设的分类方法，它通过特征计算分类的概率，选取概率大的情况进行分类，因此它是基于概率论的一种机器学习分类方法。因为分类的目标是确定的，所以也是属于监督学习。 朴素贝叶斯有如下几种： 离散型朴素贝叶斯: MultinomialNB 连续型朴素贝叶斯: GaussianNB 混合型朴素贝叶斯: MergedNB","text":"一、朴素贝叶斯分类 简介 朴素贝叶斯（Naive Bayesian）是基于贝叶斯定理和特征条件独立假设的分类方法，它通过特征计算分类的概率，选取概率大的情况进行分类，因此它是基于概率论的一种机器学习分类方法。因为分类的目标是确定的，所以也是属于监督学习。 朴素贝叶斯有如下几种： 离散型朴素贝叶斯: MultinomialNB 连续型朴素贝叶斯: GaussianNB 混合型朴素贝叶斯: MergedNB 原理 朴素贝叶斯基于条件概率、贝叶斯定理和独立性假设原则。 (1) 条件概率原理原理 123基于概率论的方法告诉我们，当只有两种分类时：如果p1(x,y)&gt;p2(x,y)，那么分入类别1如果p1(x,y)&lt;p2(x,y)，那么分入类别2 (2) 贝叶斯定理 $p(c_i|x,y)=\\frac{p(x,y|c_i)p(c_i)}{p(x,y)}$ 其中，x,y表示特征变量，ci表示分类，p(ci|x,y)即表示在特征为x,y的情况下分入类别ci的概率，因此，结合条件概率和贝叶斯定理，有： 12如果p(c1|x,y)&gt;p(c2|x,y)，那么分类应当属于c1；如果p(c1|x,y)&lt;p(c2|x,y)，那么分类应当属于c2 贝叶斯定理最大的好处是可以用已知的三个概率去计算未知的概率，而如果仅仅是为了比较p(ci|x,y)和p(cj|x,y)的大小，只需要已知两个概率即可，分母相同，比较p(x,y|ci)p(ci)和p(x,y|cj)p(cj)即可。 (3) 特征条件独立假设原则 见FAQ4. 朴素贝叶斯分类的流程 123(1). 数据准备：收集数据，并将数据预处理为数值型或者布尔型，如对文本分类，需要将文本解析为词向量(2). 训练数据：根据训练样本集计算词项出现的概率，训练数据后得到各类下词汇出现概率的向量(3). 测试数据：用测试样本集去测试分类的准确性 优缺点 1234561. 监督学习，需要确定分类的目标2. 对缺失数据不敏感，在数据较少的情况下依然可以使用该方法3. 可以处理多个类别 的分类问题4. 适用于标称型数据5. 对输入数据的形势比较敏感6. 由于用先验数据去预测分类，因此存在误差 参考： 机器学习之朴素贝叶斯(NB)分类算法与Python实现 FAQ： 基于概率论的方法和基于统计学的方法： 基于概率论的方法是通过概率来衡量事件发生的可能性。概率论和统计学恰好是两个相反的概念，统计学是抽取部分样本进行统计来估算总体的情况，而概率论是通过总体情况来估计单个事件或者部分事情的发生情况。 朴素贝叶斯，朴素在什么地方： 之所以叫朴素贝叶斯，因为它简单、易于操作，基于特征独立性假设，假设各个特征不会相互影响，这样就大大减小了计算概率的难度。 概率论中的基本概念 (1)事件交和并： A和B两个事件的交，指的是事件A和B同时出现，记为A∩B;A和B两个事件的并，指的是事件A和事件B至少出现一次的情况，记为A∪B。 (2)条件概率(conditional probability)： 某个事件发生时另外一个事件发生的概率，如事件B发生条件下事件A发生的概率： $P(B|A)=\\frac{P(A \\cap B)}{P(A)},P(A \\cap B)=P(A)P(B | A) or P(A \\cap B)=P(B)P(A | B)$ P(A)称为”先验概率”（Prior probability），即在B事件发生之前，我们对A事件概率的一个判断。 P(A|B)称为”后验概率”（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。 P(B|A)/P(B)称为”可能性函数”（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。 所以，条件概率可以理解成下面的式子： 后验概率 ＝ 先验概率 ｘ 调整因子 (3)独立事件交的概率： 两个相互独立的事件，其交的概率为： $P(A \\cap B)=P(A)P(B)$ 贝叶斯定理（Bayes’s Rule）： 如果有k个互斥且有穷个事件:B1,B2···，Bk ，并且，P(B1)+P(B2)+···+P(Bk)=1和一个可以观测到的事件A，那么有： $P(B_i | A)=\\frac{P(B_i \\cap A)}{P(A)}=\\frac{P(B_i)P(A | B_i)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)+···+P(B_k)P(A|B_k)}$ p(A) ：事件A发生的概率； p(A∩B) :事件A 和事件B同时发生的概率； p(A|B) ：表示事件A在事件B发生的条件下发生的概率。 THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"Bayes","slug":"Bayes","permalink":"http://ai.wisim.me/tags/Bayes/"}]},{"title":"平衡二叉树的旋转及其代码实现","slug":"2018-03-13_AVL","date":"2018-03-14T06:12:40.672Z","updated":"2018-03-14T06:12:40.672Z","comments":true,"path":"2018/03/14/2018-03-13_AVL/","link":"","permalink":"http://ai.wisim.me/2018/03/14/2018-03-13_AVL/","excerpt":"平衡二叉树的构造问题以及为了维护它的平衡所要进行的LL旋转、RR旋转、LR旋转、RL旋转。","text":"平衡二叉树的构造问题以及为了维护它的平衡所要进行的LL旋转、RR旋转、LR旋转、RL旋转。 一、平衡二叉树的构造1234567891011121314151617181920node *insert(node *root, int x) &#123; if (root == 0) &#123; root = &amp;all[total++]; root-&gt;left = root-&gt;right = 0; root-&gt;val = x; root-&gt;height = 0; &#125; else if (x &lt; root-&gt;val) &#123; root-&gt;left = insert(root-&gt;left, x); if (height(root-&gt;left) - height(root-&gt;right) == 2) &#123; root = (x &lt; root-&gt;left-&gt;val) ? LL(root) : LR(root); &#125; &#125; else &#123; root-&gt;right = insert(root-&gt;right, x); if (height(root-&gt;right) - height(root-&gt;left) == 2) &#123; root = (x &gt; root-&gt;right-&gt;val) ? RR(root) : RL(root); &#125; &#125; root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + 1; return root;&#125; 二、LL旋转所谓LL旋转并不是指旋转方向，而是指新插入导致不平衡的元素位于左子树的左儿子位置，也就是LeftLeft。 看一下这种旋转的示意图： 12345678node *LL(node *k2) &#123; node *k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; return k1;&#125; 三、RR旋转同样LL旋转是指新插入导致不平衡的元素位于右子树的右儿子位置，也就是RightRight。 看一下这种旋转的方式示意图： 12345678node *RR(node *k1) &#123; node *k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; return k2;&#125; 四、LR旋转和RL旋转LR和RL则分别表示位于左子树的右儿子和右子树的左儿子。 1.对于LR旋转，首先将最近的不平衡结点k3的左子树进行RR旋转，再将k3本身进行LL旋转。 1234node *LR(node *k3) &#123; k3-&gt;left = RR(k3-&gt;left); return LL(k3);&#125; 2.对于RL旋转，首先将最近的不平衡结点k3的右子树进行LL旋转，再将k3本身进行RR旋转。 1234node *RL(node *k1) &#123; k1-&gt;right = LL(k1-&gt;right); return RR(k1);&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://ai.wisim.me/tags/二叉树/"}]},{"title":"机器学习构建chatbot","slug":"2018-02-24_chatbot","date":"2018-02-24T16:00:00.000Z","updated":"2018-03-14T06:12:40.671Z","comments":true,"path":"2018/02/25/2018-02-24_chatbot/","link":"","permalink":"http://ai.wisim.me/2018/02/25/2018-02-24_chatbot/","excerpt":"预备知识机器人应答逻辑（Logic Adapter），针对每个部分设计了不同的适配器 Closet Match Adapter:字符串模糊匹配（编辑距离） Closet Meaning Adapter:借助nltk的WordNet，近义词评估 Time Logic Adapter:处理涉及实践的提问 Mathematical Evaluation Adapter:涉及数学运算 存储器后段（Storage Adapter） Read Only Mode:只读模式 Json Database Mode:Json格式存储对话数据 Mongo Database Mode:以MongoDb方式存储对话数据库 输入形式（Input Adapter） Variable input type Adapter:允许chatbot接收不同类型的输入 Terminal Adapter:以终端方式进行对话 HipChat Adapter:通过HipChat聊天室和chatbo进行对话 Speech recognition:语音识别输入 输出形式（Output Adapters） Output format adapter:支持text，json和object格式的输出 Terminal adapter HipChat Adapter Mailgun adapter:允许chat bot基于Mailgun API进行邮件的发送 Speech synthesis TTS(Text to speech)部分，详见chatterbot-voice","text":"预备知识机器人应答逻辑（Logic Adapter），针对每个部分设计了不同的适配器 Closet Match Adapter:字符串模糊匹配（编辑距离） Closet Meaning Adapter:借助nltk的WordNet，近义词评估 Time Logic Adapter:处理涉及实践的提问 Mathematical Evaluation Adapter:涉及数学运算 存储器后段（Storage Adapter） Read Only Mode:只读模式 Json Database Mode:Json格式存储对话数据 Mongo Database Mode:以MongoDb方式存储对话数据库 输入形式（Input Adapter） Variable input type Adapter:允许chatbot接收不同类型的输入 Terminal Adapter:以终端方式进行对话 HipChat Adapter:通过HipChat聊天室和chatbo进行对话 Speech recognition:语音识别输入 输出形式（Output Adapters） Output format adapter:支持text，json和object格式的输出 Terminal adapter HipChat Adapter Mailgun adapter:允许chat bot基于Mailgun API进行邮件的发送 Speech synthesis TTS(Text to speech)部分，详见chatterbot-voice 使用ChatterBot构建聊天机器人1. 首先构建ChatBot并指定Adapter123456789101112131415161718# -*- coding: utf-8 -*-from chatterbot import ChatBotbot = ChatBot( 'Default Response Example Bot', #置信度低于0.65时回复default_response logic_adapters=[ &#123; 'import_path': 'chatterbot.logic.BestMatch' &#125;, &#123; 'import_path': 'chatterbot.logic.LowConfidenceAdapter', 'threshold': 0.65, 'default_response': 'I am sorry, but I do not understand.' &#125; ], #指定对话类型是列表 trainer='chatterbot.trainers.ListTrainer') 2. 接着手动给定一点语料用于训练1234567bot.train([ 'How can I help you?', 'I want to create a chat bot', 'Have you read the documentation?', 'No, I have not', 'This should help get you started: http://chatterbot.rtfd.org/en/latest/quickstart.html']) 3. 给定问题并取回结果12345678910question = 'How do I make an omelette?'print(question)response = bot.get_response(question)print(response)print(\"\\n\")question = 'how to make a chat bot?'print(question)response = bot.get_response(question)print(response) 各自输出： 123456How do I make an omelette?I am sorry, but I do not understand.how to make a chat bot?Have you read the documentation? 4. 使用chatterbot自带的中文语料库训练1234567891011121314#!/usr/bin/python# -*- coding: utf-8 -*-from chatterbot import ChatBotfrom chatterbot.trainers import ChatterBotCorpusTrainerchatbot = ChatBot(\"ChineseChatBot\")chatbot.set_trainer(ChatterBotCorpusTrainer)# 使用中文语料库训练它chatbot.train(\"chatterbot.corpus.chinese\")# 开始对话while True: print(chatbot.get_response(input(\"&gt;\"))) 试了一下，问答比较二。。。 seq2seq LSTM THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[]},{"title":"20170928.2","slug":"2017-09-28-2","date":"2018-02-24T05:24:41.189Z","updated":"2018-02-24T05:24:41.189Z","comments":true,"path":"2018/02/24/2017-09-28-2/","link":"","permalink":"http://ai.wisim.me/2018/02/24/2017-09-28-2/","excerpt":"题 2:设 y=f(x) 在(-1,1)内有二阶连续导数，且f’’(x)≠0. 证明 (1) 对于任意非零x∈(-1,1),存在唯一 θ(x)∈(0,1), 使得 f(x)=f(0)+xf’[ θ(x),x] 成立； (2) $\\lim _{x\\rightarrow 0^{+}}\\theta \\left( x\\right) =\\dfrac {1} {2}$.","text":"题 2:设 y=f(x) 在(-1,1)内有二阶连续导数，且f’’(x)≠0. 证明 (1) 对于任意非零x∈(-1,1),存在唯一 θ(x)∈(0,1), 使得 f(x)=f(0)+xf’[ θ(x),x] 成立； (2) $\\lim _{x\\rightarrow 0^{+}}\\theta \\left( x\\right) =\\dfrac {1} {2}$. 证明:(1) 对于f(x)在[0,1]上使用拉格朗日定理，得:f(x)-f(0)=xf’[0+θ(x)*(x-0)], f(x)=f(0)+xf’(θ(x)*x). 又f’’(x)≠在[0,1]内连续且f’’(x)≠0,故保号，于是不妨设f’’(x)&gt;0.所以f’(x)严格单调，所以θ(x)唯一. (2) 由泰勒公式有 $f\\left( x\\right) =f\\left( 0\\right) +f’\\left( 0\\right)x +\\dfrac {1} {2}f’’(\\varepsilon )x ^{2}$ 又由(1)中的拉格朗日定理可知：f(x)=f(0)+xf’[θ(x)]. 所以: $f(0)+xf’[θ(x)*x] =f\\left( 0\\right) +f’\\left( 0\\right)x +\\dfrac {1} {2}f’’(\\varepsilon )x ^{2}$ =&gt; $xf’[θ(x)*x] =f’\\left( 0\\right)x +\\dfrac {1} {2}f’’(\\varepsilon )x ^{2}$ =&gt; $\\dfrac {f’[θ(x)*x]-f’(0)}{x} =\\dfrac {1} {2}f’’(\\varepsilon )$ =&gt; $\\lim _{x\\rightarrow 0^{+}} \\dfrac {f’[0+θ(x)*x]-f’(0)} {θ(x)x} θ(x)$ $=\\lim _{x\\rightarrow 0^{+}}f’’(0)*θ(x)$ $=\\lim _{x\\rightarrow 0^{+}}\\dfrac {1} {2}f’’(\\varepsilon ) =\\dfrac {1} {2}f’’(0)$ =&gt; $\\lim _{x\\rightarrow 0^{+}}f’’(0)*θ(x)=\\dfrac {1} {2}f’’(0)$ 因此 $\\lim _{x\\rightarrow 0^{+}}θ(x)=\\dfrac {1} {2}$ THE END.","categories":[{"name":"中值定理","slug":"中值定理","permalink":"http://ai.wisim.me/categories/中值定理/"}],"tags":[{"name":"拉格朗日定理","slug":"拉格朗日定理","permalink":"http://ai.wisim.me/tags/拉格朗日定理/"},{"name":"泰勒公式","slug":"泰勒公式","permalink":"http://ai.wisim.me/tags/泰勒公式/"}]},{"title":"NLP基础","slug":"2018-02-25_nltk","date":"2018-02-23T16:00:00.000Z","updated":"2018-03-14T06:12:40.671Z","comments":true,"path":"2018/02/24/2018-02-25_nltk/","link":"","permalink":"http://ai.wisim.me/2018/02/24/2018-02-25_nltk/","excerpt":"NLTKNLTK在NLP上的应用 情感分析 文本相似度 文本分类","text":"NLTKNLTK在NLP上的应用 情感分析 文本相似度 文本分类 一、安装NLTK1234sudo pip install nltkpython3&gt;&gt;&gt; import nltk&gt;&gt;&gt; nltk.download() 其中 nltk.download() 用来下载nltk自带的一些语料库 测试布朗大学的语料库： 1234567&gt;&gt;&gt; from nltk.corpus import brown&gt;&gt;&gt; brown.categories()[&apos;adventure&apos;, &apos;belles_lettres&apos;, &apos;editorial&apos;, &apos;fiction&apos;, &apos;government&apos;, &apos;hobbies&apos;, &apos;humor&apos;, &apos;learned&apos;, &apos;lore&apos;, &apos;mystery&apos;, &apos;news&apos;, &apos;religion&apos;, &apos;reviews&apos;, &apos;romance&apos;, &apos;science_fiction&apos;]&gt;&gt;&gt; len(brown.sents())57340 #句子长度&gt;&gt;&gt; len(brown.words())1161192 #单词个数 二、文本处理流程1. 文本预处理（1）Tokenize:把长句子拆分成“有意义”的小部分 12345&gt;&gt;&gt; import nltk&gt;&gt;&gt; sentence = “hello, world&quot;&gt;&gt;&gt; tokens = nltk.word_tokenize(sentence)&gt;&gt;&gt; tokens[&apos;hello&apos;, ‘,&apos;, &apos;world&apos;] （2）词形归一化，包括Stemming和Lemmatization Stemming 词干提取:一般来说，就是把不影响词性的inflection的小尾巴砍掉 可以使用nltk中的 PorterStemmer/LancasterStemmer/SnowballStemmer/PorterStemmer Lemmatization 词形归一:把各种类型的词的变形，都归为一个形式 可以使用nltk中的 WordNetLemmatizer Part-Of-Speech:NLTK更好地实现Lemma （3）去除停止词 1234from nltk.corpus import stopwords# 先token得到word_list,再去除停止词filtered_words =[word for word in word_list if word not in stopwords.words('english')] （4）最终得到一个干净的word list 分词的方式：启发式Heuristic（查数据库）机器学习／统计方法：HMM、CRF 三、应用：情感分析最简单的方法是给每个词打分，然后判断句子总的分数。 配上ML的情感分析： 123456# 把训练集给做成标准形式 training_data = [[preprocess(s1), 'pos'], [preprocess(s2), 'pos'], [preprocess(s3), 'neg'], [preprocess(s4), 'neg']]# 构建modelmodel = NaiveBayesClassifier.train(training_data) # 测试结果 print(model.classify(preprocess('this is a good book'))) 四：应用:文本相似度用元素频率表示文本特征 原理就是使用余弦定理来计算文本相似度: $similarity = cos( \\theta ) = \\dfrac{A \\cdot B}{||A|| \\: ||B||}$ 使用NLTK中的FreqDist包来进行频率统计 12345678&gt;&gt;&gt; from nltk.corpus import stopwords&gt;&gt;&gt; from nltk import FreqDist&gt;&gt;&gt; corpus = &apos;this is my sentence this is my life this is the day&apos;&gt;&gt;&gt; tokens = nltk.word_tokenize(corpus)&gt;&gt;&gt; fdist = FreqDist(tokens)&gt;&gt;&gt; standard_freq_vector = fdist.most_common(50)&gt;&gt;&gt; print(standard_freq_vector)[(&apos;this&apos;, 3), (&apos;is&apos;, 3), (&apos;my&apos;, 2), (&apos;sentence&apos;, 1), (&apos;life&apos;, 1), (&apos;the&apos;, 1), (&apos;day&apos;, 1)] 这一步得到了一个类似词典的东西，里面保存了我们给出的句子里面每个单词出现的频率，并且取出来出现频率最高的50个单词。 然后按照出现频率 ,记录下每个单词的位置： 1234567891011def position_lookup(v): res = &#123;&#125; counter = 0 for word in v: res[word[0]] = counter counter += 1 return res# 把标准的单词位置记录下来standard_position_dict = position_lookup(standard_freq_vector) print(standard_position_dict)# 得到 个位置对照表# &#123;'is': 0, 'the': 3, 'day': 4, 'this': 1,'sentence': 5, 'my': 2, 'life': 6&#125; 这时如果我们有个新句子，对于这个新句子的每个单词如果在我们的词库出现过那么就在”标准位置”上+1 1234567891011sentence = 'this is cool'# 先新建个跟我们的标准vector同样的向量 freq_vector = [0] * size# 简单的Preprocessingtokens = nltk.word_tokenize(sentence)for word in tokens: try: freq_vector[standard_position_dict[word]] += 1 except KeyError: # 如果是个新词就pass掉 continueprint(freq_vector)# [1, 1, 0, 0, 0, 0, 0] 结巴分词 Word2Vec THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"NLTK","slug":"NLTK","permalink":"http://ai.wisim.me/tags/NLTK/"}]},{"title":"KNN","slug":"2018-02-23_knn","date":"2018-02-22T16:00:00.000Z","updated":"2018-03-27T07:40:53.856Z","comments":true,"path":"2018/02/23/2018-02-23_knn/","link":"","permalink":"http://ai.wisim.me/2018/02/23/2018-02-23_knn/","excerpt":"K邻近算法，或者说K最近邻(kNN，k-NearestNeighbor)分类算法k-近邻算法（kNN，k-NearestNeighbor），是最简单的机器学习分类算法之一，其核心思想在于用距离目标最近的k个样本数据的分类来代表目标的分类（这k个样本数据和目标数据最为相似）。kNN是一种监督分类算法。","text":"K邻近算法，或者说K最近邻(kNN，k-NearestNeighbor)分类算法k-近邻算法（kNN，k-NearestNeighbor），是最简单的机器学习分类算法之一，其核心思想在于用距离目标最近的k个样本数据的分类来代表目标的分类（这k个样本数据和目标数据最为相似）。kNN是一种监督分类算法。 算法描述 计算分类未知数据 x_new 与训练样本集数据 x 的欧氏距离 distance 将 distance 递增排序 选取 distance 的前 k 个点 选取前 k 个点中，出现频率最高的类别 y 作为 x_new的分类 代码实现123456789101112131415161718192021222324252627282930import numpy as npdef createDataSet(): group = np.array([[1, 1.1], [1, 1], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels\"\"\"定义knn算法分类器函数:param inX: 测试数据:param dataSet: 训练数据:param labels: 分类类别:param k: k值:return: 所属分类\"\"\"def classify(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] #shape（m, n）m列n个特征 diffMat = np.tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 #欧式距离 sortedDistIndicies = distances.argsort() #排序并返回index classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1 #default 0 sortedClassCount = sorted(classCount.items(), key=lambda d:d[1], reverse=True) return sortedClassCount[0][0] 测试1234if __name__ == '__main__': dataSet, labels = createDataSet() r = classify([0, 0.2], dataSet, labels, 3) print(r) 输出 B THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"KNN","slug":"KNN","permalink":"http://ai.wisim.me/tags/KNN/"}]},{"title":"感知机","slug":"2018-02-19_perceptron","date":"2018-02-18T16:00:00.000Z","updated":"2018-02-24T05:25:50.003Z","comments":true,"path":"2018/02/19/2018-02-19_perceptron/","link":"","permalink":"http://ai.wisim.me/2018/02/19/2018-02-19_perceptron/","excerpt":"感知机感知机（perceptron）是一种二分类的线性分类模型，输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的分离超平面。感知机旨在求出该超平面，为求得超平面导入了基于误分类的损失函数，利用梯度下降法 对损失函数进行最优化（最优化）。","text":"感知机感知机（perceptron）是一种二分类的线性分类模型，输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的分离超平面。感知机旨在求出该超平面，为求得超平面导入了基于误分类的损失函数，利用梯度下降法 对损失函数进行最优化（最优化）。 感知机的损失函数$L(w,b)=-\\sum_{i=1}^{M} {y_i(w*x_i+b)}$ 显然，损失函数L(w,b)是非负的。如果没有误分类点，那么L(w,b)为0，误分类点数越少，L(w,b)值越小。一个特定的损失函数：在误分类时是参数w,b的线性函数，在正确分类时，是0。 损失函数L(w,b)的梯度： $\\nabla_w L(w,b)=-\\sum_{i=1}^{M}y_i\\:x_i$ $\\nabla_b L(w,b)=-\\sum_{i=1}^{M}y_i$ 求解损失函数极小值的过程： 首先，任意选定w0、b0，然后用梯度下降法不断极小化目标损失函数，极小化的过程不是一次性的把M中的所有误分类点梯度下降，而是一次随机选取一个误分类点使其梯度下降： $w=w+\\eta y_i\\:x_i$ $b=b+\\eta y_i$ 式中η（0≤η≤1）是步长，在统计学是中成为学习速率。步长越大，梯度下降的速度越快，更能接近极小点。如果步长过大，有可能导致跨过极小点，导致函数发散；如果步长过小，有可能会耗很长时间才能达到极小点。 实现代码从输入参数得到训练文件和模型文件： 123n = float(sys.argv[1])trainFile = open(sys.argv[2])modelFile= open(sys.argv[3], 'w') 从训练文件中读取训练数据： 123456789101112for line in trainFile: chunk = line.strip().split(' ') #每行的数据 lens = len(chunk) - 1 #最后一行是训练输出 tmp_all = [] tmp = [] for i in range(1, lens+1): tmp.append(int(chunk[i])) tmp_all.append(tmp) tmp_all.append(int(chunk[0])) training_set.append(tmp_all)trainFile.close() 训练数据：1231 3 31 4 3-1 1 1 计算点到超平面的距离：12345678def cal(item): global w, b res = 0 for i in range(len(item[0])): res += item[0][i] * w[i] #w和xi的内积 res += b res *= item[1] return res 判断是否是误分类点，如果是误分类点则更新参数:1234for item in training_set: if cal(item) &lt;= 0: flag = True update(item) 使用随机梯度下降法更新参数：12345def update(item): global w, b, lens, n #n就是学习速率η for i in range(lens): w[i] = w[i] + n * item[1] * item[0][i] b = b + n * item[1] 疑问：感知机的对偶形式 参考：http://www.cnblogs.com/kaituorensheng/p/3561091.html THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"感知机","slug":"感知机","permalink":"http://ai.wisim.me/tags/感知机/"}]},{"title":"线性代数陌生公式","slug":"2017-12-25","date":"2017-12-24T16:00:00.000Z","updated":"2018-02-24T05:24:41.193Z","comments":true,"path":"2017/12/25/2017-12-25/","link":"","permalink":"http://ai.wisim.me/2017/12/25/2017-12-25/","excerpt":"$\\left(kA\\right)^{\\ast}=k^{n-1}A^{\\ast}$ $|A^{\\ast}|=|A|^{n-1}$ $|kA|=k^{n}|A|$","text":"$\\left(kA\\right)^{\\ast}=k^{n-1}A^{\\ast}$ $|A^{\\ast}|=|A|^{n-1}$ $|kA|=k^{n}|A|$ $\\begin{vmatrix}A &amp; O \\\\O &amp; B\\end{vmatrix}^{-1}=\\begin{vmatrix}A^{-1} &amp; O \\\\O &amp; B^{-1}\\end{vmatrix}$ $\\begin{vmatrix}O &amp; A \\\\B &amp; O\\end{vmatrix}^{-1}=\\begin{vmatrix}O &amp; B^{-1} \\\\A^{-1} &amp; O\\end{vmatrix}$ $A^{-1}=\\dfrac{A^{\\ast}}{|A|} &lt;=&gt; (A^{\\ast})^{-1}=\\dfrac{A}{|A|} &lt;=&gt; AA^{\\ast}=|A|E$ $(A^{T})^{\\ast}=(A^{\\ast})^{T}$ $(A^{T})^{-1}=(A^{-1})^{T}$ $(A^{-1})^{\\ast}=(A^{\\ast})^{-1}$ $(A^{\\ast})^{\\ast}=|A|^{n-2}A$ $(AB)^{\\ast}=B^{\\ast}A^{\\ast}$ $r(A^{\\ast})=\\begin{cases}n,r(A)=n\\\\1,r(A)=n-1\\\\0,r(A)&lt;n-1 \\end{cases}$ $r(AB)\\geq r(A)+r(B)-n$ $r(A)=r(A^{T}A)$ $r(A|B)\\leq r(A)+r(B)$ $r(A|B)\\geq r(A)$ $(A+B)^n=A^n+C_n^1A^{n-1}B+C_n^{2}A^{n-2}B^2+…+C_n^{n-1}AB^{n-1}+B^n$ THE END.","categories":[{"name":"线性代数","slug":"线性代数","permalink":"http://ai.wisim.me/categories/线性代数/"}],"tags":[{"name":"公式","slug":"公式","permalink":"http://ai.wisim.me/tags/公式/"}]},{"title":"线性代数难点题型","slug":"2017-12-24","date":"2017-12-23T16:00:00.000Z","updated":"2018-02-24T05:24:41.192Z","comments":true,"path":"2017/12/24/2017-12-24/","link":"","permalink":"http://ai.wisim.me/2017/12/24/2017-12-24/","excerpt":"1. 关于矩阵的n阶的题型(1) 如果$A=αβ^{T}$,其中α和β是n维非零列向量，则$A^{n}=l^{n-1}A$,其中$l=β^{T}α=tr(A)$ (2) 如果$A=\\begin{pmatrix}0 &amp; a &amp; c \\\\0 &amp; 0 &amp; b \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,则$A^{2}=\\begin{pmatrix}0 &amp; 0 &amp; ab \\\\0 &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,$A^{3}=0$,$A^{4}=0$… (3) 如果$A \\sim B$,则$A^{n} \\sim B^{n}$,于是$A^{n} \\sim P^{-1}B^{n}P$,其中B是对角矩阵。 (4) 用归纳法：先求 $A^{2},A^{3}$ 等,看出规律，再求 $A^{n}$","text":"1. 关于矩阵的n阶的题型(1) 如果$A=αβ^{T}$,其中α和β是n维非零列向量，则$A^{n}=l^{n-1}A$,其中$l=β^{T}α=tr(A)$ (2) 如果$A=\\begin{pmatrix}0 &amp; a &amp; c \\\\0 &amp; 0 &amp; b \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,则$A^{2}=\\begin{pmatrix}0 &amp; 0 &amp; ab \\\\0 &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,$A^{3}=0$,$A^{4}=0$… (3) 如果$A \\sim B$,则$A^{n} \\sim B^{n}$,于是$A^{n} \\sim P^{-1}B^{n}P$,其中B是对角矩阵。 (4) 用归纳法：先求 $A^{2},A^{3}$ 等,看出规律，再求 $A^{n}$ 2. 证明可逆的方法主要有：n阶矩阵A可逆 &lt;=&gt; $|A|\\neq0$ &lt;=&gt; r(A)=n &lt;=&gt; A的列（行）向量组线性无关 &lt;=&gt; Ax=0只有0解 &lt;=&gt; 0不是矩阵A的特征值 3. 关于两个矩阵的和的公式只有：$(A+B)^T=A^T+B^T$ 4. 满足交换律的一些特殊矩阵：(1) $AA^2=A^2A=A^3$ (2) $AA^{\\ast}=A^{\\ast}A=|A|E$ (3) $AE=EA=A$ (4) $AA^{-1}=A^{-1}A=E$ (5) $AB=aA+bB(ab\\neq0)$ (6) $A^2-kAB=E(k\\neq0)$ 注：一般矩阵不满足交换律。 THE END.","categories":[{"name":"线性代数","slug":"线性代数","permalink":"http://ai.wisim.me/categories/线性代数/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://ai.wisim.me/tags/线性代数/"}]},{"title":"动态规划-数对之差最大值","slug":"2017-11-22-DynamicProgrammingMaxDiff","date":"2017-11-21T16:00:00.000Z","updated":"2018-03-14T06:12:40.671Z","comments":true,"path":"2017/11/22/2017-11-22-DynamicProgrammingMaxDiff/","link":"","permalink":"http://ai.wisim.me/2017/11/22/2017-11-22-DynamicProgrammingMaxDiff/","excerpt":"题目描述 在数组中，某个数字减去它右边的数字得到一个数对之差。求所有数对之差的最大值。例如，在数组{2,4,1,16,7,5,11,9}中，数对之差的最大值是11，是16减去5的结果。","text":"题目描述 在数组中，某个数字减去它右边的数字得到一个数对之差。求所有数对之差的最大值。例如，在数组{2,4,1,16,7,5,11,9}中，数对之差的最大值是11，是16减去5的结果。 分析 定义D[i]是以数组中第i个数字为减数的所有数对之差的最大值。根据题意，用N[i]表示数组的第i个元素，就是说对于任意h=N[h]-N[i]。所以D[i]的最大值就是整个数组的最大的数对之差。来手写求一下最大数对之差的过程。 123456789101112131415161718192021222324252627M[0] = 2;D[1] = M[0] - N[1] = 2 - 4 = -2;maxDiff = 2;M[1] = max&#123;M[0],N[1]&#125; = max&#123;2,4&#125; = 4;D[2] = M[1] - N[2] = 4 - 1 = 3;maxDiff = max&#123;maxDiff,D[2]&#125; = 3;M[2] = max&#123;M[1],N[2]&#125; = max&#123;4,1&#125; = 4;D[3] = M[2] - N[3] = -12;maxDiff = max&#123;maxDiff,D[3]&#125; = 3;M[3] =16;D[4] = 9;maxDiff = 9;M[4] = 16;D[5] = 11;maxDiff = 11;M[5] = 16;D[6] = 5;maxDiff = 11;M[6] = 16;D[7] = 7;maxDiff = 11; 这里的 M[i-1] 表示的是当前第i个元素之前的i-1个元素中的最大值。而maxDiff则是i之前包括位置i在内的最大数对之差的值。 C代码实现12345678910111213141516int MaxDiff(int numbers[], int length) &#123; if(numbers == NULL || length &lt; 2) return 0; int max = numbers[0]; int maxDiff = max - numbers[1]; for(int i=2;i&lt;length;++i) &#123; if(numbers[i] &lt; max) &#123; max = numbers[i]; &#125; int curDiff = max - numbers[i]; if(curDiff &gt; maxDiff) &#123; maxDiff = curDiff; &#125; &#125; return maxDiff;&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://ai.wisim.me/tags/DP/"}]},{"title":"201709304","slug":"2017-09-30-4","date":"2017-09-29T16:00:00.000Z","updated":"2018-02-24T05:24:41.192Z","comments":true,"path":"2017/09/30/2017-09-30-4/","link":"","permalink":"http://ai.wisim.me/2017/09/30/2017-09-30-4/","excerpt":"题 4:设 f(x) 在[0,1] 上有二阶导数，f(0)=f(1)=f’(0)=f’(1)=0，证明存在 𝛏∈(0,1)，使得f’’(𝛏)=f(𝛏).","text":"题 4:设 f(x) 在[0,1] 上有二阶导数，f(0)=f(1)=f’(0)=f’(1)=0，证明存在 𝛏∈(0,1)，使得f’’(𝛏)=f(𝛏). 证明构造辅助函数 $F(x)=[f(x)+f’(x)]e^{-x}$. 由题设可知F(x)在[0,1]上连续，在(0,1)可导，且F(0)=F(1).由罗尔定理可知至少存在一点 𝛏∈(0,1)，使得F’(𝛏)=0. 又 $F’(x)=[f’(x)+f’’(x)]e^{-x}-[f(x)+f’(x)]e^{-x}=[f’’(x)-f(x)]e^{-x}$.由于 $e^{-x}\\neq0，可知有f’’(𝛏)-f(𝛏)=0，即f’’(𝛏)=f(𝛏).$ THE END.","categories":[{"name":"中值定理","slug":"中值定理","permalink":"http://ai.wisim.me/categories/中值定理/"}],"tags":[{"name":"罗尔定理","slug":"罗尔定理","permalink":"http://ai.wisim.me/tags/罗尔定理/"}]},{"title":"20170929.3","slug":"2017-09-29-3","date":"2017-09-28T16:00:00.000Z","updated":"2018-02-24T05:24:41.189Z","comments":true,"path":"2017/09/29/2017-09-29-3/","link":"","permalink":"http://ai.wisim.me/2017/09/29/2017-09-29-3/","excerpt":"题 3:求极限 $\\lim _{\\tiny{x\\rightarrow\\infty}} {(b^{\\tiny{\\dfrac{1}{n}}}-1)}\\sum_{j=0}^{n-1} {b^{\\tiny{\\dfrac{i}{n}}} \\: sin\\: b^{\\tiny{\\dfrac{2i+1}{2n}}}(b&gt;1).}$","text":"题 3:求极限 $\\lim _{\\tiny{x\\rightarrow\\infty}} {(b^{\\tiny{\\dfrac{1}{n}}}-1)}\\sum_{j=0}^{n-1} {b^{\\tiny{\\dfrac{i}{n}}} \\: sin\\: b^{\\tiny{\\dfrac{2i+1}{2n}}}(b&gt;1).}$ 证明:原式 = $\\lim _{\\tiny{x\\rightarrow\\infty}}(b^{\\tiny{\\dfrac {i+1} {n}}}-b^{\\tiny{\\dfrac{i}{n}}})\\sum _{i=0}^{n-1}{sin\\: b^{\\tiny{\\dfrac{2i+1}{2n}}}}$ ,这里的和式可以看作sin x 在[1,b]上划分所做的积分和,区间划分如下: $1=b^{\\tiny\\dfrac{0}{n}}&lt;b^{\\tiny\\dfrac{1}{n}}&lt;b^{\\tiny\\dfrac{2}{n}}&lt;…&lt;b^{\\tiny\\dfrac{n}{n}}=b$ 其中 $\\Delta x_{i}=b^{\\tiny{\\dfrac {i+1} {n}}}-b^{\\tiny{\\dfrac{1}{n}}}$ 是区间 $[b^{\\tiny{\\dfrac{i}{n}}},b^{\\tiny{\\dfrac{i+1}{n}}}]$ 的长度，最大的长度: $\\lambda=max_{\\tiny{0\\leq i \\leq n-1}}\\Delta x_i\\leq b(b^{\\tiny\\dfrac{1}{n}}-1)\\rightarrow0$, $\\xi_i=b^{\\tiny\\dfrac{2i+1}{2n}}\\in[b^{\\tiny{\\dfrac{i}{n}}},b^{\\tiny{\\dfrac{i+1}{n}}}]$ 是小区间两端点的比例中项. 因此原极限= $\\int _{1}^{b}sin\\: xdx=cos\\:1-cos\\:b$. THE END.","categories":[{"name":"定积分","slug":"定积分","permalink":"http://ai.wisim.me/categories/定积分/"}],"tags":[{"name":"定积分的精确定义","slug":"定积分的精确定义","permalink":"http://ai.wisim.me/tags/定积分的精确定义/"}]},{"title":"20170927.1","slug":"2017-09-27-1","date":"2017-09-26T16:00:00.000Z","updated":"2018-02-24T05:24:41.189Z","comments":true,"path":"2017/09/27/2017-09-27-1/","link":"","permalink":"http://ai.wisim.me/2017/09/27/2017-09-27-1/","excerpt":"题 1:设 $0 &lt; a &lt; b$ ,证明：$\\ln \\dfrac {b} {a}&gt;2\\dfrac {b-a} {b+a}$.","text":"题 1:设 $0 &lt; a &lt; b$ ,证明：$\\ln \\dfrac {b} {a}&gt;2\\dfrac {b-a} {b+a}$. 证明:$\\ln \\dfrac {b} {a}&gt;\\dfrac {\\dfrac {b} {a}-1} {\\dfrac {b} {a}+1}$ , 令 $\\dfrac {b} {a}=x$ , 即证 $\\ln x&gt;2\\dfrac {x-1} {x+1}$。 令 F(x) = (1+x)lnx-2(x-1) ，则：$F’\\left( x\\right) =\\dfrac {1} {x}+\\ln x-1$$F’’\\left( x\\right) =-\\dfrac {1} {x^{2}}+\\dfrac {1} {x}=\\dfrac {1} {x}\\left( 1-\\dfrac {1} {x}\\right) &gt; 0$ 因此 F’(x) &gt; F’(1) = 0 ,故 F(x) &gt;F(1)=0。得证。 THE END.","categories":[{"name":"微分不等式","slug":"微分不等式","permalink":"http://ai.wisim.me/categories/微分不等式/"}],"tags":[]},{"title":"Sunday 算法","slug":"2017-04-17-AlogrithmSunday","date":"2017-04-16T16:00:00.000Z","updated":"2018-03-14T06:12:40.670Z","comments":true,"path":"2017/04/17/2017-04-17-AlogrithmSunday/","link":"","permalink":"http://ai.wisim.me/2017/04/17/2017-04-17-AlogrithmSunday/","excerpt":"KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，有一种比BM算法更快的查找算法即Sunday算法。","text":"KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，有一种比BM算法更快的查找算法即Sunday算法。 Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似： 只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1； 否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。 下面举个例子说明下Sunday算法。假定现在要在文本串”substring searching algorithm”中查找模式串”search”。 1.刚开始时，把模式串与文本串左边对齐： 2.结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图： 3.结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下： 4.匹配成功。 回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。 THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://ai.wisim.me/tags/字符串匹配/"}]},{"title":"Print all sub-array with 0 sum","slug":"2017-04-19-AlogrithmPrintSubarray ","date":"2017-04-16T16:00:00.000Z","updated":"2018-03-14T06:12:40.671Z","comments":true,"path":"2017/04/17/2017-04-19-AlogrithmPrintSubarray /","link":"","permalink":"http://ai.wisim.me/2017/04/17/2017-04-19-AlogrithmPrintSubarray /","excerpt":"1234567891011121314151617Given an array of integers, print all subarrays having 0 sum.For example,Input: &#123; 4, 2, -3, -1, 0, 4 &#125;Sub-arrays with 0 sum are&#123; -3, -1, 0, 4 &#125;&#123; 0 &#125;Input: &#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125;Sub-arrays with 0 sum are&#123; 3, 4, -7 &#125;&#123; 4, -7, 3 &#125;&#123; -7, 3, 1, 3 &#125;&#123; 3, 1, -4 &#125;&#123; 3, 1, 3, 1, -4, -2, -2 &#125;&#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125;","text":"1234567891011121314151617Given an array of integers, print all subarrays having 0 sum.For example,Input: &#123; 4, 2, -3, -1, 0, 4 &#125;Sub-arrays with 0 sum are&#123; -3, -1, 0, 4 &#125;&#123; 0 &#125;Input: &#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125;Sub-arrays with 0 sum are&#123; 3, 4, -7 &#125;&#123; 4, -7, 3 &#125;&#123; -7, 3, 1, 3 &#125;&#123; 3, 1, -4 &#125;&#123; 3, 1, 3, 1, -4, -2, -2 &#125;&#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125; 意思就是给定一个数组，找到所有和为0的子数组。 解法1：暴力求解双重循环，从当前数组开始往后遍历，找到和为0的子数组。时间复杂度是O(n^3)，其中O(n^2)用于遍历出子数组，O(n)用于计算和。 解法2：使用HashMap来解决构造一个 Map&lt;Integer, ArrayList&gt; hashMap 用来存放遍历数组，以当前位置（包含当前位置）之前的所有元素之和sum为key，如果hashMap中不存在这个key，则将这个key插入到hashMap中，并将这个元素所在位置插入到对应的ArrayList中。如果hashMap中已经存在这个key，则遍历key对应的ArrayList，以ArrayList中(每个元素所在位置+1)为起始值，当前元素所在位置为结束值，这之间的子数组的和就是0，接着还是要把当前位置插入到已经存在的key所对应的ArrayList中。 举个例子：数组{ 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 }我们来一步一步的分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374(1)首先初始化的时候插入key为0，对应的ArrayList中插入-1，这样以后如果找到子数组就是从位置0开始了。插入之后hashMap的内容是：&#123;0,[-1]&#125;(2)位置0的元素为3，hashMap中不含(0+3=3)。插入之后hashMap的内容是：&#123;0,[-1]&#125;,&#123;3,[0]&#125;(3)位置1的元素是4,hashMap中不含(3+4=7)，插入之后hashMap的内容是：&#123;0,[-1]&#125;,&#123;3,[0]&#125;,&#123;7,[1]&#125;(4)位置2的元素是-7,hashMap包含(-7+7=0)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0]&#125;,&#123;7,[1]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[0,1,2](5)位置3的元素是3,hashMap包含(0+3=3)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[1,2,3](6)位置4的元素是1,hashMap不含(1+3=4)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1]&#125;,&#123;4,[4]&#125;(7)位置5的元素是3,hashMap包含(4+3=7)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[2,3,4,5](8)位置6的元素是1,hashMap不含(7+1=8)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4]&#125;,&#123;8,[6]&#125;(9)位置7的元素是-4,hashMap包含(-4+8=4)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4,7]&#125;,&#123;8,[6]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[5,6,7](10)位置8的元素是-2,hashMap包含(-2+4=2)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4,7]&#125;,&#123;8,[6]&#125;,&#123;2,[8]&#125;(11)位置9的元素是-2,hashMap包含(-2+2=0)，插入之后hashMap的内容是：&#123;0,[-1,2,9]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4,7]&#125;,&#123;8,[6]&#125;,&#123;2,[8]&#125;并且此时有两个满足条件的子数组，对应的位置序列：[0,1,2,3,4,5,6,7,8,9][3,4,5,6,7,8,9] 来总结一下这种解法的:这种解法的时间复杂度是O(n)。初始化的时候向hashMap中插入了key为0的一个元素，这一步很重要。之后从数组中遍历出的元素累加，每次累加得到的结果肯定会发生变化。如果发现某一次累加之后的值之前已经出现过一次，说明什么，说明在第一次出现这个值之后中间的累加操作一定会使得第一次之后（不包含第一次）到第二次（包含第二次）的和的值为0。 ￼￼结合下面这张折线图来看一下： 从-1位置开始，初始sum为0，经过了0，1，2三个位置的元素累加之后，sum又重新变为0。这期间发生了什么呢，依次发生了+3，+4，-7的操作，所以一旦发现两次的累加的和相等的话，表明这之间一定经过了和为0的加减操作。同理，其他几个位置的变化也是如此。 我们再用数学公式抽象一下：设从 0 到 i 位置的累加和为 Si且i位置的元素为e[i]，从 0 到 n 位置的累加和为 Sn且n位置的元素为e[n]，Si = Sn。 从累加的定义我们知道： S_{i} + e[i+1] = S_{i+1}于是可以得到： S_i + e[i+1] + e[i+2] + ... + e[n] = S_n又有：S_i = S_n 所以 e[i+1] + e[i+2] + ... + e[n] = 0 。也就是从 i+1 开始到 n 的子数组之和为0 Link : find-sub-array-with-0-sum THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://ai.wisim.me/tags/DP/"}]},{"title":"学习MachineLearning过程中的一些问题","slug":"2017-03-05-MachineLearningFAQ","date":"2017-03-04T16:00:00.000Z","updated":"2018-05-02T08:39:16.343Z","comments":true,"path":"2017/03/05/2017-03-05-MachineLearningFAQ/","link":"","permalink":"http://ai.wisim.me/2017/03/05/2017-03-05-MachineLearningFAQ/","excerpt":"环境相关 python Anaconda Anaconda 本质上是一个软件发行版 ，包含了 conda、Python 等 180 多个科学包及其依赖项。 pydot pydot是用python实现的绘制graphviz的接口。 graphviz Graphviz的是AT&amp;T Labs Research开发的图形绘制工具软件如果运行过程中报出 Exception: &quot;dot&quot; not found in path. 则需要安装 graphviz，如果已经安装了Anacoda，直接执行 conda install graphviz。","text":"环境相关 python Anaconda Anaconda 本质上是一个软件发行版 ，包含了 conda、Python 等 180 多个科学包及其依赖项。 pydot pydot是用python实现的绘制graphviz的接口。 graphviz Graphviz的是AT&amp;T Labs Research开发的图形绘制工具软件如果运行过程中报出 Exception: &quot;dot&quot; not found in path. 则需要安装 graphviz，如果已经安装了Anacoda，直接执行 conda install graphviz。 概念问题 分类 聚类 回归 异常检测 关联规则 强化学习 结构预测 特征学习 在线学习 半监督学习 语法归纳 监督学习 分类 ： 输出值如果是不连续的监督学习算法称为分类器（classifier）。 回归 ： 输出值连续的监督学习算法称为回归函数（regression function）。 线性回归 代价函数 ： J(\\theta)=\\frac{1}{2m}\\sum_{i=1}^m{({h_\\theta }({x^{(i)}})-{y^{(i)}})^{2}}向量化实现 : J(\\theta)=\\frac{1}{2m}(X*\\theta-\\vec{y})^{T} (X*\\theta-\\vec{y}) 归一化 : y_{i}=\\frac{x_{i}-\\overline{x}}{s(x)} 梯度下降算法 : 代价函数对 \\theta_j 求偏导得到 : \\frac{\\partial{J(\\theta)}}{\\partial{\\theta_j}} = \\frac{1}{m}\\sum\\limits_{i = 1}^m {[({h_\\theta }({x^{(i)}})-{y^{(i)}})x_j^{(i)}]}所以对 \\theta 的更新可以写为 : {\\theta_j}={\\theta_j}-\\alpha\\frac{1}{m}\\sum\\limits_{i=1}^m {[({h_\\theta }({x^{(i)}})-{y^{(i)}})x_j^{(i)}]} 向量化实现 : {\\theta_j} = {\\theta_j}-{\\alpha\\frac{1}{m}(X^T(X*{\\theta- \\vec{y}}))} 分类器 人工神经网络 支持向量机（support vector machine） 最邻近法 高斯混合模型 朴素贝叶斯法 决策树（decision tree） 径向量函数分类 解决步骤 决定训练的样本类型 搜集训练集 决定学习函数的特征表示 决定学习函数的结构以及对应的学习算法 完成设计 评价学习函数的准确性 决策树 表征（装袋, 提升，随机森林） k-NN 线性回归 朴素贝叶斯 神经网络 逻辑回归 感知器 支持向量机（SVM） 相关向量机（RVM） 聚类 BIRCH 层次 k平均 期望最大化（EM） DBSCAN OPTICS 均值飘移 降维 因子分析 CCA ICA LDA NMF PCA LASSO t-SNE 结构预测 概率图模型（贝叶斯网络，CRF, HMM） 异常检测 k-NN 局部离群因子 神经网络 自编码 深度学习 多层感知机 RNN 受限玻尔兹曼机 SOM CNN 理论 偏差/方差偏置(Bias-Variance Tradeoff)：一般而言高偏差意味着欠拟合，高方差意味着过拟合 计算学习理论 经验风险最小化 PAC学习 统计学习 VC理论 THE END.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://ai.wisim.me/tags/机器学习/"}]},{"title":"LeetCode:70. Climbing Stairs","slug":"2016-08-21-LeetCodeClimbingStairs","date":"2016-08-20T16:00:00.000Z","updated":"2018-03-14T06:12:40.670Z","comments":true,"path":"2016/08/21/2016-08-21-LeetCodeClimbingStairs/","link":"","permalink":"http://ai.wisim.me/2016/08/21/2016-08-21-LeetCodeClimbingStairs/","excerpt":"LeetCode:70. Climbing Stairs12You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?","text":"LeetCode:70. Climbing Stairs12You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 题目的意思就是让你爬n阶提子，但是每次只能爬一个阶梯或者两个阶梯。让你求出所有的可能性。 想想看，由于只能爬1或者2，所以我们爬一个阶梯只有一种可能性，但是爬两个阶梯就有两种可能，也就是两个1或者一个2。 这样举个例子，思考一下，因为只能爬1或者2个阶梯，所以爬到4只有两个可能，就是从3爬一步爬到4或者从2爬两步爬到4。因此爬到4的可能性也就确定了，也就是从0爬到3的可能性以及从0爬到2的可能性之和。再往前看，爬到3有几种可能：从1爬两步爬到3，以及从2爬一步爬到3。爬到2的可能性：从1爬一步到2或者从0爬两步到2。这样就可以算到从0爬到4的可能性了。来看一下Java代码实现 ： 123456789101112131415161718192021222324252627public class Solution &#123; public int climbStairs(int n) &#123; //将1，2两种步伐抽象成一个数组，这样下面的代码对其他的步伐也适用 int[] arr = new int[]&#123;1,2&#125;; //每个阶梯的可能的情况都放在res数组对应的位置 int[] res = new int[n+1]; if(n &lt; arr[0]) &#123; return 0; &#125; for(int i = 1 ; i &lt; n+1 ; i++) &#123; //循环每种步伐 for(int j = 0 ; j &lt; arr.length;j++) &#123; if(i == arr[j]) &#123; //如果等于步伐中的某一步，则该位置的结果增加自身这一种可能性 res[i]+=1; &#125; else if(i &gt; arr[j])&#123; //如果大于步伐，则减去该步伐所得位置的可能性要加在当前位置的可能性里面。 res[i]+=res[i-arr[j]]; &#125; else &#123; break; &#125; &#125; //System.out.println(i+ \" : \" +res[i]); &#125; return res[n]; &#125;&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:377. Combination Sum IV","slug":"2016-08-20-LeetCodeCombinationSumIV","date":"2016-08-19T16:00:00.000Z","updated":"2018-03-14T06:12:40.669Z","comments":true,"path":"2016/08/20/2016-08-20-LeetCodeCombinationSumIV/","link":"","permalink":"http://ai.wisim.me/2016/08/20/2016-08-20-LeetCodeCombinationSumIV/","excerpt":"LeetCode:377. Combination Sum IV12345678910111213141516171819Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.Example:nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7.","text":"LeetCode:377. Combination Sum IV12345678910111213141516171819Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.Example:nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. 题目的意思就是给你一个正整数数组，里面的元素不重复（未排序）。再给你一个目标数值，要你用数组里面的数组合起来的和是目标数值，求出有多少种可能。 这道题目有点像那个爬梯子的题目。同时也可以看看这篇文章ClimbingStairs。 两道题目有异曲同工之妙，我们来思考一下这道题目。如果我要求和为4的所有可能性，首先要求(4-1),(4-2),(4-3)的可能性，它们的和就是4的可能性。来看一下Java代码实现： 123456789101112131415161718public class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; Arrays.sort(nums); int[] res = new int[target+1]; for (int i = 1 ; i &lt; target+1;i++) &#123; for(int num : nums) &#123; if(i == num) &#123; res[i]+=1; &#125; else if(i &gt; num) &#123; res[i]+= res[i-num]; &#125; else &#123; break; &#125; &#125; &#125; return res[target]; &#125;&#125; THE END","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:385. Mini Parser","slug":"2016-08-18-LeetCodeMinParser","date":"2016-08-17T16:00:00.000Z","updated":"2018-03-14T06:12:40.669Z","comments":true,"path":"2016/08/18/2016-08-18-LeetCodeMinParser/","link":"","permalink":"http://ai.wisim.me/2016/08/18/2016-08-18-LeetCodeMinParser/","excerpt":"LeetCode:385. Mini Parser123456789Given a nested list of integers represented as a string, implement a parser to deserialize it.Each element is either an integer, or a list -- whose elements may also be integers or other lists.Note: You may assume that the string is well-formed:String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,, ].","text":"LeetCode:385. Mini Parser123456789Given a nested list of integers represented as a string, implement a parser to deserialize it.Each element is either an integer, or a list -- whose elements may also be integers or other lists.Note: You may assume that the string is well-formed:String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,, ]. 题目的意思就是给你一个由好多int值嵌套在一起的字符串。让你写一个解析器，把里面的元素解析出来。每个元素呢，要么是一个int值，要么是一个列表，而这个列表的元素又可以是int或者其他列表，如此嵌套而成。几个注意点：给定的字符创不为空且不含空格，只包含0-9以及[]还有,和-。 讲讲思路先 遇到’[‘字符肯定是要产生一个新的 NestedInteger 对象的。 遇到’]’字符则表明上一个元素可以结束了，此时要处理这里面的整型字符串，将其解析成int值再传给当前的NestedInteger对象。并且呢，由于当前元素已经结束解析，还需要将它传给它的父NestedInteger。 遇到’,’字符要分情况了，如果它的前一个字符是’]’则表明在步骤2种已经做了处理了，否则的话说明之前的整型字符串还没有解析。 如果遇到了0到9还有－，则暂时不作处理，将其拼接到一个StringBuilder里面。 看看Java代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public NestedInteger deserialize(String s) &#123; if (s.isEmpty()) return null; if (s.charAt(0) != '[') // ERROR: special case return new NestedInteger(Integer.valueOf(s)); //stack 用于保存上一个 NI 对象 Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;(); //curNi用于保存当前 NI 对象 NestedInteger curNi = null; StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; s.length() ; i++ ) &#123; char c = s.charAt(i); if(c == '[') &#123; //如果当前 curNi 不为空，则 curNi 临时push进 stack if(curNi != null) &#123; stack.push(curNi); &#125; //并且遇到'['之后要实例化新的 curNi curNi = new NestedInteger(); &#125; else if (c == ']') &#123; //遇到']'之后，就要把之前的字符串解析成int了 if(sb.length() &gt;0) &#123; curNi.add(new NestedInteger(Integer.parseInt(sb.toString()))); sb.setLength(0); &#125; //如果 stack 不为空则把 curNi 添加到 stack的顶层NI 中。 if(!stack.empty()) &#123; NestedInteger popNi = stack.pop(); popNi.add(curNi); curNi = popNi; &#125; &#125; else if (c == ',')&#123; //如果前一个元素是]，则已经处理；如果不是，则要把前面的元素解析成int if(s.charAt(i-1) != ']') &#123; curNi.add(new NestedInteger(Integer.parseInt(sb.toString()))); sb.setLength(0); &#125; &#125; else &#123; sb.append(c); &#125; &#125; return curNi; &#125;&#125; 我们这里再来拿一个字符串来讨论看看，对于字符串”[-1,[123],[[3]]]” 首先遇到’[‘产生一个NestedInteger，对应着最外层的NestedInteger， 记作NI1，并赋值给curNi(NI1)； 接着向后遍历，直到遇到了第一个’,’，此时要为前面的整型值’-1’实例化一个NestedInteger对象，并插入到最外层的curNi(NI1)； 继续向后遍历，遇到第二个’[‘，先将curNi(NI1)压入stack中，再实例化一个新的NestedInteger对象，记作NI2，且令赋值给curNi(NI2)； 向后遍历，遇到第二个’[‘所对应的’]’，为前面的整型值’123’实例化一个NestedInteger对象，add进curNI(NI2)中。再弹出stack中的NI1对象，将curNI(NI2)add到NI中，再令curNi ＝ NI1，注意此时stack中已空； 继续，遇到第二个’,’但是发现它的前一个字符是’]’，不作处理； 继续遍历，遇到第三个’[‘，先将curNI(NI1)压入stack中。再实例化一个新的NestedInteger对象，记作NI3，令curNI = NI3； 继续遍历，遇到第四个’[‘，先将curNI(NI3)压入stack中。再实例化一个新的NestedInteger对象，记作NI4，令curNI = NI4； 继续遍历，遇到第四个’[‘所对应的’]’，为’3’实例化一个NestedInteger对象，插入到curNI(NI4)中。从stack中弹出NI3，将curNI(NI4)插入到NI3中，且令curNI = NI3； 继续遍历，遇到第三个’[‘所对应的’]’，前面没有未处理的整型字符串。此时stack里面还有一个NI1，弹出NI1，将curNI(NI3)add给NI1，且令curNI = NI1； 到了最后一个’]’，也对应了第一个’]’，此时stack为空，且没有未处理的字符串了。此时，curNI就对应了最外层的那个NestedInteger，是不是很神奇。结束。 THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:378. Kth Smallest Element in a Sorted Matrix","slug":"2016-08-13-LeetCodeKthSmallest","date":"2016-08-12T16:00:00.000Z","updated":"2018-03-14T06:12:40.669Z","comments":true,"path":"2016/08/13/2016-08-13-LeetCodeKthSmallest/","link":"","permalink":"http://ai.wisim.me/2016/08/13/2016-08-13-LeetCodeKthSmallest/","excerpt":"LeetCode:378. Kth Smallest Element in a Sorted Matrix12345678910111213Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.Note that it is the kth smallest element in the sorted order, not the kth distinct element.Example:matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13.Note:You may assume k is always valid, 1 ≤ k ≤ n2.","text":"LeetCode:378. Kth Smallest Element in a Sorted Matrix12345678910111213Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.Note that it is the kth smallest element in the sorted order, not the kth distinct element.Example:matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13.Note:You may assume k is always valid, 1 ≤ k ≤ n2. 题目的意思呢就是给你一个n x n的矩阵，而这个矩阵的每一行以及每一列的元素大小都是递增（也可以相等）。让你找到第k小的那个元素。值得注意的是第k小的意思并不是绝对第k小。怎么讲呢，比如上面的example中的两个13，它们分别是第7小和第8小。也就是想等的元素也各自算一个k。 拿到手第一个想到的动态规划，不过后来发现题目理解错了，那就快排呗，不过这也达不到hard的level啊。构造一个搜索二叉树？嗯也是可以的，不过代价还是有点大。看了讨论之后发现居然直接可以使用 PriorityQueue 来解决。我真是越来越不懂这套路了。 优先队列PriorityQueue的本质是最小堆，每次插入和删除时都会动态更新堆中元素的位置。这就给我们提供了方便的解法了。 后来转念一想，干嘛不直接放到List里面，然后一顿排序。岂不快哉。 看一下Java代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class KthSmallest &#123; public int kthSmallest(int[][] matrix, int k) &#123; Comparator&lt;Integer&gt; comparator = new IntegerLengthComparator(); PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(10, comparator); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; queue.add(matrix[i][j]); &#125; &#125; int pos=0; while (queue.size() &gt; 0) &#123; pos++; if (pos == k) &#123; return queue.poll(); &#125; queue.poll(); &#125; return -1; &#125; public int kthSmallestList(int[][] matrix, int k) &#123; Comparator&lt;Integer&gt; comparator = new IntegerLengthComparator(); List&lt;Integer&gt; queue = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; queue.add(matrix[i][j]); &#125; &#125; Collections.sort(queue,comparator); return queue.get(k-1); &#125; public static class IntegerLengthComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer x, Integer y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0; &#125; &#125;&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:381. Insert Delete GetRandom O(1)","slug":"2016-08-12-LeetCodeInsertDeleteGetRandom","date":"2016-08-11T16:00:00.000Z","updated":"2018-03-14T06:12:40.668Z","comments":true,"path":"2016/08/12/2016-08-12-LeetCodeInsertDeleteGetRandom/","link":"","permalink":"http://ai.wisim.me/2016/08/12/2016-08-12-LeetCodeInsertDeleteGetRandom/","excerpt":"LeetCode:381. Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time.Note: Duplicate elements are allowed.insert(val): Inserts an item val to the collection.remove(val): Removes an item val from the collection if present.getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.","text":"LeetCode:381. Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time.Note: Duplicate elements are allowed.insert(val): Inserts an item val to the collection.remove(val): Removes an item val from the collection if present.getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains. 题目的意思是要你设计一个数据结构，使得它的插入和删除时间复杂度都是O(1)，并且能够随机返回一个元素，而返回这个元素的概率也是和这个元素的个数是线性相关的。允许插入相同的元素。 说实话一看到这个题目我是没有思路的。我想这总不至于让你设计一个和HashMap一样的数据结构吧。看了一下别人的解法，确实不至于。要说的是这个数据结构内部可以使用HashMap，而不必自己从0开始写一个。 来说一下大概的思路吧，这个数据结构暂且就叫 RandomizedCollection ，它有一个 Map","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:384. Shuffle an Array","slug":"2016-08-12-LeetCodeShuffleArray","date":"2016-08-11T16:00:00.000Z","updated":"2018-03-14T06:12:40.668Z","comments":true,"path":"2016/08/12/2016-08-12-LeetCodeShuffleArray/","link":"","permalink":"http://ai.wisim.me/2016/08/12/2016-08-12-LeetCodeShuffleArray/","excerpt":"LeetCode:384. Shuffle an Array Shuffle a set of numbers without duplicates.","text":"LeetCode:384. Shuffle an Array Shuffle a set of numbers without duplicates. 洗牌算法，题目的意思就是交换数组元素的位置，并且保证每种情况出现的概率是一样大。 一开始的思路呢，就是生成一个随机数(0到数组长度之间)，把这个随机数对应位置元素插入到一个等长的新数组中，如果生成的随机数已经出现过，则继续生成。直到新的数组放满。 后来呢，发现重复生成随机数会导致Time Limit Exceeded。值得再考虑考虑了。怎样才能保证生成的随机数即使重复了也有效呢。 首先在数组末尾设置一个标兵。每次生成的随机数（0到标兵位置之间）,把对应位置的元素和数组的标兵元素交换，标兵再向前移动一位。 这样就保证了即使随机数重复，对应位置的元素由于之前已经交换过，所以实际位置的元素并不会重复。而标兵位置之后的元素都是已经出现过的不会再出现了。看一下Java代码实现： 12345678910111213141516171819202122232425262728293031import java.util.Random;public class Solution &#123; private int[] mNums; public Solution(int[] nums) &#123; mNums = nums; &#125; public int[] reset() &#123; return mNums; &#125; public int[] shuffle() &#123; int len = mNums.length; int pos = len-1; int[] arr = new int[len]; for(int i = 0 ; i &lt; len;i++) &#123; arr[i] = mNums[i]; &#125; Random random = new Random(); while(pos &gt; 0) &#123; int ranNum = random.nextInt(pos+1); int temp = arr[pos]; arr[pos] = arr[ranNum]; arr[ranNum] = temp; pos--; &#125; return arr; &#125;&#125; THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:383. Ransom Note","slug":"2016-08-11-LeetCodeRansomNote","date":"2016-08-10T16:00:00.000Z","updated":"2018-03-14T06:12:40.668Z","comments":true,"path":"2016/08/11/2016-08-11-LeetCodeRansomNote/","link":"","permalink":"http://ai.wisim.me/2016/08/11/2016-08-11-LeetCodeRansomNote/","excerpt":"eetCode:383. Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines,write a function that will return true if the ransom note can be constructed from the magazines ;otherwise,it will return false.Each letter in the magazine string can only be used once in your ransom note.Note:You may assume that both strings contain only lowercase letters.","text":"eetCode:383. Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines,write a function that will return true if the ransom note can be constructed from the magazines ;otherwise,it will return false.Each letter in the magazine string can only be used once in your ransom note.Note:You may assume that both strings contain only lowercase letters. 题目的意思就是给你两个字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，第二个字符里的每个字符只能使用一次。（假设只包含小写字母） 那么首先想到的就是穷举法了，两层遍历即可，也就是下面的 canConstruct 方法了。 再思考一下，有个小技巧。这里只要判断两个字符串中每个字母出现的次数即可解决问题。对于某个字母来说，如果第ransom字符串中出现的次数比magazines中出现的次数要多，很显然就直接返回false了。 看一下 canConstructBetter 方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.List;import java.util.ArrayList;public class Solution &#123; public boolean canConstructBetter(String ransomNote, String magazine) &#123; if (ransomNote.equals(magazine) || \"\".equals(ransomNote)) &#123; return true; &#125; if (\"\".equals(magazine) &amp;&amp; !\"\".equals(ransomNote)) &#123; return false; &#125; int[] ransomNoteCharCount = new int[26]; int[] magazineCharCount = new int[26]; for(int i = 0 ; i &lt; ransomNote.length() ; i++) &#123; ransomNoteCharCount[ransomNote.charAt(i)-'a']++; &#125; for(int i = 0 ; i &lt; magazine.length() ; i++) &#123; magazineCharCount[magazine.charAt(i)-'a']++; &#125; for(int i = 0 ; i &lt; 26 ; i++) &#123; if(ransomNoteCharCount[i] &gt; magazineCharCount[i] ) &#123; return false; &#125; &#125; return true; &#125; public boolean canConstruct(String ransomNote, String magazine) &#123; if (ransomNote.equals(magazine)) &#123; return true; &#125; if (\"\".equals(ransomNote)) &#123; return true; &#125; List&lt;Character&gt; ransomNodeChars = new ArrayList&lt;&gt;(); List&lt;Character&gt; magazineChars = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; ransomNote.length() ; i++) &#123; ransomNodeChars.add(ransomNote.charAt(i)); &#125; this.printList(ransomNodeChars); for(int j = 0 ; j &lt; magazine.length() ; j++) &#123; magazineChars.add(magazine.charAt(j)); &#125; boolean flag = false; Character c = null; for(int m = 0 ; m &lt; ransomNote.length() ; m++) &#123; c = ransomNodeChars.get(m); flag = false; for(int n = 0 ; n &lt; magazineChars.size() ; n++) &#123; if(magazineChars.get(n) == c) &#123; flag = true; magazineChars.remove(n); break; &#125; &#125; if (flag == false) &#123; break; &#125; &#125; return flag; &#125;&#125; THE END","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"LeetCode:382. Linked List Random Node","slug":"2016-08-10-LeetCodeLinkedListRandomNode","date":"2016-08-09T16:00:00.000Z","updated":"2018-03-14T06:12:40.667Z","comments":true,"path":"2016/08/10/2016-08-10-LeetCodeLinkedListRandomNode/","link":"","permalink":"http://ai.wisim.me/2016/08/10/2016-08-10-LeetCodeLinkedListRandomNode/","excerpt":"LeetCode:382. Linked List Random Node Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?","text":"LeetCode:382. Linked List Random Node Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? 题目的意思就是给你一个链表，要你从链表中取出一个值，并且保证取到每个元素的概率都是相等的。还要思考如果链表长度极其大，咋办。能不能不使用额外的空间就能达到目的。 一开始我的想法就是直接遍历一次拿到链表的长度，再生成一个随机值，拿到这个值对应位置的元素即可。但是我觉得这种解法完全达不到Medium的难度啊。看了讨论学又到一个新词：蓄水池抽样算法。 蓄水池抽样算法的结论就是：在N（N不确定）个元素中取出K个元素的概率就是 K/N。这里我们令K等于1，就可以用来解上面的这道题目了。Java代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Random;public class Solution &#123; private Random mRandom; private ListNode head; public Solution(ListNode head) &#123; this.head=head; &#125; /** *蓄水池抽样算法 */ public int getRandom() &#123; mRandom=new Random(); int pos = 1; ListNode node = head; ListNode res = head; while(node != null) &#123; //一直取最末尾的一个数 if (mRandom.nextInt(pos) == (pos-1)) &#123; res = node;//此处不可直接return。取第一个值的时候概率是百分之百，直接返回。 &#125; pos = pos+1; node = node.next; &#125; return res == null ? head.val : res.val; &#125; /** *先获取长度再取随机值的方法 */ public int getRandomXX() &#123; int randomVaule = mRandom.nextInt(this.getLength()); int pos = 0; ListNode res = head; while(res != null) &#123; if(pos == randomVaule) &#123; return res.val; &#125; res = res.next; pos++; &#125; return res.val; &#125; public int getLength() &#123; int len = 0; ListNode node = head; while(node != null) &#123; len++; node = node.next; &#125; return len; &#125;&#125; 那么为什么蓄水池抽样算法会保证每个元素被取到的概率是一样的呢？让我们一步一步来验证一下。 我们这里来考察选择最后一个元素的概率。 首先如果只有一个元素的时候，概率是1； 如果有两个元素，取到第二个元素的概率是1/2； 如果有三个元素，要保证每个元素取到的概率都是一样，有两种情况，第一种就是取第三个元素，取到的概率是1/3。但是如果不是取到第三个元素，而是取到第二个呢？那就是下面这种情况 ： 取不到第三个元素的概率 x 取到第二个元素的概率 = (2/3) x (1/2) = 1/3 可以用数学归纳法来证明一下： 假设已经读取n个数，现在保留的数是An，取到An的概率为(1/n)。 123456789101112131415对于第n+1个数An+1，以1/(n+1)的概率取An+1，否则仍然取An。依次类推，可以保证取到数据的随机性。数学归纳法证明如下： 当n=1时，显然，取A1。取A1的概率为1/1。 假设当n=Max时，取到的数据AMax。取AMax的概率为1/Max。 当n=Max+1时，以1/(Max+1)的概率取AMax+1，否则仍然取AMax。 (1)如果取AMax+1，则概率为1/(Max+1)； (2)如果不取AMax+1而仍然取AMax，则概率为(1/Max)*(Max/(Max+1))=1/(Max+1)所以，对于之后的第n+1个数An+1，以1/(n+1)的概率取An+1，否则仍然取An。依次类推，可以保证取到数据的随机性。 THE END.","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://ai.wisim.me/categories/Alogrithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ai.wisim.me/tags/LeetCode/"}]},{"title":"常用的Latex公式","slug":"1970-01-01-01","date":"1969-12-31T16:00:00.000Z","updated":"2018-02-24T05:24:41.189Z","comments":true,"path":"1970/01/01/1970-01-01-01/","link":"","permalink":"http://ai.wisim.me/1970/01/01/1970-01-01-01/","excerpt":"空格直接是 \\:","text":"空格直接是 \\: 1. 极限$\\lim _{\\tiny{x\\rightarrow \\infty} }( b^{\\tiny{\\dfrac {1} {n}}}-1)$ 1$\\lim _&#123;\\tiny&#123;x\\rightarrow \\infty&#125; &#125;(...)$ 2. 字体大小(1) 极小的字体 1\\tiny 3. 角标(1) 右上角 : $b^{\\tiny{\\dfrac {1} {n}}}$ 1$b^&#123;\\tiny&#123;...&#125;&#125;$ (2) 右下角 : $b_{\\tiny{\\dfrac {1} {n}}}$ 1$b_&#123;\\tiny&#123;\\dfrac &#123;1&#125; &#123;n&#125;&#125;&#125;$ 4. 分数形式(1) $\\dfrac{a}{b}$1$\\dfrac&#123;...&#125;&#123;...&#125;$ 5. 希腊字母 字母 源码 $\\pi$ \\pi $\\alpha$ \\alpha $\\beta$ \\beta $\\theta$ \\theta $\\varepsilon$ \\varepsilon $\\delta$ \\delta $\\eta$ \\eta $\\lambda$ \\lambda $\\xi$ \\xi $\\tau$ \\tau $\\psi$ \\psi $\\phi$ \\phi 6. 数学符号 符号 说明 源码 $\\leq$ 小于等于 \\leq $\\geq$ 大于等于 \\geq $\\neq$ 不等于 \\neq $\\in$ 在区间内 \\in $\\cdot$ 点乘 \\cdot $\\sum ^{n}_{i=0} {i\\cdot n}$ 累加 \\sum ^{...}_{...} {...} $\\Delta x_{i}$ delta \\Delta $\\int _{a}^{b}$ 积分 \\int _{a}^{b} THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://ai.wisim.me/tags/TOOLS/"}]}]}