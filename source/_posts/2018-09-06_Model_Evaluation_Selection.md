---
title: 模型评估与选择
date: 2018-09-06
categories: ML
tags: [ML]
---

#### 一、经验误差与过拟合

1. 错误率(error rate)：分类错误的样本数占样本总数的比例,E = a/m
2. 精度(accuracy)：精度 = 1 一 错误率
3. 误差(error)：学习器的实际预测输出与样本的真实输出之间的差异
4. `经验误差`(empirical error)：学习器在训练集上的误差，也叫训练误差(training error)
5. `泛化误差`(generalization error)：学习器在新样本上的误差
6. `过拟合`(overfitting)：当学习器把训练样本学得"太好"了的时候，很可能巳经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象称为过拟合。其中最常见的情况是由于学习能力过于强大，以至于把训练样本所包含的不太一般的特性都学到了。

过拟合为什么无法避免？机器学习面临的问题通常是NP 难甚至更难，而有效的学习算法必然是在多项式时间内运行完成，若可彻底避免过拟合， 则通过经验误差最小化就能获最优解，这就意味着我们构造性地证明了 "P=NP" ;因此只要相信"P≠NP " ，过拟合就不可避免P。

7. `欠拟合`(underfitting)：是指对训练样本的一般性质尚未学好。通常是由于学习能力低下而造成的。

<!--more-->

#### 二、模型评估方法

通常，我们可以通过实验测试来对学习器的`泛化误差`进行评估并进而做出选择。为此，需要使用一个“测试集” (testing set) 来测试学习器对新样本的判别能力，然后以测试集上的 “测试误差” (testing error) 作为泛化误差的近似。通常我们假设测试样本也是从样本真实分布中`独立同分布`采样而得。但需要注意的是，测试集应该尽可能与训练集`互斥`，即测试样本尽量不在训练集中出现、未在训练过程中使用过。

我们只有一个包含 m 个样例的数据集 $D=\{(x_1, y_1), (x_2, y_2), ... , (x_m, y_m)\}$ ​， 既要训练，又要测试，怎样才能做到呢？答案是：通过对  D 进行适当的处理，从中产生出训练集 S 和测试集​ T 。下面介绍几种常见的做法。

1. 留出法（hold-out）

直接将数据集D 划分为两个互斥的集合，一个用来训练模型，一个评估。$D = S\cup T, \; S\cap T = \emptyset$，D为总数据集，S为训练数据集，T为测试数据集。

- S 过大，测试误差不够准确
- T 过大，训练出的模型不够准确

训练和测试集的划分要尽可能保持数据分布的一致性，避免因数据划分引入额外的偏差。一种保留类别比例的采样：stratified sampling.

单次使用留出法得到的估计结果不够稳定可靠。一般采用若干次随机划分、重复实验取平均值。

常见做法：大约 2/3 ~ 4/5 的样本用于训练，剩余样本用于测试。

2. 交叉验证法（cross validation)

将 D 做分成 k 个大小相似的部分, $D = D_1\cup D_2 \cup \ldots \cup D_k, \; D_i\cap D_j = \emptyset \, (i\neq j)$，留下一个做测试集，其他作为训练集，从而得到 k 次训练和测试。划分本身还要随机重复 p 次，最终的评估结果是这 p 次  k 折交叉验证结果的均值。通常把交叉验证法称为 `k 折交叉验证` (​ k - fold cross validation)。​ 最常用的取值是 10，此时称为 10 折交叉验证；其他常用的 k 值有 5、20 等。

特殊例子：k = m(数据集中的数据个数), 称为留一法(LOO). 当 m 很大时工作量太大。

3. 自助法(bootstrapping)

自助采样(bootstrap sampling)：sampling with replacement.

给定包含 m 个样本的数据集D，每次有放回取出一个样本，重复m次，构成采样数据集D'。有一部分样本会重复出现，有一部分不会出现。样本在 m 次采样中始终不被采到的概率是：

$$\lim_{m\to \infty} \left (1-\frac{1}{m}\right )^m = \frac{1}{e} \approx 0.368$$

所以大约有 1/3 的样本不会在采样集中出现。采样数据集作为训练集，剩下的作为测试集。

- 优点：自助法在数据集较小、难以有效划分时有用。
- 缺点：`自助法改变了初始数据集的分布，会引入估计偏差`。

4. 调参与最终模型(parameter tuning)

参数空间太大，调参的工作量很大。在不少应用中，参数调得好不好往往对最终模型性能有关键性影响。

如果误差函数对参数是光滑的，可以用优化算法寻找最优参数。

模型评估与选择中用于评估测试的数据集称为 validation set，和测试集不同，属于训练数据中的一部分。

#### 三、性能度量（performance measure）

回归任务最常用的是“均方误差”（mean squared error) ：

$$E(f; D) = \frac{1}{m}\sum_{i=1}^m (f(\boldsymbol x_i)-y_i)^2 \tag{3.1}$$

更一般地，对于数据分布D和概率密度p(x)的表达式如下：

$$E(f; \mathcal D) = \int_{\boldsymbol x\sim \mathcal D} (f(\boldsymbol x)-y)^2p(\boldsymbol x) {\rm d}\boldsymbol x \tag{3.2}$$

其实3.1和3.2式分别就是离散数据和连续数据的均方误差表达式。

1. 错误率与精度

对于数据分布D:

错误率：$E(f; \mathcal D) = \frac{1}{m}\sum_{i=1}^m(f(x_i)\neq y_i)$

错误率更一般的表达式：$E(f; \mathcal D) = \int_{\boldsymbol x\sim \mathcal D} (f(\boldsymbol x)\neq y)p(\boldsymbol x) {\rm d}\boldsymbol x$

精度：$E(f; \mathcal D) = \frac{1}{m}\sum_{i=1}^m(f(x_i) = y_i)$

精度更一般的表达式：$E(f; \mathcal D) = \int_{\boldsymbol x\sim \mathcal D} (f(\boldsymbol x) = y)p(\boldsymbol x) {\rm d}\boldsymbol x$

2. 查准率、查全率与F1

以信息检索为例：

- 查准率(precision): 检索出的信息中有多少比例是用户感兴趣的
- 查全率(recall)：用户感兴趣的信息中有多少被检索出来了

对于二分类问题，可将样例根据其`真实类别以及机器学习分类器预测类别`的组合划分为真正例（true positive）、假正例子（false positive）、真反例（true negative）以及假反例（false negative）四种情形。令TP、FP、TN、FN分别表示其对应的`样例数`。显然有 TP+FP+TN+FN=总样例数。分类结果的“混淆矩阵”（confusion matrix）如下：

![混淆矩阵](/src/imgs/1809/0906_confusionmatrix.png)

- 查准率 $P=\frac{TP}{TP+FP}$

- 查全率 $R=\frac{TP}{TP+FN}$

另外，人们设计了一些综合考虑查准率和查全率的性能度量。

`平衡点`（Break-Event Point,BEP）是这其中的一个度量，它是“查准率=查全率”时的取值。

BEP过于简化，更常用的是`F1度量`：

$$F1=\frac{2 \times P \times R}{P+R}=\frac{2 \times TP}{样例总数+TP-TN} \tag{3.3}$$

考虑到有的应用中查准率和查全率的权重不同，给出F1度量更一般的形式：

$$F_{\beta}=\frac{(1+{\beta}^2) \times P \times R}{({\beta}^2 \times P)+R} \tag{3.4}$$

其中$\beta$表示查全率对查准率的相对重要性。$\beta=1$时退化为标准的F1度量（3.3式）。$\beta > 1$时，查全率更重要。$\beta < 1$时查准率更重要。

#### 四、比较检验

机器学习中性能比较比想象的要复杂。原因有三：

1. 希望比较泛化性能，但获得的度量是测试集上的，两者有差别； 
2. 测试集上的性能和测试集的选取有关； 
3. 算法的随机性。

统计假设检验(hypothesis test)为我们比较学习器性能提供了重要依据. 若在测试集上学习器A比B好，则A的泛化性能是否在统计意义上优于B，以及这个结论的把握有多大。

1. 假设检验

- 二项检验
- t检验

2. 交叉验证t检验
3. McNemar检验
4. Friedman检验和Nemenyi后续检验

#### 五、偏差与方差

“偏差-方差分解”（bias-variance decomposition）是解释机器学习算法泛化性能的一种重要工具。偏差-方差分解试图对学习算法的期望泛化错误率进行拆解。

泛化误差可以分解为偏差、方差与噪声之和：
$$E(f;D)=bias^2(x)+var(x)+\epsilon^2$$


- - -
THE END.