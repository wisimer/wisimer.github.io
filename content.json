{"meta":{"title":"XP","subtitle":null,"description":"This is AI of Wisimer","author":"Wisimer","url":"http://ai.wisim.me"},"pages":[{"title":"Hello AI.","date":"2018-07-24T06:24:34.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"about/index.html","permalink":"http://ai.wisim.me/about/index.html","excerpt":"","text":"The more we do,the more we can do. 关于WISIM这是我的个人站点，用来记录和分享平时的一些AI技术学习上的发现，以及生活上的感悟和思想。 关于ARTS每周至少一个 ARTS Algorithm : 一个算法题 Review/Reading : 点评一篇英文技术文章/阅读一篇英语文章 Tip : 学习一个技术技巧 Share : 分享一个技术观点和思考 ARTS Rules: ARTS汇总文件名 :0000-00-00-ARTS_ISSUE_000.md ARTS汇总文章的category : ARTS ARTS汇总文章的tags : ARTS 单个ARTS类别文件名 : 0000-00-00-ARTS_ISSUE_000_a/r/t/s.md 单个ARTS类别文章的category : 根据文章自定，不得使用ARTS，保证 ARTS 分类下面是所有ISSUE 单个ARTS类别文章的tags : 根据文章自定，同时加入 ARTS 标签 主要分类 MACHINE LEARING (ML) ALGORITHM MATH JAVA SOFTWARE ENGINEERING (SE) ANDROID (@deprecated) 规则 文件命名 : 日期_标题，使用下划线分割主题 categories : 分类后面使用大写单词 tags : 多个标签使用[]包裹，并用逗号,分割 关于我 90后 男 计算机专业 吟诗（打油诗）作画（无聊自黑漫画） 联系我 E-mail：wisimer@163.com Blog：http://ai.wisim.me 链接 MathPad LeetCode LintCode Nowcoder QiNiu"},{"title":"ARTS","date":"2018-07-24T06:24:34.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"arts/index.html","permalink":"http://ai.wisim.me/arts/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-24T06:24:34.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"categories/index.html","permalink":"http://ai.wisim.me/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-24T06:24:34.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"tags/index.html","permalink":"http://ai.wisim.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"sklearn 技巧","slug":"2018-09-17_sklearn_tricks","date":"2018-09-16T16:00:00.000Z","updated":"2018-09-17T11:31:42.000Z","comments":true,"path":"2018/09/17/2018-09-17_sklearn_tricks/","link":"","permalink":"http://ai.wisim.me/2018/09/17/2018-09-17_sklearn_tricks/","excerpt":"1. 模型的保存和读取使用 joblib 模块。 保存： 1234567891011121314151617181920from sklearn.datasets import load_iris # iris数据集from sklearn.model_selection import train_test_split # 分割数据模块from sklearn.neighbors import KNeighborsClassifier # K最近邻(kNN，k-NearestNeighbor)分类算法from sklearn.externals import joblib #jbolib模块iris = load_iris()X = iris.datay = iris.target# 分割数据并X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=4)# 建立模型knn = KNeighborsClassifier()# 训练模型knn.fit(X_train, y_train)# 保存模型(注:保存模型所在的文件夹要预先建立，否则会报错)joblib.dump(knn, &apos;/Users/mac/Downloads/knn.pkl&apos;) 读取和使用： 123knn = joblib.load(&apos;/Users/mac/Downloads/knn.pkl&apos;)print(knn.predict(X_test[0:1]))# [2]","text":"1. 模型的保存和读取使用 joblib 模块。 保存： 1234567891011121314151617181920from sklearn.datasets import load_iris # iris数据集from sklearn.model_selection import train_test_split # 分割数据模块from sklearn.neighbors import KNeighborsClassifier # K最近邻(kNN，k-NearestNeighbor)分类算法from sklearn.externals import joblib #jbolib模块iris = load_iris()X = iris.datay = iris.target# 分割数据并X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=4)# 建立模型knn = KNeighborsClassifier()# 训练模型knn.fit(X_train, y_train)# 保存模型(注:保存模型所在的文件夹要预先建立，否则会报错)joblib.dump(knn, &apos;/Users/mac/Downloads/knn.pkl&apos;) 读取和使用： 123knn = joblib.load(&apos;/Users/mac/Downloads/knn.pkl&apos;)print(knn.predict(X_test[0:1]))# [2] THE END.","categories":[{"name":"sklearn","slug":"sklearn","permalink":"http://ai.wisim.me/categories/sklearn/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/tags/ML/"},{"name":"sklearn","slug":"sklearn","permalink":"http://ai.wisim.me/tags/sklearn/"}]},{"title":"sklearn.model_selection 交叉验证","slug":"2018-09-17_sklearn_model_selection","date":"2018-09-16T16:00:00.000Z","updated":"2018-09-18T08:52:59.000Z","comments":true,"path":"2018/09/17/2018-09-17_sklearn_model_selection/","link":"","permalink":"http://ai.wisim.me/2018/09/17/2018-09-17_sklearn_model_selection/","excerpt":"前言1. 什么是交叉验证法？它的基本思想就是将原始数据（dataset）进行分组，一部分做为训练集来训练模型，另一部分做为测试集来评价模型。 2. 为什么用交叉验证法？交叉验证用于评估模型的预测性能，尤其是训练好的模型在新数据上的表现。交叉验证本身只能用于评估，但是可以对比不同 Model 或者参数对结构准确度的影响。然后可以根据验证得出的数据进行调参，也可以在一定程度上减小过拟合。","text":"前言1. 什么是交叉验证法？它的基本思想就是将原始数据（dataset）进行分组，一部分做为训练集来训练模型，另一部分做为测试集来评价模型。 2. 为什么用交叉验证法？交叉验证用于评估模型的预测性能，尤其是训练好的模型在新数据上的表现。交叉验证本身只能用于评估，但是可以对比不同 Model 或者参数对结构准确度的影响。然后可以根据验证得出的数据进行调参，也可以在一定程度上减小过拟合。 Sklearn 中的 Cross Validation (交叉验证)对于我们选择正确的 Model 和 Model 的参数是非常有帮助的， 有了他的帮助，我们能直观的看出不同 Model 或者参数对结构准确度的影响。 一、基础验证123456789101112131415161718192021from sklearn.datasets import load_iris # iris数据集from sklearn.model_selection import train_test_split # 分割数据模块from sklearn.neighbors import KNeighborsClassifier # K最近邻(kNN，k-NearestNeighbor)分类算法#加载iris数据集iris = load_iris()X = iris.datay = iris.target#分割数据并X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=4)#建立模型knn = KNeighborsClassifier()#训练模型knn.fit(X_train, y_train)#将准确率打印出print(knn.score(X_test, y_test))# 0.973684210526 可以看到这里我们先使用 KNN 分类训练数据之后，再用测试集测试，最后直接调用 knn.score，通过 KNN 自带的基础验证的准确率为0.973684210526。 二、Model 交叉验证法(Cross Validation)主要就是使用 sklearn.cross_validation 这个模块 1. sklearn.model_selection.cross_val_score文档： 123sklearn.model_selection.cross_val_score(estimator, X, y=None, groups=None, scoring=None, cv=None, n_jobs=1, verbose=0, fit_params=None, pre_dispatch=&apos;2*n_jobs&apos;)Evaluate a score by cross-validation cross_val_score 是用来进行交叉验证的。它有如下参数： estimator ： 实现了 fit 接口的预测器，也就是我们的模型 X ： 要拟合的数据 y ： 标签 groups ： 分割后的数据每一组的群组标签 cv ： 交叉验证生成器，决定分割验证的策略。有四个可选值： None（默认使用 3 折叠交叉验证），integer（指定 StratifiedKFold 的k值大小），对象，迭代。 n_jobs ： 用于计算的 CPU 的数量，默认1，如果是 -1 则表示用上所有 CPU verbose ： The verbosity level. fit_params ： 从预测器传递给拟合方法的参数 pre_dispatch ： 任务的个数 例子： 123456789101112from sklearn.cross_validation import cross_val_score # K折交叉验证模块#使用K折交叉验证模块，参数 cv 为5，表示直接使用 5 折 StratifiedKFold 交叉验证scores = cross_val_score(knn, X, y, cv=5, scoring=&apos;accuracy&apos;)#将5次的预测准确率打印出print(scores)# [ 0.96666667 1. 0.93333333 0.96666667 1. ]#将5次的预测准确平均率打印出print(scores.mean())# 0.973333333333 可以看到交叉验证的准确平均率为0.973333333333 2. class sklearn.model_selection.KFold此外我们可以使用 KFold 类自己构造一个 K 折交叉验证器。 文档： 1234567class sklearn.model_selection.KFold(n_splits=3, shuffle=False, random_state=None)K-Folds cross-validatorProvides train/test indices to split data in train/test sets. Split dataset into k consecutive folds (without shuffling by default).Each fold is then used once as a validation while the k - 1 remaining folds form the training set. 很显然，KFold这个类是用来分离数据的。可以讲数据集分割成 k-1 个训练集和 1 个测试集。它有三个参数： n_splits ： 表示分为几个数据子集 shuffle ： 要不要打乱数据顺序呢，默认为 False random_state ： 打乱数据顺序所用的种子，默认不使用 例子： 12345678# 实例化一个 k 折叠分割器kfold = model_selection.KFold(n_splits=10, random_state=7)print(kfold)# 验证模型results = model_selection.cross_val_score(knn, X_test, y_test, cv=kfold)print(results.mean())# 0.9 可以看到10折交叉验证的准确平均率为0.9 三、以准确率(accuracy)判断上面验证只是得出某种参数情况下的模型的性能，如果想要横向对比不同参数时模型性能的话则需要多次验证再做对比。 这里使用 KNN 分类器来举例，一般来说准确率(accuracy)会用于判断分类模型的好坏。 123456789101112131415161718192021222324from sklearn import model_selectionimport matplotlib.pyplot as plt#加载iris数据集iris = load_iris()X = iris.datay = iris.target#建立测试参数集k_range = range(1, 31)k_scores = []#通过迭代的方式来计算不同参数对模型的影响，并返回交叉验证后的平均准确率。for k in k_range: knn = KNeighborsClassifier(n_neighbors=k) # 这里通过改变 KNN 的 K 值来测试分类精度 scores = model_selection.cross_val_score(knn, X, y, cv=10, scoring=&apos;accuracy&apos;) k_scores.append(scores.mean())#可视化数据plt.plot(k_range, k_scores)plt.xlabel(&apos;Value of K for KNN&apos;)plt.ylabel(&apos;Cross-Validated Accuracy&apos;)plt.show() 从图中可以得知，选择12~20的k值最好。高过20之后，准确率开始下降则是因为过拟合(Over fitting)的问题。 其实这里就是通过调整不同的 K值来调整 KNN 的分类性能，然后使用交叉验证来直观地显示分类的准确性，也就可以找出一个最佳 K 值使得 KNN 性能最高。 当然， model_selection.cross_val_score 方法的 scoring 参数也可以使用 mean_squared_error(平均方差)。得到的结果和使用 accuracy 相差不多。 参考： [1]. 交叉验证 THE END.","categories":[{"name":"sklearn","slug":"sklearn","permalink":"http://ai.wisim.me/categories/sklearn/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/tags/ML/"},{"name":"sklearn","slug":"sklearn","permalink":"http://ai.wisim.me/tags/sklearn/"}]},{"title":"集成学习 实践","slug":"2018-09-16_EsembleLearning_pratice","date":"2018-09-15T16:00:00.000Z","updated":"2018-09-18T08:51:25.000Z","comments":true,"path":"2018/09/16/2018-09-16_EsembleLearning_pratice/","link":"","permalink":"http://ai.wisim.me/2018/09/16/2018-09-16_EsembleLearning_pratice/","excerpt":"我们\b使用 \b集成学习 方法来对乳腺癌预测，这里的例子使用的数据集是 Wisconsin Breast Cancer dataset/Chapter%2003/wisc_bc_data.csv) 。这个数据集的 diagnosis 列为每一个记录的标签，有 B 和 M两个值，而其他列均是特征。下面我们来一步一步处理。","text":"我们\b使用 \b集成学习 方法来对乳腺癌预测，这里的例子使用的数据集是 Wisconsin Breast Cancer dataset/Chapter%2003/wisc_bc_data.csv) 。这个数据集的 diagnosis 列为每一个记录的标签，有 B 和 M两个值，而其他列均是特征。下面我们来一步一步处理。 一、数据预处理1. 数据导入1234567import pandas as pdimport numpy as npfrom sklearn.preprocessing import Imputerfrom sklearn.preprocessing import MinMaxScalerdata = pd.read_csv(&apos;/Users/mac/Downloads/cancer.csv&apos;)data.head() 看一下输出： 看一下第一列 “id” ，对我们的训练和预测没有什么用，直接去掉即可： 1data.drop([&apos;id&apos;],axis = 1, inplace = True) 去掉之后再看一下数据集的详细信息： 1data.describe() 1data.info() 2. 数据缺失值处理如果数据集中有缺失的话，我们可以使用 data.replace(&#39;?&#39;,0, inplace=True) 来填补缺失值。同样，我们看一下 diagnosis 这一列，也就是诊断结果。由于现在是字符串类型 B or M，需要变为整型\b，直接用 replace 替换为：B(0)，M(1)： 12data.replace(&apos;B&apos;,0, inplace=True)data.replace(&apos;M&apos;,1, inplace=True) 由于这里的 data 还是一个 DataFrame &lt;class pandas.core.frame.DataFrame&gt; 类型的对象，现在要转换为 Numpy 里面的数 ndarray&lt;class numpy.ndarray&gt; ： 1234567891011values = data.valuesprint(values)# 输出替换之后的数据[[ 0. 12.32 12.39 ... 0.09391 0.2827 0.06771] [ 0. 10.6 18.95 ... 0.07926 0.294 0.07587] [ 0. 11.04 16.83 ... 0.07431 0.2998 0.07881] ... [ 1. 15.28 22.41 ... 0.1226 0.3175 0.09772] [ 0. 14.53 13.98 ... 0.1069 0.2606 0.0781 ] [ 1. 21.37 15.1 ... 0.1966 0.273 0.08666]] 如果是在训练集上用规则处理好数据，同时想要应用到测试集上，可以使用 Imputer.fit_transform()，见注[3]。 3. 数据归一化上面缺失值处理好之后发现即使全部类型都变为整型，但是每一列的\b数据范围还是比较大，这样会导致特征的微小变化不会生效。下面对数据进行归一化处理，保证它们的范围都在0-1之间： 123456789101112scaler = MinMaxScaler(feature_range=(0, 1))normalizedData = scaler.fit_transform(values)print(normalizedData)# 输出归一化之后的数据[[0. 0.25268588 0.0906324 ... 0.32271478 0.24876799 0.08310376] [0. 0.17128118 0.31247886 ... 0.27237113 0.27104278 0.136626 ] [0. 0.19210564 0.24078458 ... 0.25536082 0.28247585 0.15590975] ... [1. 0.3927777 0.42948935 ... 0.42130584 0.31736645 0.27994228] [0. 0.35728146 0.14440311 ... 0.36735395 0.20520402 0.15125279] [1. 0.68100715 0.18227934 ... 0.67560137 0.22964715 0.20739866]] 二、使用 sklearn 实现集成学习实例1. Bagging 集成学习先回顾一下 Bagging 算法。Bagging 是并行集成学习方法的代表。我们使用 sklearn.ensemble.BaggingClassifier 来实现 Bagging 集成学习： 文档： 1234class sklearn.ensemble.BaggingClassifier(base_estimator=None, n_estimators=10, max_samples=1.0, max_features=1.0, bootstrap=True, bootstrap_features=False, oob_score=False, warm_start=False, n_jobs=1, random_state=None, verbose=0)A Bagging classifier is an ensemble meta-estimator that fits base classifiers each on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator (e.g., a decision tree), by introducing randomization into its construction procedure and then making an ensemble out of it. BaggingClassifier 有如下几个参数： base_estimator ： 基学习器（可以是多个不同） n_estimators ： base_estimator 的数量 max_samples ： 从数据集中取出训练每个学习器的数据最大个数 max_features ： max_samples 的最大特征数 bootstrap ： 取出样本后是否放回，默认 True bootstrap_features ： 样本特征取出后是否替换 oob_score ： 是否使用 out-of-bag 方法 warm_start ： 是否复用之前的模型 n_jobs ： 工作 CPU 的个数 random_state ： 随机种子 verbose ： The verbosity level 代码： 1234567891011121314151617181920212223from sklearn import model_selectionfrom sklearn.ensemble import BaggingClassifierfrom sklearn.tree import DecisionTreeClassifier# 取特征值X = values[:,1:31]# 取标签Y = values[:,0]# 使用 K 折交叉验证kfold = model_selection.KFold(n_splits=10, random_state=7)# 使用决策树分类cart = DecisionTreeClassifier()num_trees = 100# 使用 Bagging 集成学习model = BaggingClassifier(base_estimator=cart, n_estimators=num_trees, random_state=7)# 执行交叉验证results = model_selection.cross_val_score(model, X, Y, cv=kfold)# 打印 10 次验证结果的平均值print(results.mean())# 0.9561090225563911 当然这里我们也可以横向对比一下， BaggingClassifier 的 n_estimators 参数取不同值的时候，模型的性能如何： 12345678910111213k_range = range(10, 100, 5)k_scores = []for k in k_range: model = BaggingClassifier(base_estimator=cart, n_estimators=k, random_state=7) results = model_selection.cross_val_score(model, X, Y, cv=kfold) #print(results) k_scores.append(results.mean()) plt.plot(k_range, k_scores)plt.xlabel(&apos;Value of n_estimators for BaggingClassifier&apos;)plt.ylabel(&apos;Cross-Validated Accuracy&apos;)plt.show() 从图中可以看到 n_estimators 不是越好，在50-60之间的时候性能较高一点点。 2. AdaBoost 集成学习先回顾一下 Boosting 算法族是一组串行序列化集成学习方法。可以将弱学习器转化为强学习器。我们这里使用 sklearn.ensemble.AdaBoostClassifier 来实现 Boosting 集成学习方法。 文档： 123class sklearn.ensemble.AdaBoostClassifier(base_estimator=None, n_estimators=50, learning_rate=1.0, algorithm=’SAMME.R’, random_state=None)An AdaBoost classifier is a meta-estimator that begins by fitting a classifier on the original dataset and then fits additional copies of the classifier on the same dataset but where the weights of incorrectly classified instances are adjusted such that subsequent classifiers focus more on difficult cases. AdaBoostClassifier 有如下几个参数： base_estimator ： 基础模型 n_estimators ： 模型数量 learning_rate ： 学习速率，通过修改 learning_rate 控制每个模型的贡献值 algorithm ： 具体 boosting 算法，{‘SAMME’, ‘SAMME.R’}二选一 random_state ： 随机种子 代码： 123456789101112from sklearn.ensemble import AdaBoostClassifierseed = 7num_trees = 70kfold = model_selection.KFold(n_splits=10, random_state=seed)# 使用 AdaBoost 集成学习model = AdaBoostClassifier(n_estimators=num_trees, random_state=seed)results = model_selection.cross_val_score(model, X, Y, cv=kfold)# 打印 10 次验证结果的平均值print(results.mean())# 0.9649122807017545 3. 基于投票法的集成学习这里将多个分类模型集合起来，对他们的分类结果采取投票法，最终得到结果。这里使用 sklearn.ensemble.VotingClassifier 来实现。 文档： 123class sklearn.ensemble.VotingClassifier(estimators, voting=’hard’, weights=None, n_jobs=1, flatten_transform=None)Soft Voting/Majority Rule classifier for unfitted estimators. VotingClassifier 有如下几个参数： estimators ： 模型 voting ： {‘hard’, ‘soft’} 二选一，hard就是单纯使用标签投票，soft则是预测可能性最大的标签。默认hard weights ： 每个方法预先的权值，默认各方法权值相同 n_jobs ： 工作 CPU 数量 flatten_transform ： 平滑变形，配合voting参数为soft时使用。如果voting =’soft’且flatten_transform = True，变换方法返回具有形状的矩阵（n_samples，n_classifiers * n_classes），则仅影响变换输出的形状。 如果flatten_transform = False，它将返回（n_classifiers，n_samples，n_classes）。 代码： 123456789101112131415161718192021from sklearn.linear_model import LogisticRegressionfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.svm import SVCfrom sklearn.ensemble import VotingClassifierkfold = model_selection.KFold(n_splits=10, random_state=seed)# 模型集合estimators = []model1 = LogisticRegression()estimators.append((&apos;logistic&apos;, model1))model2 = DecisionTreeClassifier()estimators.append((&apos;cart&apos;, model2))model3 = SVC()estimators.append((&apos;svm&apos;, model3))# Voting 作为结合策略的集成学习ensemble = VotingClassifier(estimators)results = model_selection.cross_val_score(ensemble, X, Y, cv=kfold)print(results.mean())# 0.950814536340852 注： [1]. Imputer : sklearn 里面用于处理缺失值。 [2]. MinMaxScaler : sklearn 里面用于处理数据归一化。 [3]. fit_transform THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/tags/ML/"}]},{"title":"KNN 实践","slug":"2018-09-14_KNN_pratice","date":"2018-09-13T16:00:00.000Z","updated":"2018-09-16T11:03:51.000Z","comments":true,"path":"2018/09/14/2018-09-14_KNN_pratice/","link":"","permalink":"http://ai.wisim.me/2018/09/14/2018-09-14_KNN_pratice/","excerpt":"先简单回顾一下 KNN 的原理：用距离目标最近的 k 个样本数据的分类来代表目标的分类。","text":"先简单回顾一下 KNN 的原理：用距离目标最近的 k 个样本数据的分类来代表目标的分类。 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"KNN","slug":"KNN","permalink":"http://ai.wisim.me/tags/KNN/"}]},{"title":"Numpy.tile() 函数的作用","slug":"2018-09-14_Numpy_tile","date":"2018-09-13T16:00:00.000Z","updated":"2018-09-17T07:58:04.000Z","comments":true,"path":"2018/09/14/2018-09-14_Numpy_tile/","link":"","permalink":"http://ai.wisim.me/2018/09/14/2018-09-14_Numpy_tile/","excerpt":"一、文档1234567891011121314numpy.tile(A, reps): Construct an array by repeating A the number of times given by reps. If reps has length d, the result will have dimension of max(d, A.ndim). If A.ndim &lt; d, A is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote A to d-dimensions manually before calling this function. If A.ndim &gt; d, reps is promoted to A.ndim by pre-pending 1’s to it. Thus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as (1, 1, 2, 2). Note : Although tile may be used for broadcasting, it is strongly recommended to use numpy’s broadcasting operations and functions.","text":"一、文档1234567891011121314numpy.tile(A, reps): Construct an array by repeating A the number of times given by reps. If reps has length d, the result will have dimension of max(d, A.ndim). If A.ndim &lt; d, A is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote A to d-dimensions manually before calling this function. If A.ndim &gt; d, reps is promoted to A.ndim by pre-pending 1’s to it. Thus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as (1, 1, 2, 2). Note : Although tile may be used for broadcasting, it is strongly recommended to use numpy’s broadcasting operations and functions. 二、说明tile 函数有两个参数 A 和 reps。 tile这个函数是用来构造一个数组，内容按规则 reps (元组) 来重复参数 A (数组)。 如果 reps 的长度是 d，那么生成结果的维度是 max(d,A.ndim)。A.ndim 表示参数 A 数组的维度。 如果 A.ndim &lt; d，那就在 A 的前面加上新的维度使其达到 d 维。 如果 A.ndim &gt; d，reps 就\b要在现有元素\b前面插入1，使它的长度达到 A.ndim。再对 A 进行重复。 注意！！！这里的执行顺序很重要：元组 reps 数字从左到右，数组 A 维度从最低（外层）维度到最高（内层）维度。见下面例子分析。 三、例子例子 1输入： 123import numpy as npa = np.array([0, 1, 2])np.tile(a, 2) 输出： 1array([0, 1, 2, 0, 1, 2]) 分析： 这里的参数 A 就是 [0, 1, 2]，维度是 1。参数 reps 是 2，它的长度是1。A.ndim = d，不用改变维度，直接重复 A 两次得到[0, 1, 2, 0, 1, 2]。 例子 2输入： 12a = np.array([0, 1, 2])np.tile(a, (2, 2)) 输出： 12array([[0, 1, 2, 0, 1, 2], [0, 1, 2, 0, 1, 2]]) 分析： 参数 A 还是 [0,1,2]，维度是 1。参数 reps 是 (2, 2)，它的长度是 2。A.ndim &lt; d， max(d,A.ndim)=2，就表示构造的结果要升维变成 2 维了。那么具体是怎么重复A呢？首先第1个维度（最低维度）重复 A 两次（reps的第一个2），同时升为2维，变为 [[0,1,2,0,1,2]]；然后再将这个结果在第 2 个维度（高维度）重复两次（reps的第二个2）变为 [[0,1,2,0,1,2],[0,1,2,0,1,2]]。 例子 3输入： 12a = np.array([0, 1, 2])np.tile(a, (2, 1, 2)) 输出： 12array([[[0, 1, 2, 0, 1, 2]], [[0, 1, 2, 0, 1, 2]]]) 分析： 参数 A 还是 [0,1,2]，维度是 1。参数 reps 是（2，1，2）它的长度是3。A.ndim &lt; d，max(d,A.ndim)=3，所以构造的结果需要升维到 3。首先在第1维度（最低维度）重复2次且升维得[[[0,1,2,0,1,2]]]；再在第2维度重复1次，也就是它本身得[[[0,1,2,0,1,2]]]；最后在第3维度（最高）重复2次得[[[0,1,2,0,1,2]],[[0,1,2,0,1,2]]]。 例子 4输入： 12b = np.array([[1, 2], [3, 4]])np.tile(b, 2) 输出： 12array([[1, 2, 1, 2], [3, 4, 3, 4]]) 分析： 参数 A 是 [[1,2], [3,4]]，维度是 2。参数 reps 是 2，长度是1。A.ndim &gt; d，max(d,A.ndim)=2，所以在 reps 前面插入 1 得 (1,2)，再对 A 重复。首先第1维（最低维度）重复1次得 [[1, 2], [3, 4]] ，再在高维度重复2次得 [[1,2,1,2],[3,4,3,4]] 。 例子 5输入： 12b = np.array([[1, 2], [3, 4]])np.tile(b, (2, 1)) 输出： 1234array([[1, 2], [3, 4], [1, 2], [3, 4]]) 分析： 参数 A 是 [[1, 2], [3, 4]]，维度是 2。参数 reps 是(2, 1)，长度是2。A.ndim = d，不用升维。首先低维度重复2次得 [[1, 2], [3, 4],[1, 2], [3, 4]]，再在高维度重复1次得 [[1, 2], [3, 4],[1, 2], [3, 4]] 例子 6输入： 12c = np.array([1,2,3,4])np.tile(c,(4,1)) 输出： 1234array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]) 分析： 参数 A 是 [1,2,3,4]，维度是 1。参数 reps 是 (4,1)，长度是 2。A.ndim &lt; d，max(d,A.ndim)=2，结果需要升维到2。首先在低维度重复4次得 [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]，再在高维度重复1次得 [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]。 THE END.","categories":[{"name":"Numpy","slug":"Numpy","permalink":"http://ai.wisim.me/categories/Numpy/"}],"tags":[{"name":"Numpy","slug":"Numpy","permalink":"http://ai.wisim.me/tags/Numpy/"},{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/tags/ML/"}]},{"title":"高斯混合模型和EM算法","slug":"2018-09-12-GMM_EM","date":"2018-09-11T16:00:00.000Z","updated":"2018-09-13T12:27:22.000Z","comments":true,"path":"2018/09/12/2018-09-12-GMM_EM/","link":"","permalink":"http://ai.wisim.me/2018/09/12/2018-09-12-GMM_EM/","excerpt":"一、混合模型（Mixture Model）混合模型是一个可以用来表示在总体分布（distribution）中含有 K 个子分布的概率模型。换句话说，混合模型表示了观测数据在总体中的概率分布，它是一个由 K 个子分布组成的混合分布。混合模型不要求观测数据提供关于子分布的信息，来计算观测数据在总体分布中的概率。","text":"一、混合模型（Mixture Model）混合模型是一个可以用来表示在总体分布（distribution）中含有 K 个子分布的概率模型。换句话说，混合模型表示了观测数据在总体中的概率分布，它是一个由 K 个子分布组成的混合分布。混合模型不要求观测数据提供关于子分布的信息，来计算观测数据在总体分布中的概率。 二、高斯混合模型（Gaussian Mixture Model,GMM）1. 单高斯模型 当样本数据 X 是一维数据（Univariate）时，高斯分布(也叫正态分布)遵从下方概率密度函数（Probability Density Function）： P(x|\\theta)=\\frac{1}{2\\pi\\sigma^2}exp(-\\frac{(x-\\mu)^2}{2\\sigma^2})正态分布通常也记为 $N(x|\\theta)$，其中 $\\mu$ 为数据均值（期望）， $\\sigma$ 为数据标准差（Standard deviation）`。 当样本数据 X 是多维数据（Multivariate）时，高斯分布遵从下方概率密度函数： P(x|\\theta)=\\frac{1}{(2\\pi)^{D/2}|\\Sigma|^{1/2}}exp(-\\frac{(x-\\mu)^T \\Sigma^{-1}(x-\\mu)}{2})其中， $\\mu$ 为数据均值（期望）， $\\Sigma$ 为协方差（Covariance），D 为数据维度。注意这里的 T 是矩阵转置符号，多维数据 $x-\\mu$ 是一个矩阵。 2. 高斯混合模型高斯混合模型可以看作是由 K 个单高斯模型组合而成的模型，每个 Gaussian 称为一个“Component”，这 K 个子模型是混合模型的隐变量（Hidden variable）。也就是说我们假设样本中的每个数据都由这 K 个子模型中的某一个生成。一般来说，一个混合模型可以使用任何概率分布，这里使用高斯混合模型是因为高斯分布具备很好的数学性质以及良好的计算性能。下面给出高斯混合模型的数学定义： 首先定义如下信息： $x_j$ 表示第 j 个观测数据， j = 1,2,…,N K 是混合模型中子高斯模型的数量， k = 1,2,…,K $\\alpha_k$ 是观测数据属于第 i 个子模型的概率， $\\alpha_k \\geq 0 ， \\sum_{i=1}^{K}{\\alpha_k} = 1$ $\\phi(x|\\theta_k)$ 是第 k 个子模型的高斯分布密度函数， $\\theta_k = (\\mu_k, \\sigma_k^{2})$ 。其展开形式与上面介绍的单高斯模型相同 $\\gamma_{ji}$ 表示第 j 个观测数据属于第 i 个子模型的概率。 那么，高斯混合模型的概率分布为： \\begin{array}{ll} P(x|\\theta) & =\\sum_{k=1}^{K} \\alpha_k \\phi(x|\\theta_k)\\\\ & =\\sum_{k=1}^{K} \\alpha_k \\frac{1}{(2\\pi)^{D/2}|\\Sigma|_k^{1/2}}exp(-\\frac{(x-\\mu_k)^T \\Sigma_k^{-1}(x-\\mu_k)}{2})\\\\ \\end{array}对于这个高斯混合模型而言，参数 $\\theta = (\\tilde{\\mu_k}, \\tilde{\\sigma_k}, \\tilde{\\alpha_k})$ ，也就是每个子模型的期望、方差（或协方差）、在混合模型中发生的概率。 根据上面的式子，如果我们要从 GMM 的分布中随机地取一个点的话，实际上可以分为两步：首先随机地在这 K 个 Component 之中选一个，每个 Component 被选中的概率实际上就是它的系数 $\\alpha_k$ ，选中了 Component 之后，再单独地考虑从这个 Component 的分布中选取一个点就可以了──这里已经回到了普通的 Gaussian 分布，转化为了已知的问题。 那么如何用 GMM 来做聚类呢？其实很简单，现在我们有了数据，假定它们是由 GMM 生成出来的，那么我们只要根据数据推出 GMM 的概率分布来就可以了，然后 GMM 的 K 个 Component 实际上就对应了 K 个 cluster 了。根据数据来推算概率密度通常被称作密度估计(density estimation) ，特别地，当我们在已知（或假定）了概率密度函数的形式，而要估计其中的参数的过程被称作“参数估计”。 GMM与K-means比较 相同点：都是可用于聚类的算法；都需要指定K值。 不同点：GMM可以给出一个样本属于某类的概率是多少。 三、极大似然估计上面只是给出了 GMM 的概率密度，但是它的参数还是未知的，那么如何该如何求\b概率密度的参数呢？ 先来聊聊似然函数。现在假设我们有 N 个数据点，并假设它们服从某个分布（记作 p(x) ），要确定里面的一些参数的值。现在\b这里的分布就是高斯混合分布，我们就需要确定 $\\alpha_k、\\mu_k 和 \\Sigma_k$ 这些参数。 我们的想法是，找到这样一组参数，它所确定的概率分布生成这些给定的数据点的概率最大，而这个概率实际上就等于 $\\prod_{i=1}^N p(x_i)$ ，我们把这个乘积称作似然函数 (Likelihood Function)。 通常单个点的概率都很小，许多很小的数字相乘起来在计算机里很容易造成浮点数下溢，因此我们通常会对其取对数，把乘积变成加和 $\\sum_{i=1}^N \\log p(x_i)$，得到对数似然函数（log-likelihood function） 。接下来我们只要将这个函数最大化（通常的做法是求导并令导数等于零，然后解方程），亦即找到这样一组参数值，它让似然函数取得最大值，我们就认为这是最合适的参数，这样就完成了参数估计的过程。下面让我们来看一看 GMM 的对数似然函数的具体形式 ： l(\\Theta)=log\\prod_{i=1}^{n}p(x_{i};\\Theta)=\\sum_{i=1}^{n}log(\\sum_{k=1}^{K}\\alpha_{k}N(x_{i};\\mu_{k},\\Sigma_{k})) \\tag{3.1}由于在对数函数里面又有加和，我们没法直接用求导解方程的办法直接求得最大值。为了解决这个问题，我们要用到 EM算法。 四、EM算法EM算法全程是 Expectation Maximization，即期望最大化算法，专门用来迭代求解极大似然估计。我们就是要找到最佳的模型参数，使得3.1式的期望最大，“期望最大化算法”名字由此而来。 EM算法每次迭代包含两个步骤： E-step：求期望 $E(\\gamma_{jk} | X, \\theta)$ for all j = 1,2,…,N; M-step：求极大，计算新一轮迭代的模型参数。 这里不具体介绍一般性的 EM 算法（通过 Jensen 不等式得出似然函数的下界 Lower bound，通过极大化下界做到极大化似然函数），只介绍怎么在高斯混合模型里应用从来推算出模型参数。通过 EM 迭代更新高斯混合模型参数的方法如下： 假设：我们有样本数据 $x_{1}, x_{2}, …,x_{N}$ 和一个有 K 个子模型的高斯混合模型，想要推算出这个高斯混合模型的最佳参数。 1. 首先初始化参数2. E-step\b：依据当前参数，计算每个数据 j 来自子模型 k 的可能性估计数据由每个 Component 生成的概率（并不是每个 Component 被选中的概率）：对于每个数据 $x_i$ 来说，它由第 k 个 Component 生成的概率为： \\gamma_{jk} = \\frac{\\alpha_{k}\\phi(x_{j}|\\theta_{k})}{\\sum_{k=1}^{K}{\\alpha_{k}\\phi(x_{j}|\\theta_{k})}}, j = 1,2,...,N; k = 1,2,...,K3. M-step：计算新一轮迭代的模型参数估计每个 Component 的参数：现在我们假设上一步中得到的 $\\gamma(i, k)$ 就是正确的“数据 $x_i$ 由 Component k 生成的概率”，亦可以当做该 Component 在生成这个数据上所做的贡献。或者说，我们可以看作 $x_i$ 这个值其中有 $\\gamma(i, k)x_i$ 这部分是由 Component k 所生成的。集中考虑所有的数据点，现在实际上可以看作 Component 生成了 $\\gamma(1, k)x_1, \\ldots, \\gamma(N, k)x_N$ 这些点。由于每个 Component 都是一个标准的 Gaussian 分布，可以很容易分布求出最大似然所对应的参数值： \\mu_{k} = \\frac{\\sum_{j}^{N}{(\\gamma_{jk}}x_{j})}{\\sum_{j}^{N}{\\gamma_{jk}}}, k=1,2,...,K\\Sigma_{k} = \\frac{\\sum_{j}^{N}{\\gamma_{jk}}(x_{j}-\\mu_{k})(x_{j}-\\mu_{k})^{T}}{\\sum_{j}^{N}{\\gamma_{jk}}}, k = 1,2,...,K,用这一轮更新后的 \\mu_{k}\\alpha_{k} = \\frac{\\sum_{j=1}^{N}{\\gamma_{jk}}}{N}, k=1,2,...,K4. 重复计算 E-step 和 M-step 直至收敛也就是要求 $||\\theta_{i+1} - \\theta_{i}|| &lt; \\varepsilon$, $\\varepsilon$ 是一个很小的正数，表示经过一次迭代之后参数变化非常小。否则重复2，3两步。 至此，我们就找到了高斯混合模型的参数。需要注意的是，EM 算法具备收敛性，但并不保证找到全局最大值，有可能找到局部最大值。解决方法是初始化几次不同的参数进行迭代，取结果最好的那次。 参考： [0]. 高斯混合模型 [1]. 高斯混合模型（GMM） [2]. 漫谈 Clustering (3): Gaussian Mixture Model [3]. EM及高斯混合模型 [4]. 如何通俗理解EM算法 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"GMM","slug":"GMM","permalink":"http://ai.wisim.me/tags/GMM/"}]},{"title":"Bagging 和 随机森林（Random Forest,RF）","slug":"2018-09-10_Bagging_RandomForest","date":"2018-09-09T16:00:00.000Z","updated":"2018-09-18T03:25:00.000Z","comments":true,"path":"2018/09/10/2018-09-10_Bagging_RandomForest/","link":"","permalink":"http://ai.wisim.me/2018/09/10/2018-09-10_Bagging_RandomForest/","excerpt":"前面已经了解到集成学习有两个流派，一个是 Boosting 派系，它的特点是各个弱学习器之间有依赖关系。另一种是 Bagging 流派，它的特点是各个弱学习器之间没有依赖关系，可以并行拟合。而随机森林又是对 Bagging 的一个改进算法，可以很方便的并行训练。","text":"前面已经了解到集成学习有两个流派，一个是 Boosting 派系，它的特点是各个弱学习器之间有依赖关系。另一种是 Bagging 流派，它的特点是各个弱学习器之间没有依赖关系，可以并行拟合。而随机森林又是对 Bagging 的一个改进算法，可以很方便的并行训练。 一、Bagging1. Bagging 算法原理Bagging 原理图： Bagging 的弱学习器之间的确没有 Boosting 那样的联系。它的特点在“随机采样”。那么什么是随机采样？ 随机采样(bootsrap)就是从我们的训练集里面采集固定个数的样本，但是每采集一个样本后，都将样本放回。也就是说，之前采集到的样本在放回后有可能继续被采集到。对于我们的Bagging算法，一般会随机采集和训练集样本数m一样个数的样本。这样得到的采样集和训练集样本的个数相同，但是样本内容不同。如果我们对有m个样本训练集做T次的随机采样，则由于随机性，T个采样集各不相同。注意到这和 GBDT 的子采样是不同的。GBDT 的子采样是无放回采样，而 Bagging的子采样是放回采样。 对于一个样本，它在某一次含m个样本的训练集的随机采样中，每次被采集到的概率是 $\\frac{1}{m}$，不被采集到的概率为 $1-\\frac{1}{m}$。如果 m 次采样都没有被采集中的概率是 $(1-\\frac{1}{m})^{m}$，当 $m \\to \\infty,(1-\\frac{1}{m})^m \\to \\frac{1}{e} \\simeq 0.368$。也就是说，在 BaggingB的每轮随机采样中，训练集中大约有36.8%的数据没有被采样集采集中。 对于这部分大约36.8%的没有被采样到的数据，我们常常称之为袋外数据(Out Of Bag, 简称OOB)。这些数据没有参与训练集模型的拟合，因此可以用来检测模型的泛化能力。 Bagging 对于弱学习器没有限制，这和Adaboost一样。但是最常用的一般也是决策树和神经网络。 Bagging 的结合策略也比较简单，对于分类问题，通常使用简单投票法，得到最多票数的类别或者类别之一为最终的模型输出。对于回归问题，通常使用简单平均法，对T个弱学习器得到的回归结果进行算术平均得到最终的模型输出。 由于 Bagging算法每次都进行采样来训练模型，因此泛化能力很强，对于降低模型的方差很有作用。当然对于训练集的拟合程度就会差一些，也就是模型的偏差会大一些。 2. Bagging 算法流程 输入为样本集 $D=\\{(x_,y_1),(x_2,y_2), …(x_m,y_m)\\}$。 弱学习器算法。弱分类器迭代次数T。 输出为最终的强分类器f(x) (1) 对于 i=1,2…,m: (a) 对训练集进行第 i 次随机采样，共采集 m 次，得到包含 m 个样本的采样集 D; (b) 用采样集 D 训练第 i 个弱学习器 $G_i(x)$. (2) 如果是分类算法预测，则 m 个弱学习器投出最多票数的类别或者类别之一为最终类别。如果是回归算法，m 个弱学习器得到的回归结果进行算术平均得到的值为最终的模型输出。 二、随机森林理解了 Bagging 算法，随机森林(Random Forest,以下简称RF)就好理解了。它是 Bagging 算法的进化版，也就是说，它的思想仍然是 Bagging,但是进行了独有的改进。我们现在就来看看RF算法改进了什么。 首先，RF使用了CART 决策树作为弱学习器。第二，在使用决策树的基础上，RF对决策树的建立做了改进，对于普通的决策树，我们会在节点上所有的n个样本特征中选择一个最优的特征来做决策树的左右子树划分，但是RF通过随机选择节点上的一部分样本特征，这个数字小于n，假设为 $n_1$，然后在这些随机选择的 $n_1$ 个样本特征中，选择一个最优的特征来做决策树的左右子树划分。这样进一步增强了模型的泛化能力。 如果 $n_1=n$，则此时RF的CART决策树和普通的CART决策树没有区别。$n_1$ 越小，则模型约健壮，当然此时对于训练集的拟合程度会变差。也就是说$n_1$ 越小，模型的方差会减小，但是偏差会增大。在实际案例中，一般会通过交叉验证调参获取一个合适的 $n_1$ 的值。 除了上面两点，RF和普通的 Bagging 算法没有什么不同， 下面简单总结下RF的算法。 输入为样本集 $D=\\{(x_,y_1),(x_2,y_2), …(x_m,y_m)\\}$。 弱分类器迭代次数T。 输出为最终的强分类器f(x)。 (1) 对于 i=1,2…,m: (a)对训练集进行第 i 次随机采样，共采集 m 次，得到包含 m 个样本的采样集 D; (b)用采样集 D 训练第 i 个决策树模型 $G_i(x)$ ，在训练决策树模型的节点的时候，在节点上所有的样本特征中选择一部分样本特征， 在这些随机选择的部分样本特征中选择一个最优的特征来做决策树的左右子树划分 (2) 如果是分类算法预测，则 m 个弱学习器投出最多票数的类别或者类别之一为最终类别。如果是回归算法，m 个弱学习器得到的回归结果进行算术平均得到的值为最终的模型输出。 三、结合策略我们可以看到不管是 Boosting 还是 Bagging，最终弱学习器都要通过结合策略结合成强学习器，结合策略有如下几个： 1. 平均法对于数值类的回归预测问题，通常使用的结合策略是平均法，也就是说，对于若干个弱学习器的输出进行平均得到最终的预测输出。 最简单的平均是算术平均，也就是说最终预测是：$H(x) = \\frac{1}{T}\\sum\\limits_{1}^{T}h_i(x)$ 如果每个个体学习器有一个权重w，则最终预测是：$H(x) = \\sum\\limits_{i=1}^{T}w_ih_i(x)$，其中 $wi$ 是个体学习器 $hi$ 的权重，通常有 $w_i \\geq 0 ,\\;\\;\\; \\sum\\limits_{i=1}^{T}w_i = 1$ 2. 投票法对于分类问题的预测，我们通常使用的是投票法。假设我们的预测类别是 $\\{c_1,c_2,…c_K\\}$,对于任意一个预测样本x，我们的T个弱学习器的预测结果分别是 $(h_1(x), h_2(x)…h_T(x))$。 最简单的投票法是相对多数投票法，也就是我们常说的少数服从多数，也就是T个弱学习器的对样本x的预测结果中，数量最多的类别ci为最终的分类类别。如果不止一个类别获得最高票，则随机选择一个做最终类别。 稍微复杂的投票法是绝对多数投票法，也就是我们常说的要票过半数。在相对多数投票法的基础上，不光要求获得最高票，还要求票过半数。否则会拒绝预测。 更加复杂的是加权投票法，和加权平均法一样，每个弱学习器的分类票数要乘以一个权重，最终将各个类别的加权票数求和，最大的值对应的类别为最终类别。 3. 学习法上面两个方法都是对弱学习器的结果做平均或者投票，相对比较简单，但是可能学习误差较大，于是就有了学习法这种方法，对于学习法，代表方法是stacking，当使用stacking的结合策略时， 我们不是对弱学习器的结果做简单的逻辑处理，而是再加上一层学习器，也就是说，我们将训练集弱学习器的学习结果作为输入，将训练集的输出作为输出，重新训练一个学习器来得到最终结果。 在这种情况下，我们将弱学习器称为初级学习器，将用于结合的学习器称为次级学习器。对于测试集，我们首先用初级学习器预测一次，得到次级学习器的输入样本，再用次级学习器预测一次，得到最终的预测结果。 四、随机森林的推广由于RF在实际应用中的良好特性，基于RF，有很多变种算法，应用也很广泛，不光可以用于分类回归，还可以用于特征转换，异常点检测等。下面对于这些RF家族的算法中有代表性的做一个总结。 1. extra treesextra trees是RF的一个变种, 原理几乎和RF一模一样，仅有区别有： (1) 对于每个决策树的训练集，RF 采用的是随机采样 bootstrap 来选择采样集作为每个决策树的训练集，而 extra trees 一般不采用随机采样，即每个决策树采用原始训练集。 (2) 在选定了划分特征后，RF的决策树会基于基尼系数，均方差之类的原则，选择一个最优的特征值划分点，这和传统的决策树相同。但是extra trees比较的激进，他会随机的选择一个特征值来划分决策树。 从第二点可以看出，由于随机选择了特征值的划分点位，而不是最优点位，这样会导致生成的决策树的规模一般会大于RF所生成的决策树。也就是说，模型的方差相对于RF进一步减少，但是偏差相对于RF进一步增大。在某些时候，extra trees的泛化能力比RF更好。 2. Totally Random Trees EmbeddingTotally Random Trees Embedding(以下简称 TRTE)是一种非监督学习的数据转化方法。它将低维的数据集映射到高维，从而让映射到高维的数据更好的运用于分类回归模型。我们知道，在支持向量机中运用了核方法来将低维的数据集映射到高维，此处TRTE提供了另外一种方法。 TRTE在数据转化的过程也使用了类似于RF的方法，建立T个决策树来拟合数据。当决策树建立完毕以后，数据集里的每个数据在T个决策树中叶子节点的位置也定下来了。比如我们有3颗决策树，每个决策树有5个叶子节点，某个数据特征x划分到第一个决策树的第2个叶子节点，第二个决策树的第3个叶子节点，第三个决策树的第5个叶子节点。则x映射后的特征编码为(0,1,0,0,0, 0,0,1,0,0, 0,0,0,0,1), 有15维的高维特征。这里特征维度之间加上空格是为了强调三颗决策树各自的子编码。 映射到高维特征后，可以继续使用监督学习的各种分类回归算法了。 3. Isolation Forest Isolation Forest（以下简称IForest）是一种异常点检测的方法。它也使用了类似于RF的方法来检测异常点。 对于在 T 个决策树的样本集，IForest 也会对训练集进行随机采样,但是采样个数不需要和RF一样，对于RF，需要采样到采样集样本个数等于训练集个数。但是IForest不需要采样这么多，一般来说，采样个数要远远小于训练集个数。为什么呢？因为我们的目的是异常点检测，只需要部分的样本我们一般就可以将异常点区别出来了。 对于每一个决策树的建立， IForest采用随机选择一个划分特征，对划分特征随机选择一个划分阈值。这点也和RF不同。 另外，IForest一般会选择一个比较小的最大决策树深度 max_depth,原因同样本采集，用少量的异常点检测一般不需要这么大规模的决策树。 对于异常点的判断，则是将测试样本点 x 拟合到 T 颗决策树。计算在每颗决策树上该样本的叶子节点的深度 $h_t(x)$。，从而可以计算出平均高度h(x)。此时我们用下面的公式计算样本点x的异常概率: s(x,m) = 2^{-\\frac{h(x)}{c(m)}}其中，m为样本个数。c(m)的表达式为： c(m) =2\\ln(m-1) + \\xi - 2\\frac{m-1}{m}, \\; \\xi为欧拉常数s(x,m)的取值范围是[0,1],取值越接近于1，则是异常点的概率也越大。 五、小结RF算法作为一个可以高度并行化的算法，在大数据时候大有可为。下面总结一下 RF 的优缺点。 RF的主要优点有： 训练可以高度并行化，对于大数据时代的大样本训练速度有优势。个人觉得这是的最主要的优点。 由于可以随机选择决策树节点划分特征，这样在样本特征维度很高的时候，仍然能高效的训练模型。 在训练后，可以给出各个特征对于输出的重要性 由于采用了随机采样，训练出的模型的方差小，泛化能力强。 相对于Boosting系列的Adaboost和GBDT， RF实现比较简单。 对部分特征缺失不敏感。 RF的主要缺点有： 在某些噪音比较大的样本集上，RF模型容易陷入过拟合。 取值划分比较多的特征容易对RF的决策产生更大的影响，从而影响拟合的模型的效果。 参考： [1]. Bagging与随机森林算法原理小结 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"Bagging","slug":"Bagging","permalink":"http://ai.wisim.me/tags/Bagging/"},{"name":"RF","slug":"RF","permalink":"http://ai.wisim.me/tags/RF/"}]},{"title":"AdaBoost 简介【译】","slug":"2018-09-07-Boosting","date":"2018-09-06T16:00:00.000Z","updated":"2018-09-10T13:21:18.000Z","comments":true,"path":"2018/09/07/2018-09-07-Boosting/","link":"","permalink":"http://ai.wisim.me/2018/09/07/2018-09-07-Boosting/","excerpt":"原文：AdaBoost 简介 目前的集成学习（Ensemble Learning）方法大致可分为两类：一是个体学习器之间存在强依赖关系、必须串行生成的序列化方法，代表算法是Boosting；二是个体学习器之间不存在强依赖关系，可同时生成的并行方法，代表算法是 Bagging 和 “随机森林（Random Forest）”。 首先要知道 AdaBoost(adaptive boosting) 算法是Boosting算法族中的一员。Boosting算法可将弱学习器提升为强学习器。所谓的弱学习器就是泛化性能略高于随机猜测的学习器，而强学习器很显然就是指泛化能力较高的学习器了。Boosting算法原理图： AdaBoost算法中有一个很重要的环节。每一个训练样本都被赋予权值，并且随着训练过程样本权值不断更新。更新的原则是：误分类样本被赋予更高的权值，而正确分类样本的权值被相应降低。通过这种方式能够将重点放在不能正确分类的样本上，新选出来的分类器能够发挥原有分类器没有的作用，提高整体的分类效果。","text":"原文：AdaBoost 简介 目前的集成学习（Ensemble Learning）方法大致可分为两类：一是个体学习器之间存在强依赖关系、必须串行生成的序列化方法，代表算法是Boosting；二是个体学习器之间不存在强依赖关系，可同时生成的并行方法，代表算法是 Bagging 和 “随机森林（Random Forest）”。 首先要知道 AdaBoost(adaptive boosting) 算法是Boosting算法族中的一员。Boosting算法可将弱学习器提升为强学习器。所谓的弱学习器就是泛化性能略高于随机猜测的学习器，而强学习器很显然就是指泛化能力较高的学习器了。Boosting算法原理图： AdaBoost算法中有一个很重要的环节。每一个训练样本都被赋予权值，并且随着训练过程样本权值不断更新。更新的原则是：误分类样本被赋予更高的权值，而正确分类样本的权值被相应降低。通过这种方式能够将重点放在不能正确分类的样本上，新选出来的分类器能够发挥原有分类器没有的作用，提高整体的分类效果。 一、算法目标如果你正在处理一个二分类模式识别问题，并且现在提供了一系列分类器，你可以从中选择使用哪些分类器（我们这里称之为小能手）。现在你想从中选出最优的几个小能手参加“超级碗”比赛。因此，你要选出一个十一人梦之队。假设给定的数据 $x_i$ 和每个分类器（小能手） $k_j$ 可以发表一个观点 $k_j(x_i) \\in{\\{-1,1\\}}$，并且根据这些观点最终得出的决定是 sign(C(x_i))，这个 sign函数是所有小能手提出的观点的带权之和： C(x_i)=a_1k_1(x_i)+a_2k_2(x_i)+...+a_11k_11(x_i)这里的 $k_1,k_2,…,k_11$ 表示这十一个小能手代表的时哪一种分类器。然后前面的常数 $a_1,a_2,…,a_11$ 是我们给定的每个小能手的权重。此外，小能手 $K_j$ 只能回答 “yes(+1)” 或者 “no(-1)” 来对问题分类。这里的 sign 函数是一个非线性决策，它是由这一些列线性分类器组合而成。 二、寻找合适的分类器如果你也想参加我们这个分类器比赛，你要做的是：1）找到适合的队员，2）召集他们，3）根据他们的贡献给他们分配权重值。 寻找合适队员的工作是通过使用分类器训练数据集 N 中的一部分 T 来完成，N中得数据就是一个多维数据点 $x_i$。对于每一个 $x_i$ ，它们都有一个相对应的标签 $y_i = 1$ 或者 $y_i=-1$。如果分类器判断错误，我们就给这个分类器减去一个值 $e^{\\beta}$，如果分类器判断正确，我们就给这个分类器减去一个值 $e^{-\\beta}$，这样对所有的分类器\u001d进行测试和\b排序。这里的 $\\beta &gt; 0$，所以会保证判断错误的惩罚值会比判断正确地要高。不过也许你会奇怪，为什么判断正确还要给一个惩罚值，但其实只要判断正确的惩罚值小于判断错误的惩罚值（$e^{-\\beta}&lt;e^{\\beta}$），那就是没有问题的。这类错误函数和常用的欧式距离不同，它是一种指数损失函数。AdaBoost就是使用的指数损失函数作为错误惩罚函数。 在测试这些分类器的时候，\b对于某一个分类器\b L，我们构建一个矩阵 S，S 用1记录判断错误，用0记录判断正确。矩阵的列代表着每个数据点 $x_i$，列代表着第 j 个分类器： 在上面这个例子里，我们可以看到第一个分类器对第1，2和N这三个点得判断正确，对第3个点的判断错误。其他的分类器对数据点的判断结果也显而易见。 AdaBoost算法的主要思想就是通过自动迭代挑选出\b分类器。每次迭代的当前相关性（或者叫\b重要性）决定了数据集中得元素的权重。一开始，所有元素都分配的时相同的权重（1或者1/N，保持权重之和为1）。随着挑选的过程，越难判别的元素就会让它们的权重越高。这个挑选的过程就是选出对这些难判别元素分类效果\b较好地分类器。如果每次挑选的分类器只适用于那些已经可以正确判断的元素，那这个挑选的过程就没有意义了。如果想两次都挑选一个分类器，那直接复制它的权重即可。最好的“队员”就是能为团队提供新视野的人。挑选的分类器一定要最佳互补。“并不是每个人都能做四分卫的”。 三、征集分类器每次迭代我们都要对所有分类器排序，然后选出最佳分类器。假设在第 m 次迭代时，我们已经筛选出了 m-1 个分类器，现在要选择下一个了。当前筛选出的 m-1 个分类器的线性组合如下： C_{m-1}(x_i)=a_1k_1(x_i)+a_2k2_(x_i)+...+a_{m-1}k_{m-1}(x_i) \\tag{3.1}所以扩展到第 m 个分类器时，线性组合表示为： C_m(x_i)=C_{m-1}(x_i)+a_mk_m(x_i) \\tag{3.2}在第一次迭代的时候 m=1,C_{m-1} 是 0 。我们为第 m 个线性组合定义了总的代价或者总的错误作为指数损失为： E=\\sum_{i=1}^m e^{-y_i(C_{(m-1)}(x_i)+a_mk_m(x_i))} \\tag{3.3}这里的 $a_m$ 和 $k_m$ 要通过优化方式得到。既然我们目标是要得到 $k_m$，这里重写一下上面的公式3.3： E=\\sum_{i=1}^mw_i^{(m)}e^{-y_ia_mk_m(x_i)},w_i^{(m)}=e^{-y_iC_{(m-1)(x_i)}} \\tag{3.4}注意这里的上标 m 不是幂，而是第 m 个；下标 m-1 也是代表第 m-1 个。i=1,….,N。 在第一次迭代中， $w_i^{(1)}=1,i=1,…,N$。而后面的迭代中，向量 $w^{(m)}$ 代表着第 m 次迭代分配给数据点的权重。我们可以把上面的公式3.4拆分成两个和： E=\\sum_{y_i=k_m(x_i)}w_i^{(m)}e^{-a_m}+\\sum_{y_i\\neq k_m(x_i)}w_i^{(m)}e^{a_m} \\tag{3.5}公式3.5很重要，它表示总的代价就是判断正确的代价之和加上判断错误的代价之和（之前已经说过判断对错都要给一个代价）。把第一个代价和（判断正确代价和）表示为 $W_ce^{-a_m}$ ，然后第二个代价和（判断错误代价和）表示为 $W_ee^{a_m}$，所以公式3.5就可以表示为如下： E=W_ce^{-a_m}+W_ee^{a_m} \\tag{3.6}由于分类器 $k_m$ 的选择和 $a_m(a_m&gt;0)$ 的具体值没有关系，所以对于一个固定的 $a_m$ 值来说，最小化代价函数 E 就等价于最小化 $e^{a_m}E$，同时因为公式3.6左右两边同时乘以 $e^{a_m}$ 得。 e^{a_m}E=W_c+W_ee^{2a_m} \\tag{3.7}又因为 $e^{2a_m}&gt;1$，所以公式3.7又可以变为： e^{a_m}E=(W_c+W_e)+W_e(e^{2a_m}-1) \\tag{3.8} 这里的($W_c+W_e$) 就是总的代价 $W$，对于当前迭代来说它可以看做一个常量，它就是所有数据点的权重和。在第 m 个迭代时，如果我们选择了一个分类器使得错误判断的代价 $W_e$ 达到最小，那么等式3.7的右侧也就是当前迭代里的最小值了。正因为有了最小的代价，所以很显然这就保证我们选出的下一个分类器 $k_m$ 带有最小的惩罚值。 四、加权之前的挑选分类器的时候都是直接假定权重值 $a_m$ 是一个常数，现在把它看做一个未知数，我们要来确定它的具体的值了。看公式3.6直接对 $a_m$ 求导得： \\frac{dE}{da_m}=-W_ce^{-a_m}+W_ee^{a_m} \\tag{4.1}直接令公式3.9等于0，再乘以 $e^{a_m}$ 可以得到： -W_c+W_ee^{2a_m}=0 \\tag{4.2}可以得到最优的 $a_m$ 就是： a_m=\\frac{1}{2}ln(\\frac{W_c}{W_e}) \\tag{4.3}而 $W$ 又是所有数据点权重之和，可以重写公式4.3得： a_m=\\frac{1}{2}ln(\\frac{W-We}{W_e})=\\frac{1}{2}ln(\\frac{1-e_m}{e_m}) \\tag{4.4}这里的 $e_m=W_e/W$，就是给定权重下，数据集的分类错误率。 五、伪代码假设有一个数据集 T 里面的数据点为 $x_i$，这些数据点的标签 $y_i$ 是(+1,-1) 中的一个，假设所有数据点的权重初始值 $w_i^{(1)}=1$。我们想要从一系列分类器中选出 M 个分类器。执行 M 次迭代。每次迭代时，所有数据点的权重之和为 $W$，所有分类错误的数据点的权重和为 $W_e$。 AadBoost算法伪代码： For m=1 to M1.从一系列分类器中选出一个分类器错误分类权重和最小，也就是满足如下情况： W_e=\\sum_{y_i \\neq k_m(x_i)}w_i^{(m)}2.将分类器的权重值 $a_m$ 设置为： a_m=\\frac{1}{2}ln(\\frac{1-e_m}{e_m})这里的 $e_m=W_e/W$ 3.为下一次迭代更新所有分类器的权重值。如果 $k_m(x_i)$ 分类错误，则设置： w_i^{(m+1)}=w_i^{(m)}e^{a_m}=w_i^{(m)} \\sqrt{\\frac{1-e_m}{e_m}}否则设置： w_i^{(m+1)}=w_i^{(m)}e^{-a_m}=w_i^{(m)} \\sqrt{\\frac{e_m}{1-e_m}}以上就是 AdaBoost的伪代码。 第一步里面的那一系列分类器可以是一个分类器族，这里面有一个分类器可使当前权重情况下的损失函数达到最小值。分类器池不必提前给出，只要是这个分类器存在的即可。如果已经给出了有限个分类器，我们只要每次测试一个即可。而这个搜索矩阵 S 可以在每次迭代的时候重复使用，只要乘以权重值 $w^{(m)}$ 所对应矩阵的转置即可，这是为了每次都能得出误分类权重 $W_e$。 至于这些权重值，其实是表示了权重的变化步骤，因此只有误分类才会导致权重的变化。 值得注意的是权重向量 $w^{(m)}$ 是迭代构造的。每次迭代可能都会导致它全部重新计算，但是还算高效也简单易实现。 另外，那些弱分类器的权重值会是0。如果有一个完美的分类器（$e_m=W_e/W=0$），那它的权重是无穷大，并且我们就只需要这一个分类器就好了。而一个劣质的分类器（$e_m=W_e/W=1$）的权重很显然是负无穷大，其实这样也好，我们可以每次直接对它的分类结果取反，同样我们也只需要这一个分类器即可。 六、问题 假设我们为误分类分配了一个代价值 a，为正确分类分配了一个代价值 b，且 a&gt;b&gt;0，我们可以将这个代价值变形为 $a=c^d,b=c^{-d}$。这样指数损失函数 $e^{a_m},e^{-a_m}$也不影响它的通用性了。 参考:[1] Y. Freund, and R. Shapire, “A decision-theoretic generalization of on-linelearning and an application to boosting”, Proceedings of the Second EuropeanConference on Computational Learning Theory, 1995, pp. 23–37. [2] Paul A. Viola, Michael J. Jones, “Robust Real-Time Face Detection”, ICCV2001, Vol. 2, pp. 747. [3] T. Hastie, R. Tibshirani, J. Friedman, The Elements of Statistical Learning,Springer-Verlag, New York, 2001. THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"Boosting","slug":"Boosting","permalink":"http://ai.wisim.me/tags/Boosting/"},{"name":"AdaBoost","slug":"AdaBoost","permalink":"http://ai.wisim.me/tags/AdaBoost/"}]},{"title":"模型评估与选择","slug":"2018-09-06_Model_Evaluation_Selection","date":"2018-09-05T16:00:00.000Z","updated":"2018-09-10T06:01:43.000Z","comments":true,"path":"2018/09/06/2018-09-06_Model_Evaluation_Selection/","link":"","permalink":"http://ai.wisim.me/2018/09/06/2018-09-06_Model_Evaluation_Selection/","excerpt":"一、经验误差与过拟合 错误率(error rate)：分类错误的样本数占样本总数的比例,E = a/m 精度(accuracy)：精度 = 1 一 错误率 误差(error)：学习器的实际预测输出与样本的真实输出之间的差异 经验误差(empirical error)：学习器在训练集上的误差，也叫训练误差(training error) 泛化误差(generalization error)：学习器在新样本上的误差 过拟合(overfitting)：当学习器把训练样本学得”太好”了的时候，很可能巳经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象称为过拟合。其中最常见的情况是由于学习能力过于强大，以至于把训练样本所包含的不太一般的特性都学到了。过拟合为什么无法避免？机器学习面临的问题通常是NP 难甚至更难，而有效的学习算法必然是在多项式时间内运行完成，若可彻底避免过拟合， 则通过经验误差最小化就能获最优解，这就意味着我们构造性地证明了 “P=NP” ;因此只要相信”P≠NP “ ，过拟合就不可避免P。 欠拟合(underfitting)：是指对训练样本的一般性质尚未学好。通常是由于学习能力低下而造成的。","text":"一、经验误差与过拟合 错误率(error rate)：分类错误的样本数占样本总数的比例,E = a/m 精度(accuracy)：精度 = 1 一 错误率 误差(error)：学习器的实际预测输出与样本的真实输出之间的差异 经验误差(empirical error)：学习器在训练集上的误差，也叫训练误差(training error) 泛化误差(generalization error)：学习器在新样本上的误差 过拟合(overfitting)：当学习器把训练样本学得”太好”了的时候，很可能巳经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象称为过拟合。其中最常见的情况是由于学习能力过于强大，以至于把训练样本所包含的不太一般的特性都学到了。过拟合为什么无法避免？机器学习面临的问题通常是NP 难甚至更难，而有效的学习算法必然是在多项式时间内运行完成，若可彻底避免过拟合， 则通过经验误差最小化就能获最优解，这就意味着我们构造性地证明了 “P=NP” ;因此只要相信”P≠NP “ ，过拟合就不可避免P。 欠拟合(underfitting)：是指对训练样本的一般性质尚未学好。通常是由于学习能力低下而造成的。 二、模型评估方法通常，我们可以通过实验测试来对学习器的泛化误差进行评估并进而做出选择。为此，需要使用一个“测试集” (testing set) 来测试学习器对新样本的判别能力，然后以测试集上的 “测试误差” (testing error) 作为泛化误差的近似。通常我们假设测试样本也是从样本真实分布中独立同分布采样而得。但需要注意的是，测试集应该尽可能与训练集互斥，即测试样本尽量不在训练集中出现、未在训练过程中使用过。 我们只有一个包含 m 个样例的数据集 $D=\\{(x_1, y_1), (x_2, y_2), … , (x_m, y_m)\\}$ ​， 既要训练，又要测试，怎样才能做到呢？答案是：通过对 D 进行适当的处理，从中产生出训练集 S 和测试集​ T 。下面介绍几种常见的做法。 1. 留出法（hold-out）直接将数据集D 划分为两个互斥的集合，一个用来训练模型，一个评估。$D = S\\cup T, \\; S\\cap T = \\emptyset$，D为总数据集，S为训练数据集，T为测试数据集。 S 过大，测试误差不够准确 T 过大，训练出的模型不够准确 训练和测试集的划分要尽可能保持数据分布的一致性，避免因数据划分引入额外的偏差。一种保留类别比例的采样：stratified sampling. 单次使用留出法得到的估计结果不够稳定可靠。一般采用若干次随机划分、重复实验取平均值。 常见做法：大约 2/3 ~ 4/5 的样本用于训练，剩余样本用于测试。 2. 交叉验证法（cross validation)将 D 做分成 k 个大小相似的部分, $D = D_1\\cup D_2 \\cup \\ldots \\cup D_k, \\; D_i\\cap D_j = \\emptyset \\, (i\\neq j)$，留下一个做测试集，其他作为训练集，从而得到 k 次训练和测试。划分本身还要随机重复 p 次，最终的评估结果是这 p 次 k 折交叉验证结果的均值。通常把交叉验证法称为 k 折交叉验证 (​ k - fold cross validation)。​ 最常用的取值是 10，此时称为 10 折交叉验证；其他常用的 k 值有 5、20 等。 特殊例子：k = m(数据集\b中的数据个数), 称为留一法(LOO). 当 m 很大时工作量太大。 3. 自助法(bootstrapping)自助采样(bootstrap sampling)：sampling with replacement. 给定包含 m 个样本的数据集D，每次有放回取出一个样本，重复m次，构成采样数据集D’。有一部分样本会重复出现，有一部分不会出现。样本在 m 次采样中始终不被采到的概率是： \\lim_{m\\to \\infty} \\left (1-\\frac{1}{m}\\right )^m = \\frac{1}{e} \\approx 0.368所以大约有 1/3 的样本不会在采样集中出现。采样数据集作为训练集，剩下的作为测试集。 优点：自助法在数据集较小、难以有效划分时有用。 缺点：自助法改变了初始数据集的分布，会引入估计偏差。 4. 调参与最终模型(parameter tuning)参数空间太大，调参的工作量很大。在不少应用中，参数调得好不好往往对最终模型性能有关键性影响。 如果误差函数对参数是光滑的，可以用优化算法寻找最优参数。 模型评估与选择中用于评估测试的数据集称为 validation set，和测试集不同，属于训练数据中的一部分。 三、性能度量（performance measure）回归任务最常用的是“均方误差”（mean squared error) ： E(f; D) = \\frac{1}{m}\\sum_{i=1}^m (f(\\boldsymbol x_i)-y_i)^2 \\tag{3.1}更一般地，对于数据分布D和概率密度p(x)的表达式如下： E(f; \\mathcal D) = \\int_{\\boldsymbol x\\sim \\mathcal D} (f(\\boldsymbol x)-y)^2p(\\boldsymbol x) {\\rm d}\\boldsymbol x \\tag{3.2}其实3.1和3.2式分别就是离散\b数据和连续数据的均方误差表达式。 1. 错误率与精度对于数据分布D: 错误率：$E(f; \\mathcal D) = \\frac{1}{m}\\sum_{i=1}^m(f(x_i)\\neq y_i)$ 错误率更一般的表达式：$E(f; \\mathcal D) = \\int_{\\boldsymbol x\\sim \\mathcal D} (f(\\boldsymbol x)\\neq y)p(\\boldsymbol x) {\\rm d}\\boldsymbol x$ 精度：$E(f; \\mathcal D) = \\frac{1}{m}\\sum_{i=1}^m(f(x_i) = y_i)$ 精度更一般的表达式：$E(f; \\mathcal D) = \\int_{\\boldsymbol x\\sim \\mathcal D} (f(\\boldsymbol x) = y)p(\\boldsymbol x) {\\rm d}\\boldsymbol x$ 2. 查准率、查全率与F1以信息检索为例： 查准率(precision): 检索出的信息中有多少比例是用户感兴趣的 查全率(recall)：用户感兴趣的信息中有多少被检索出来了 对于二分类问题，可将样例根据其真实类别以及机器学习分类器\b预测类别的组合划分为真正例（true positive）、假正例子（false positive）、真反例（true negative）以及假反例（false negative）四种情形。令TP、FP、TN、FN分别表示其对应的样例数。显然有 TP+FP+TN+FN=总样例数。分类结果的“混淆矩阵”（confusion matrix）如下： 查准率 $P=\\frac{TP}{TP+FP}$ 查全率 $R=\\frac{TP}{TP+FN}$ 另外，人们设计了一些综合考虑查准率和查全率的性能度量。 \b平衡点（Break-Event Point,BEP）是这其中的一个度量，它是“查准率=查全率”时的取值。 BEP过于简化，更常用的是F1度量： F1=\\frac{2 \\times P \\times R}{P+R}=\\frac{2 \\times TP}{样例总数+TP-TN} \\tag{3.3}考虑到有的应用中查准率和查全率的权重\b不同，给出F1度量更一般的形式： F_{\\beta}=\\frac{(1+{\\beta}^2) \\times P \\times R}{({\\beta}^2 \\times P)+R} \\tag{3.4}其中$\\beta$表示查全率对查准率的相对重要性。$\\beta=1$时退化为标准的F1度量（3.3式）。$\\beta &gt; 1$时，查全率更\b重要。$\\beta &lt; 1$时查准率更重要。 四、比较检验机器学习中性能比较比想象的要复杂。原因有三： 希望比较泛化性能，但获得的度量是测试集上的，两者有差别； 测试集上的性能和测试集的选取有关； 算法的随机性。 统计假设检验(hypothesis test)为我们比较学习器性能提供了重要依据. 若在测试集上学习器A比B好，则A的泛化性能是否在统计意义上优于B，以及这个结论的把握有多大。 假设检验: 二项检验, t检验 交叉验证t检验 McNemar检验 Friedman检验和Nemenyi后续检验 五、偏差与方差“偏差-方差分解”（bias-variance decomposition）是解释机器学习算法泛化性能的一种重要工具。偏差-方差分解试图对学习算法的期望泛化错误率进行拆解。 泛化误差可以分解为偏差、方差与噪声之和： E(f;D)=bias^2(x)+var(x)+\\epsilon^2 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/tags/ML/"}]},{"title":"SVM 简介【译】","slug":"2018-09-05_introduction_to_SVM","date":"2018-09-04T16:00:00.000Z","updated":"2018-09-07T10:53:14.000Z","comments":true,"path":"2018/09/05/2018-09-05_introduction_to_SVM/","link":"","permalink":"http://ai.wisim.me/2018/09/05/2018-09-05_introduction_to_SVM/","excerpt":"原文：An introduction to Support Vector Machines (SVM) 如果你在处理文本分类问题，为了提炼数据，可能已经尝试过朴素贝叶斯\b（Naive Bayes）分类算法。如果你的数据集还算正常的话，\b并且想要一步到位表现更好的话，可以考虑使用 SVM。SVM 是一个在有限数据集上十分快速且靠谱的分类算法。","text":"原文：An introduction to Support Vector Machines (SVM) 如果你在处理文本分类问题，为了提炼数据，可能已经尝试过朴素贝叶斯\b（Naive Bayes）分类算法。如果你的数据集还算正常的话，\b并且想要一步到位表现更好的话，可以考虑使用 SVM。SVM 是一个在有限数据集上十分快速且靠谱的分类算法。 你可能已经有一点点深入地\b去学习 SVM 了，是不是遇到了一些专业术语，比如：线性可分（linearly separable）、核技巧（kernel trick} 以及 核函数（kernel functions）。不过不用担心，SVM 背后的思想其实很简单，并且想要实际应用到文本分类的话，并不需要多少复杂的知识。 在继续阅读之前，推荐先看一下 朴素贝叶斯分类指南（our guide to Naive Bayes classifiers），这里面有一些关于文本处理的相关知识。 开始。 SVM 是如何\b运行的？通过一个简单地例子来更好地理解 SVM 以及它是如何运行的。假设有红、蓝两个标签，并且我们的数据有x、y两个特征。如果我们给出一对 (x,y)，想要判断它是红还是蓝。首先画出已有数据集： SVM 会输入这些数据点然后输出一个可以最优分割标签的超平面（在二维空间里面是一条直线）。这个超平面就是 决策边界：在我们这个例子里，落在左边的就分类为蓝，落在右边的就分类为红。如图： 但是，\b哪一个才是最优超平面呢？对于 SVM 来说，最优超平面就是到所有标签的距离\b最大的超平面。换句话来说，就是\b最优超平面到最近的标签的距离是所有超平面中最大的（在这个例子中是最优分割直线到最近标签的距离为最大）。看一下这个图： 可以看一下这个YouTube视频，直观感受一下最后超平面是如何找到的。 非线性数据上面这个例子很简单，因为它是线性\b可分的，直接找到一条直线就可以完成分类了。然而实际应用中，大多都是线性不可分的，看看下面这个例子： 很显然，上面这个数据是不可能找到一个\b直线来划分的。但是我们可以发现，各个标签还是相对分隔明显的，也许\b有其他的办法分类。 所以这里我们这样操作：新增一个\b第三维坐标，于是现在变成了x,y,z三个坐标。并且为了方便计算，我们定义 $z=x^2+y^2$（注意到这是一个圆的表达式）。于是在这个三维空间里，我们从垂直于y轴的方向就可以看到下面这样： SVM 是怎么做到这样的效果呢？我们继续看看： 效果看起来很棒，由于我们现在是在三维空间里，所以这个分割超平面是平行于x轴且垂直于z轴的（这里就是z=1这个平面）。 下面这张图是从z轴的方向垂直向下\b观察，这样又只看到x,y\b这两个维度了： 这样我们就利用 SVM 将数据集用一个半径为1的圆周分割开来。再看下面这个：视频 这里小结一下：\b在这个例子中，对于线性不可分的数据，先升到\b三维空间，再投影到一个线性可分的二维平面进行分类，然后再回到原始的二维平面就可以将线性不可分的数据分类了。 核技巧在上面这个线性不可分的例子中，我们找到了一种映射到高维的方法来解决了分类问题。但是，计算映射的过程很复杂，而且\b还要计算不止一个维度。这样处理数据集其实工作量还是比较大得，有没有更简单更高校的方法呢。有，就是我们要说的核技巧。 SVM 不需要实际的向量来参与计算，真正有用的时向量之间的点\b积(dot products)，这样我们就可以直接跳过第一步的升维映射\b计算过程了。\b 下面是我们要做的事情： \b\b引入我们需要的新空间：$z=x^2+y^2$ 计算出这个空间里向量之间新的点积和，例如： $a \\cdot b=x_a \\cdot x_b+y_a \\cdot y_b+z_a \\cdot z_b$ $a \\cdot b=x_a \\cdot x_b+y_a \\cdot y_b+(x_a^2+y_a^2) \\cdot (x_b^2+y_b^2)$ 让 SVM 来解决分类问题，但是要使用上面这个新的点积-我们称之为核函数 这就是我们所说的核技巧，\b避免了许多复杂计算。通常这个核是线性的，并且我们会\b得到一个线性分类器。但是，我们也可以使用一个非线性核（上面这个例子），从而得到一个非线性分类器，也可以避免大量计算。 值得注意的是，核技巧并不是 SVM 所特有的一部分，核技巧也可以用于其他线性分类器，例如：logistic regression。SVM 本身只关注决策边界。 SVM 如何应用于自然语言分类根据上面的知识，我们可以在多维空间里对向量进行分类。现在要讲这个算法应用于文本分类，首先要做的就是把一条一条的文本转换为一个一个的数字向量，才能使用 SVM 来进行分类。\b另一方面，我们使用 SVM 进行文本分类的时候，需要关注文本的什么特征呢？ 一般我们关注的就是词频，就像之前朴素贝叶斯算法中所做的一样。我们把文本看做一袋单词，出现在这里面的单词有一个特征，就是在整个文本中这个单词出现的频率，也就是词频。 词频的计算方式就是用\b这个词在文本中出现的次数除以整个文本的单词个数。例如这个句子”All monkeys are primates but not all primates are monkeys”，单词 “monkeys” 的词频就是 2/10=0.2，”but” 这个词的词频是 1/10=0.1。 此外，还可以使用 TF-IDF来计算词频。 经过上面的操作，我们数据集中得所有文本就变成了一系列多维向量，向量里的元素代表着每个单词的词频。这时候我们再把数据喂给 SVM 处理。我们还可以使用预处理技术例如 “stemming”,移除停顿词，以及使用 “n-grams”。 选择一个核函数既然我们已经有了这些特征向量，剩下的事情就是为模型选择核函数了。每个问题都要具体对待，并且核函数取决于具体的数据。这个例子中我们的数据分布看起来是一个同轴的圆，所以我们选择一个适用于这些数据点的核函数。 考虑到这一点，\b哪个核函数才最适用于自然语言处理呢？\b我们需要一个非线性分类器么？或者这个数据是线性可分的么？这样一看，我们最好选择一个线性核，为什么呢？ 回到上面这个例子中，我们的数据有两个特征。而 SVM 实际应用中，特征会非常多。我们的例子使用非线性核也许比较合适，可以避免过拟合。 整合剩下的事情就是训练数据了！从数据集中拿出一部分，并为其设置标签，将其转化为词频向量，然后喂给 SVM。最终会生成一个模型。然后未标记的数据就可以用这个模型来分类了。注意也要将这些数据转化为词频向量，然后分类结果就是\b输出这个文本的标签。 结语这里只是 \bSVM 的基础知识！ 总结如下：SVM 可以对线性可分的数据进行分类。 如果数据线性不可分，则要使用核技巧来使得 SVM 可以生效。 对于文本分类来说，尽量选用线性核。 像神经网络这样新的算法，它们有两个优势：更快速高效并且在数据量少的时候表现良好。这就使得这些新的算法更适合文本分类，\b\b只要从数据集中拿出一小部分去训练模型即可。 想要深入了解 SVM，可以学习 MIT\b的这个课程。 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"SVM","slug":"SVM","permalink":"http://ai.wisim.me/tags/SVM/"}]},{"title":"大数定理随笔","slug":"2018-09-04_law_of_large_numbers_note","date":"2018-09-03T16:00:00.000Z","updated":"2018-09-05T01:05:29.000Z","comments":true,"path":"2018/09/04/2018-09-04_law_of_large_numbers_note/","link":"","permalink":"http://ai.wisim.me/2018/09/04/2018-09-04_law_of_large_numbers_note/","excerpt":"在数学与统计学中，大数定律又称大数法则、大数律，是描述相当多次数重复实验的结果的定律。根据这个定律知道，样本数量越多，则其平均就越趋近期望值。","text":"在数学与统计学中，大数定律又称大数法则、大数律，是描述相当多次数重复实验的结果的定律。根据这个定律知道，样本数量越多，则其平均就越趋近期望值。 大数定律主要有两种表现形式：弱大数定律和强大数定律。定律的两种形式都肯定无疑地表明，样本均值： $\\overline{X}_n=\\frac{1}{n}(X_1+X_2+…+X_n)$ 收敛于期望值： $\\overline{X}_n \\rightarrow u , n\\rightarrow\\infty$ 其中 $X_1, X_2, …$ 是独立同分布、期望值 $E(X_1)=E(X_2)=…=u$ ,且皆勒贝格可积的随机变量构成的无穷序列。$X_j$ 的勒贝格可积性意味着期望值 $E(X_j)$ 存在且有限。 方差 $Var(X_1)=Var(X_2)=…=\\sigma^2&lt;\\infty$ 有限的假设是非必要的。很大或者无穷大的方差会使其收敛得缓慢一些，但大数定律仍然成立。通常采用这个假设来使证明更加简洁。 强（大数定理）和弱（大数定理）之间的差别在所断言的收敛的方式。 弱大数定律弱大数定律也称为辛钦定理，陈述为：样本均值依概率收敛于期望值 ${ {\\overline {X}}_{n}\\ {\\xrightarrow {P}}\\ \\mu \\quad {\\textrm {as}}\\quad n\\to \\infty }$也就是说对于任意正数 $\\varepsilon$ 有${ \\lim _{n\\to \\infty }P\\left(\\,|{\\overline {X}}_{n}-\\mu |&gt;\\varepsilon \\,\\right)=0}$ 强大数定律强大数定律指出，样本均值以概率1收敛于期望值。 ${ {\\overline {X}}_{n}\\ {\\xrightarrow {\\text{a.s.}}}\\ \\mu \\quad {\\textrm {as}}\\quad n\\to \\infty }$,即 ${ P\\left(\\lim _{n\\to \\infty }{\\overline {X}}_{n}=\\mu \\right)=1}$ 切比雪夫定理的特殊情况设 ${a_{1},\\ a_{2},\\ \\dots \\ ,\\ a_{n},\\ \\dots }$ 为相互独立的随机变量，其数学期望为： ${E(a_{i})=\\mu \\quad (i=1,\\ 2,\\ \\dots )}$，方差为：${Var (a_{i})=\\sigma ^{2}\\quad (i=1,\\ 2,\\ \\dots )}$ 则序列 ${\\overline {a}}={\\frac {1}{n}}\\sum _{i=1}^{n}a_{i}$ 依概率收敛于 $\\mu$（即收敛于此数列的数学期望 $E(a_{i})$。 换言之，在定理条件下，当 n 无限变大时，n 个随机变量的算术平均将变成一个常数。 伯努利大数定律设在 n 次独立重复伯努利试验中，事件 X 发生的次数为 $n_{x}$ 。事件 X 在每次试验中发生的母体机率为 p。${\\frac {n_{x}}{n}}$ 代表样本发生事件 X 的频率。 大数定律可用机率极限值定义: 则对任意正数 $\\varepsilon &gt;0$，下式成立： $\\lim _{n\\to \\infty }{P{\\left\\{\\left|{\\frac {n_{x}}{n}}-p\\right|&lt;\\varepsilon \\right\\}}}=1$ 定理表明事件发生的频率依机率收敛于事件的母体机率。定理以严格的数学形式表达了频率的稳定性。就是说当 n 很大时，事件发生的频率于母体机率有较大偏差的可能性很小。 THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[{"name":"大数定理","slug":"大数定理","permalink":"http://ai.wisim.me/tags/大数定理/"}]},{"title":"支持向量机 SVM：详解非线性SVM","slug":"2018-08-02_SVM_part2","date":"2018-08-01T16:00:00.000Z","updated":"2018-08-02T10:43:35.000Z","comments":true,"path":"2018/08/02/2018-08-02_SVM_part2/","link":"","permalink":"http://ai.wisim.me/2018/08/02/2018-08-02_SVM_part2/","excerpt":"","text":"一、非线性SVM二、\bSMO(Sequential Minimal Optimizaion)算法三、异常值的处理-松弛变量的引入 参考： Python3《机器学习实战》学习笔记（八）：支持向量机原理篇之手撕线性SVM 支持向量机的原理和实现 机器学习与数据挖掘-支持向量机(SVM) 支持向量机(SVM)是什么意思？ 支持向量机通俗导论（理解SVM的三层境界） Support Vector Machines\b 零基础学SVM—Support Vector Machine(一) THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"SVM","slug":"SVM","permalink":"http://ai.wisim.me/tags/SVM/"}]},{"title":"Binary Tree Zigzag Level Order Traversal","slug":"2018-07-17-ARTS_ISSUE_002_a","date":"2018-07-16T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/07/17/2018-07-17-ARTS_ISSUE_002_a/","link":"","permalink":"http://ai.wisim.me/2018/07/17/2018-07-17-ARTS_ISSUE_002_a/","excerpt":"The more we do,the more we can do.","text":"The more we do,the more we can do. 1. 题目：二叉树锯齿形层次遍历123456789101112131415Given a binary tree, return the zigzag level order traversal of its nodes&apos; values. (ie, from left to right, then right to left for the next level and alternate between).For example:Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7return its zigzag level order traversal as:[ [3], [20,9], [15,7]] 2. 解析本来看错题目以为就是简单的层次遍历，一个队列就可以解决问题。后来发现有个 锯齿形(zigzag) 。这样遍历每一层就可能有两个顺序，一个是 从左到右(ltr)，另一个是 从右到左(rtl)，整个的遍历顺序就是先ltr，再rtl，如此循环交替。 拿上面的例子看一下： 当遍历顺序是rtl时，也就是第二层，我们最终要的顺序应该是 20-&gt;9，这里我们先把9插入队列，再插入20，然后每次从队尾取出元素，就是要求的顺序。 当遍历顺序是ltr时，看看第三层，我们最终要的顺序应该是 15-&gt;7，这里我们先把7插入队列，再插入15，然后每次从队尾取出元素，就是要求的顺序。 可以比较一下：当 rtl 时，先插入的是左儿子，当 ltr 时，先插入的是右儿子。思路有了，直接写代码。C++ 代码如下： 3. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;void printResult(vector&lt;vector&lt;int&gt;&gt; res) &#123; int size = res.size(); for (int i = 0; i &lt; size; ++i) &#123; vector&lt;int&gt; item = res[i]; for (int j = 0; j &lt; item.size(); ++j) &#123; cout &lt;&lt; item[j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125;/** * 1. 生成一个哨兵指针，始终指向某一层的第一个节点 * 2. 每次将节点插入到一个队列末尾，当遍历到上一个哨兵的时候，表面这一层全部遍历结束 * @param root * @return */vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;vector&lt;TreeNode *&gt;&gt; resultNodes; bool ltr = false;//true : 从左往右遍历.false : 从右往左遍历 if (root == NULL) &#123; return result; &#125; TreeNode *layerEnd = root;//指向某一层队首的哨兵 vector&lt;TreeNode *&gt; currentNodes; vector&lt;TreeNode *&gt; nextNodes; vector&lt;int&gt; next; currentNodes.push_back(root); resultNodes.push_back(currentNodes); while (!currentNodes.empty()) &#123; //1. 每次都从队尾访问并取出， TreeNode *tmp; tmp = currentNodes.back(); currentNodes.pop_back(); //2. 插入到当前层的表示队列 next cout &lt;&lt; tmp-&gt;val &lt;&lt; endl; next.push_back(tmp-&gt;val); if (ltr) &#123; //3. 如果是 ltr if (tmp-&gt;right != NULL) &#123; nextNodes.push_back(tmp-&gt;right); &#125; if (tmp-&gt;left != NULL) &#123; nextNodes.push_back(tmp-&gt;left); &#125; &#125; else &#123; //3. 如果是 rtl if (tmp-&gt;left != NULL) &#123; nextNodes.push_back(tmp-&gt;left); &#125; if (tmp-&gt;right != NULL) &#123; nextNodes.push_back(tmp-&gt;right); &#125; &#125; //4. 如果遇到哨兵节点，表面此层遍历结束。 if (tmp == layerEnd) &#123; //存入结果 result.push_back(next); resultNodes.push_back(nextNodes); //注意这里是结束条件 if (nextNodes.empty()) &#123; break; &#125; //哨兵放在队首 layerEnd = nextNodes.front(); //将下一层加入缓存遍历 currentNodes.clear(); currentNodes.insert(currentNodes.end(), nextNodes.begin(), nextNodes.end()); //注意清空 nextNodes.clear(); next.clear(); ltr = !ltr; &#125; &#125; printResult(result); return result;&#125; 4. 测试123456789101112131415int main() &#123; TreeNode *node_a = new TreeNode(3); TreeNode *node_b = new TreeNode(9); TreeNode *node_c = new TreeNode(20); TreeNode *node_d = new TreeNode(15); TreeNode *node_e = new TreeNode(7); node_a-&gt;left = node_b; node_a-&gt;right = node_c; node_c-&gt;left = node_d; node_c-&gt;right = node_e; zigzagLevelOrder(node_a); return 0;&#125; 输出： 1233 20 9 15 7 正确。 THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"TREE","slug":"TREE","permalink":"http://ai.wisim.me/tags/TREE/"},{"name":"ARTS","slug":"ARTS","permalink":"http://ai.wisim.me/tags/ARTS/"}]},{"title":"ARTS ISSUE#002","slug":"2018-07-17-ARTS_ISSUE_002","date":"2018-07-16T16:00:00.000Z","updated":"2018-09-05T01:17:28.000Z","comments":true,"path":"2018/07/17/2018-07-17-ARTS_ISSUE_002/","link":"","permalink":"http://ai.wisim.me/2018/07/17/2018-07-17-ARTS_ISSUE_002/","excerpt":"","text":"Algorithm : Binary Tree Inorder Review : [点评一篇英文技术文章] Tip : [学习一个技术技巧] Share : [分享一个技术观点和思考] THE END.","categories":[{"name":"ARTS","slug":"ARTS","permalink":"http://ai.wisim.me/categories/ARTS/"}],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://ai.wisim.me/tags/ARTS/"}]},{"title":"Git Commit Message Format","slug":"2018-07-06-ARTS_ISSUE_001_t","date":"2018-07-05T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/07/06/2018-07-06-ARTS_ISSUE_001_t/","link":"","permalink":"http://ai.wisim.me/2018/07/06/2018-07-06-ARTS_ISSUE_001_t/","excerpt":"Never leave todays’s work tomorrow.","text":"Never leave todays’s work tomorrow. 1. Why need formatIt will benefit ourselves and others. 2. Specific formatLet’s first see the abstract formula: 1&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; example:1fix(controller) : nullpointexception typeIt is used to explain the type of this commit and can only be in the following 7 types: feat：add new function（feature）of your project. fix：fix bugs. docs：add documentation. style： just modify the style of code,it does’n affect the execution of code. refactor：neither feat nor fix,it may affect the execution of code. test：add test unit. chore：change of build tools or helper and enviroment. scopeIt is used to explain the scope of this commit,such as view layer,model layer,controller layer and so on. subjectIt is a short description of this commit and it can not be in excess of 50 character. start with verb and use first persion present tense,such as change instead of changes nor changed make sure the first character should be lower case do not add period(.) at the end of your subject As you see,above tips of subject also follow it’s rules. THE END.","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://ai.wisim.me/categories/FAQ/"}],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://ai.wisim.me/tags/ARTS/"},{"name":"GIT","slug":"GIT","permalink":"http://ai.wisim.me/tags/GIT/"}]},{"title":"Want to Improve Your Memory?","slug":"2018-07-06-ARTS_ISSUE_001_r","date":"2018-07-05T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/07/06/2018-07-06-ARTS_ISSUE_001_r/","link":"","permalink":"http://ai.wisim.me/2018/07/06/2018-07-06-ARTS_ISSUE_001_r/","excerpt":"","text":"来源 : Want to Improve Your Memory? Science Tells Us the Key (and It Can Actually Be Fun) The key to improving your memory is surprise. Somehow, the novelty of surprise creates a halo of better memory for all the otherwise trivial events of one’s day that we ordinarily forget.” Distract yourself. Celebrate quick wins. Take regular body breaks. Take the opportunity to try something new. THE END.","categories":[{"name":"READING","slug":"READING","permalink":"http://ai.wisim.me/categories/READING/"}],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://ai.wisim.me/tags/ARTS/"},{"name":"Medium","slug":"Medium","permalink":"http://ai.wisim.me/tags/Medium/"}]},{"title":"Binary Tree Inorder","slug":"2018-07-06-ARTS_ISSUE_001_a","date":"2018-07-05T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/07/06/2018-07-06-ARTS_ISSUE_001_a/","link":"","permalink":"http://ai.wisim.me/2018/07/06/2018-07-06-ARTS_ISSUE_001_a/","excerpt":"You cannot find peace by avoiding life.","text":"You cannot find peace by avoiding life. 1. 题目：二叉树中序遍历12345678910111213Given a binary tree, return the inorder traversal of its nodes&apos; values.Example:Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,3,2]Follow up: Recursive solution is trivial, could you do it iteratively? 2. 解析：原来还想先找到左下角的\b节点\b，再按中序的顺序遍历的。后来发现想多了，直接递归遍历，每次遇到中序节点就添加到 vector 中，最后结果返回中序遍历节点元素数组。C++代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;TreeNode *getLBNode(TreeNode *root);void inorder(TreeNode *root);vector&lt;int&gt; all;/** * * @param root node of tree * @return */vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; inorder(root); return all;&#125;void inorder(TreeNode *root) &#123; if (root != NULL) &#123; if (root-&gt;left != NULL) &#123; inorder(root-&gt;left); &#125; cout &lt;&lt; root-&gt;val; all.push_back(root-&gt;val); if (root-&gt;right != NULL) &#123; inorder(root-&gt;right); &#125; &#125;&#125;TreeNode *getLBNode(TreeNode *root) &#123; TreeNode *tmp = root; if (tmp != NULL) &#123; while (tmp-&gt;left != NULL) &#123; tmp = tmp-&gt;left; &#125; &#125; return tmp;&#125; 3. 测试代码：123456789101112int main() &#123; TreeNode *node1 = new TreeNode(1); TreeNode *node2 = new TreeNode(2); TreeNode *node3 = new TreeNode(3); node1-&gt;left = NULL; node1-&gt;right = node2; node2-&gt;left = node3; inorder(node1); return 0;&#125; 直接运行会输出： 1132 正确。权当复习。 THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"TREE","slug":"TREE","permalink":"http://ai.wisim.me/tags/TREE/"},{"name":"ARTS","slug":"ARTS","permalink":"http://ai.wisim.me/tags/ARTS/"}]},{"title":"ARTS ISSUE#001","slug":"2018-07-06-ARTS_ISSUE_001","date":"2018-07-05T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/07/06/2018-07-06-ARTS_ISSUE_001/","link":"","permalink":"http://ai.wisim.me/2018/07/06/2018-07-06-ARTS_ISSUE_001/","excerpt":"","text":"Algorithm : Binary Tree Inorder Review : Want to Improve Your Memory? Tip : Git Commit Message Format Share : [分享一个技术观点和思考] THE END.","categories":[{"name":"ARTS","slug":"ARTS","permalink":"http://ai.wisim.me/categories/ARTS/"}],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://ai.wisim.me/tags/ARTS/"}]},{"title":"支持向量机 SVM：SVM简介","slug":"2018-05-29_SVM_part1","date":"2018-05-28T16:00:00.000Z","updated":"2018-08-02T10:42:32.000Z","comments":true,"path":"2018/05/29/2018-05-29_SVM_part1/","link":"","permalink":"http://ai.wisim.me/2018/05/29/2018-05-29_SVM_part1/","excerpt":"支持向量机(support vector machine)，一般简称SVM，通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。 SVM 原理分为软间隔最大化、拉格朗日对偶、最优化问题求解、核函数、序列最小优化 SMO 等部分。","text":"支持向量机(support vector machine)，一般简称SVM，通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。 SVM 原理分为软间隔最大化、拉格朗日对偶、最优化问题求解、核函数、序列最小优化 SMO 等部分。 一、\b\b间隔和软间隔最大化1. 分隔超平面 对于二分类问题来说，中间这条实线（或\b三维空间里的平面）\u001c，就叫做分隔超平面，表达式为 $\\vec w \\cdot \\vec x + b=0$。 2. 函数间隔SVM是通过超平面将样本分为两类。在超平面 $w\\cdot x+b=0$ 确定的情况下，$|w\\cdot x+b|$ 可以相对地表示点x距离超平面的远近。对于两类分类问题，如果 $w\\cdot x+b&gt;0$ ，则x的类别被判定为1；否则判定为-1。 所以如果 $y(w\\cdot x+b)&gt;0$ ，则认为x的分类结果是正确的，否则是错误的。且 $y(w\\cdot x+b)$ 的值越大，分类结果的确信度越大。反之亦然。所以样本点 $(x_{i}, y_{i})$ 与超平面(w, b)之间的函数间隔定义为: \\gamma_i=y_i(wx_i+b) \\tag{1.2.1}我们用 $\\hat{\\gamma}$ 表示函数间隔，$\\hat{\\gamma}=y(w \\cdot x+b)$。 3. 几何间隔(软间隔)上面函数间隔的定义存在问题：即w和b同时缩小或放大M倍后，超平面并没有变化，但是函数间隔却变化了。所以，需要将w的大小固定。例如||w||=1，使得函数间隔固定，这时的间隔也就是几何间隔 。几何间隔的定义如下: \\gamma_{i} = y_{i} (\\frac{w}{||w||}\\cdot x_{i} + \\frac{b}{||w||}) = y_i(\\frac{w\\cdot x_i+b}{||w||}) \\tag{1.3.1}其中 xi 代表第 i 条数据，yi 代表第 i 条数据对应的目标变量的取值，取值有+1 和-1 两种。所以当第 i 条数据被正确分类时，y 取值和 wx+b 取值的正负一致，几何间隔为正；当被错误分类时，y 取值和 wx+b 取值的正负相反，几何间隔为负。如下图： 我们用 $\\tilde{\\gamma}$ 表示几何间隔，$\\tilde{\\gamma}=y\\frac{w \\cdot x+b}{||w||}$。由于 $\\hat{\\gamma}=y(w \\cdot x+b)$，所以 $\\tilde{\\gamma}=\\frac{\\hat{\\gamma}}{||w||}$。 此外，函数间隔以及几何间隔其实并不是表示某种距离，真正的点到直线（或平面）的距离\b公式是： \\gamma=\\frac{w \\cdot x+b}{||w||}\\tag{1.3.2}小结一下： (1). 实际距离 ：$\\gamma = \\frac{w \\cdot x + b}{||w||} \\: (1.3.3)$ (2). 函数距离 ：$\\hat{\\gamma}=y(w \\cdot x+b) \\: (1.3.4)$ (3). 几何距离 ：$\\tilde{\\gamma}=y\\frac{w \\cdot x+b}{||w||}=\\frac{\\hat{\\gamma}}{||w||} \\: (1.3.5)$ \b4. 软间隔最大化SVM 的核心思路是最大化支持向量到分隔超平面的间隔。后面所有的推导都是以最大化此间隔为核心思想展开。 (1). 首先定义几何间隔中最小的为： \\tilde{\\gamma}=min\\{\\tilde{\\gamma_i}\\} \\tag{1.4.1}(2). 由此可以得到间隔最大化问题的目标函数 $max \\{\\tilde{\\gamma_i}\\}$，并遵循如下约束条件：$s.t.\\tilde{\\gamma_i} = \\frac{y_i(w\\cdot x_i+b)}{||w||}\\geq \\tilde{\\gamma}$，（s.t.表示 subject to：满足…限制） 。 这里重点解释一下上面这句话的意思： (1).几何间隔就是点到给定超平面的距离；几何间隔中最小值 $min\\{\\tilde{\\gamma_i}\\}$ 表示所有样本点中几何间隔的最小值。 (2).间隔最大化问题 $max \\{\\tilde{\\gamma}\\}$ 表示要找到\b一种情况使得\b最小几何间隔在所有情况中取最大值，记为 $M = arg\\:max_{w,b}\\{\\frac{min_{n}[y_i(w^T \\cdot x_i+b)]}{||w||}\\} \\: (1.4.2)$。 5. 目标函数为了方便计算，令\b函数距离的最小值 $min\\{\\hat{\\gamma}\\}=min\\{y(w \\cdot x+b) \\}= 1$，则 $M=arg \\: max_{w,b}{\\{\\frac{1}{||w||}\\}}$。很显然，软间隔最大化 就是要求\bM这个最大值，也就是要求 $\\frac{1}{||w||}$的最大值，也就是要求 ||w|| 的最小值。此时几何间隔的最大化情况就是：$\\tilde{\\gamma} = \\frac{1}{||w||}$。 于是就得出了目标函数 : max \\: {\\frac{1}{||w||}},s.t.y_i(w \\cdot x_i+b) \\geq 1,i=1,2,...,n \\tag{1.5.1}等价于 : min \\: \\frac{1}{2} ||w||^2,s.t.y_i(w \\cdot x_i+b) \\geq 1,i=1,2,...,n \\tag{1.5.2}这个公式描述的是一个典型的不等式约束条件下的二次型函数优化问题，同时也是 支持向量机的基本数学模型。 可以看到这样的问题满足如下两个条件： (1). 它所最优化的问题是一个二次式 (2). 它的限制条件是一个线性的一次式 有这样特性的最优化问题就叫二次规划（quadratic programing ，简称QP） 二、拉格朗日对偶（Lagrange duality）1. 最优化问题的分类通常我们需要求解的最优化问题有如下几类： (1). 无约束优化问题，可以写为: min\\:f(x) \\tag{2.1.1}对于第(1)类的优化问题，常常使用的方法就是 Fermat定理(费马定理)，即使用求取f(x)的导数，然后令其为零，可以求得候选最优值，再在这些候选值中验证；如果是凸函数，可以保证是最优解。 (2). 有等式约束的优化问题，可以写为: \\begin{array}{ll} & min\\:f(x);\\\\ & s.t. h_i(x) = 0; \\\\ & i =1, ..., n \\\\ \\end{array} \\tag{2.1.2}对于第(2)类的优化问题，常常使用的方法就是 拉格朗日乘子法（Lagrange Multiplier) ，即把等式约束h_i(x)用一个系数与f(x)写为一个式子，称为 拉格朗日函数，而系数称为拉格朗日乘子。通过拉格朗日函数对各个变量求导，令其为零，可以求得候选值集合，然后验证求得最优值。 (3). 有不等式约束的优化问题，可以写为： \\begin{array}{ll} & min\\:f(x); \\\\ & s.t. h_i(x) = 0; \\\\ & g_j(x) \\leq 0; \\\\ & i =1, ..., n,j =1, ..., m \\\\ \\end{array} \\tag{2.1.3}对于第(3)类的优化问题，常常使用的方法就是 KKT条件。同样地，我们把所有的等式、不等式约束与f(x)写为一个式子，也叫 拉格朗日函数，系数也称拉格朗日乘子，通过一些条件，可以求出最优值的必要条件，这个条件称为KKT条件。 2. KKT条件KKT条件的全称是Karush-Kuhn-Tucker条件，KKT条件是说最优值条件必须满足以下条件： 条件一：经过拉格朗日函数处理之后的新目标函数L(w,b,a)对x求导为零; 条件二：$h_i(x)=0$; 条件三：$a*g_j(x)=0$; 求取这三个等式之后就能得到候选最优值。其中第三个式子非常有趣，因为g(x)&lt;=0，如果要满足这个等式，必须a=0或者g(x)=0。 3. 拉格朗日对偶由于这个问题的特殊结构，还可以通过拉格朗日对偶性变换到对偶变量 (dual variable) 的优化问题，即通过求解与原问题等价的对偶问题（dual problem）得到原始问题的最优解，这就是 线性可分 条件下支持向量机的对偶算法，这样做的优点在于：一者对偶问题往往更容易求解；二者可以自然的引入 核函数，进而推广到 非线性分类 问题。 1). 首先回顾一下我们要处理的问题是 有不等式约束的的优化问题,这类问题的一般描述是： \\begin{array}{ll} & min\\:f(x); \\\\ & s.t. h_i(x) = 0; \\\\ & g_j(x) \\leq 0; \\\\ & i =1, ..., n,j =1, ..., m \\\\ \\end{array} \\tag{2.3.1}我们根据原来的目标函数来构造一个新的目标函数： \\theta_p(x)=max_{\\alpha,\\beta;\\beta_j\\geq0} \\:L(x,\\alpha,\\beta) \\tag{2.3.2}2). 其中 $L(\\boldsymbol{x},\\boldsymbol{\\alpha},\\boldsymbol{\\beta})$ 为广义拉格朗日函数，定义为： L(\\boldsymbol{x},\\boldsymbol{\\alpha},\\boldsymbol{\\beta})=f(\\boldsymbol{x})+\\sum_{i=1}^m\\alpha_i h_i(\\boldsymbol{x})+\\sum_{j=1}^n\\beta_j g_j(\\boldsymbol{x}) \\tag{2.3.3}这里，$\\boldsymbol{\\alpha}=[\\alpha_1,\\alpha_2,\\ldots, \\alpha_m]^T,~\\boldsymbol{\\beta}=[\\beta_1,\\beta_2,\\ldots, \\beta_n]^T$，是我们在构造新目标函数时加入的系数变量，也是我们要求的参数。另外不要忘了我们要求的是 $\\theta_p(x)$ 的最小值。 3). 根据上面(2.3.2)和(2.3.3)两个公式我们得到： \\theta_p(x)=max_{\\alpha,\\beta;\\beta_j\\geq0} \\:\\{f(\\boldsymbol{x})+\\sum_{i=1}^m\\alpha_i h_i(\\boldsymbol{x})+\\sum_{j=1}^n\\beta_j g_j(\\boldsymbol{x})\\} \\tag{2.3.4}其中 $h_i(x) = 0;g_j(x) \\leq 0;i =1, …, n,j =1, …, m$ 首先如果x不满足这两条限制，也就是在 可行解区域外,我们观察一下公式(2.3.4)，一定可以找到某一种情况下的参数 $(\\alpha,\\beta)$ 使得 $\\theta_p(x)$ 取向于 $\\infty$，这种情况下肯定不是我们要求的$\\theta_p(x)$ 的最小值。 再看一下x同时满足这两条显示，也就是在 可行解区域内,由于 $h_i(x) = 0;g_j(x) &lt;= 0$，并且 $\\beta_j \\geq0$，那么很显然 $max_{\\alpha,\\beta;\\beta_j\\geq0} \\:\\{\\sum_{i=1}^m\\alpha_i h_i(\\boldsymbol{x})+\\sum_{j=1}^n\\beta_j g_j(\\boldsymbol{x})\\}=0$，于是可以得到 $\\theta_p(x)$ 的取值分布情况： \\theta_P(x)=\\left\\{ \\begin{array}{ll} f({x}) & {x}\\in\\Phi\\\\ \\infty & \\textrm{otherwise} \\end{array} \\right.就这样原来有约束条件的 (2.3.1)问题求解现在就变成了没有约束条件求 $min \\{\\theta_p(x)\\}$ 。 同时，我们设 $\\theta_d(x)=min\\{L(w,\\alpha,\\beta)\\} \\:(2.3.5)$，同时将问题转化为先求 $L(w,\\alpha,\\beta)$ 的最小值，再求它的最大值。与公式(2.3.2) $\\theta_p(x)=max\\{L(w,\\alpha,\\beta)\\}$比较一下： min\\{\\theta_p(x)\\}=min\\{max\\{L(w,\\alpha,\\beta)\\}\\} \\tag{2.3.6}max\\{\\theta_d(x)\\}=max\\{min\\{L(w,\\alpha,\\beta)\\}\\} \\tag{2.3.7}2.3.7 这个问题就是原问题 (2.3.6) 的对偶问题，相对于原问题只是更换了min和max的顺序，而一般更换顺序的结果是Max Min(X) &lt;= Min Max(X)。然而在这里两者相等。由此我们可以设如下： d^*=max\\{min\\{L(w,\\alpha,\\beta)\\}\\} \\leq min\\{max\\{L(w,\\alpha,\\beta)\\}\\}=p^*所以在一定的条件下我们可以得到：$d^{}=p^{}$，值得\b注意的是这里的问题要满足上面所说的 KKT条件。 4. 对偶问题求解1). 根据上面的推导我们知道了对偶问题的原理，回到一开始的问题，看一下公式 (1.5.2)，再将其转换为它的对偶问题可得： d^{*}=max\\{min\\{L(w,\\alpha,b)\\}\\}L(x,\\alpha,\\beta)=\\frac{1}{2}||w||^2-\\sum_{i=1}^m\\alpha_i [y_i(w^T \\cdot x+b)-1] \\tag{2.4.1}2). 首先固定α，也就是将α视为常数，要让L(w,b,α)关于w和b最小化，我们分别对w和b偏导数，令其等于0，即： \\frac{\\partial{L}}{\\partial{w}}=0 \\:=>\\: w=\\sum_{i=1}^{n}\\alpha_i y_i x_i\\frac{\\partial{L}}{\\partial{b}}=0 \\:=>\\: \\sum_{i=1}^{n}\\alpha_i y_i=03). 将上述结果带回L(w,b,α)得到： \\begin{array}{ll} L(w,\\alpha,b) & =\\frac{1}{2}||w||^2-\\sum_{i=1}^m\\alpha_i [y_i(w^T \\cdot x+b)-1]\\\\ & =\\frac{1}{2}w^T \\cdot w-w^T\\sum\\alpha_iy_ix_i-b\\sum\\alpha_iy_i+\\sum\\alpha_i\\\\ & =\\frac{1}{2}w^T \\sum\\alpha_iy_ix_i-w^T\\sum\\alpha_iy_ix_i-b\\cdot0+\\sum\\alpha_i\\\\ & =\\sum\\alpha_i-\\frac{1}{2}(\\sum\\alpha_iy_ix_i)^T\\sum\\alpha_iy_ix_i\\\\ & =\\sum\\alpha_i-\\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i \\alpha_j y_i y_j x_i^T x_j\\\\ \\end{array} \\tag{2.4.2}从上面的最后一个式子，我们可以看出，此时的L(w,α,b)函数只含有一个变量，即 $\\alpha_i$。 4). 现在内侧的最小值求解完成，我们求解外侧的最大值，从上面的式子得到: \\begin{array}{ll} & max\\{\\sum\\alpha_i-\\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i \\alpha_j y_i y_j x_i^T x_j\\} \\\\ & s.t. \\alpha_i\\geq0,i=1,2,...,n \\\\ & \\sum_{i=1}^{n}\\alpha_i y_i=0 \\\\ \\end{array} \\tag{2.4.3}现在我们的优化问题变成了如上的形式。对于这个问题，我们有更高效的优化算法，即序列最小优化（SMO）算法。我们通过这个优化算法能得到α，再根据α，我们就可以求解出w和b，进而求得我们最初的目的：找到超平面，即”决策平面”。最终所求得的\b模型如下： f(x) = w^T \\cdot x + b = \\sum_{i=1}^m \\alpha_i y_i x_i^T x + b \\tag{2.4.4}三、线性不可分与核函数我们上面讨论的都是线性可分的SVM，线性可分也就是分割超平面和数据是在一个空间里。事实上，大部分时候数据并不是线性可分的，这个时候满足这样条件的超平面就根本不存在。对于非线性的情况，SVM 的处理方法是选择一个核函数 K() ，通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。 具体来说，在线性不可分的情况下，支持向量机首先在低维空间中完成计算，然后通过核函数将输入空间映射到高维特征空间，最终在高维特征空间中构造出最优分离超平面，从而把平面上本身不好分的非线性数据分开。 如下图所示，一堆数据在二维空间无法划分，从而映射到三维空间里划分： 1. 映射x为了完成这个目的，用 $\\phi(x)$ 表示将 x 映射后的特征向量。于是，在特征空间划分超平面所对应的模型可表示为：$f(x)=w^T\\:\\phi(x)+b \\: (5.1.1)$。对比一下上面\b的原始向量的模型：$f(x)=w^T\\:x+b$，就是x\b映射成为$\\phi(x)$。 同理公式(5.1.1)中引入拉格朗日乘子，求解整个方程后可得： \\begin{array}{ll} f(x) & =w^T\\cdot\\phi(x)+b\\\\ & = \\sum_{i=1}^n \\alpha_i y_i \\phi(x_i)^T \\phi(x) + b\\\\ & = \\sum_{i=1}^n \\alpha_i y_i k(x_i,x) + b\\\\ \\end{array} \\tag{5.1.2}这里的这个 k(x_i,x) 就是我们所说的 核函数。 再对比一下公式（2.4.3）：$f(x) = \\sum_{i=1}^m \\alpha_i y_i x_i^T x + b$，其实这里的 $x_i^T x$也是一个核函数,称作 线性核。 简单理解就是：非线性 SVM = 核技巧 + 线性 SVM。核技巧的本质就是简化运算。 2. 核函数对于有限维的原始空间，一定存在更高维度的空间，使得前者中的样本映射到新空间后可分。但是新空间（特征空间）的维度也许很大，甚至可能是无限维的。这样的话，如在公式（5.1.2）中直接计算 $\\phi(x_i)^T \\phi(x)$ 就会很困难。 为了避免计算 $\\phi(x_i)^T\\phi(x)$的内积，我们需要设置一个新的函数$k(x_i,k_j)=\\phi(x_i)^T\\phi(x)$ 原始空间中的两个样本 xi和 xj经过 k(.,.)函数计算所得出的结果，是它们在特征空间中映射成的新向量的内积。 如此一来，我们就不必真的计算出 $\\phi(x_i)^T \\cdot \\phi(x)$ 的结果，而可以直接用 k(.,.)函数代替它们。这个函数 k(.,.) 就叫做核函数。现在我们正式给出它的正式定义： 设：X为原始空间（又称输入空间）；H为特征空间（特征空间是一个带有内积的完备向量空间，又称完备内积空间或希尔伯特空间）； 如果存在一个映射： $X \\times X$，使得对所有 $x_i, x_j \\in X$，函数 k(x_i,x_j)满足条件：$k(x_i,k_j)=\\phi(x_i)^T\\phi(x)$，即 k(.,.) 函数为输入空间中任意两个向量映射到特征空间后的内积。则称 k(.,.) 为 核函数，ϕ(⋅)为 映射函数。 3. 非线性 SVM 的对偶问题上面已经\b求出了线性 SVM 的对偶问题：公式(2.4.3) \\begin{array}{ll} & max\\{\\sum\\alpha_i-\\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i \\alpha_j y_i y_j x_i^T x_j\\} \\\\ & s.t. \\alpha_i\\geq0,i=1,2,...,n \\\\ & \\sum_{i=1}^{n}\\alpha_i y_i=0 \\\\ \\end{array}于是非线性 SVM 的对偶问题就变为： \\begin{array}{ll} & max\\{\\sum\\alpha_i-\\frac{1}{2}\\sum_{i,j=1}^{n}\\alpha_i \\alpha_j y_i y_j \\phi(x_i)\\cdot \\phi(x_j)\\} \\\\ & s.t. \\alpha_i\\geq0,i=1,2,...,n \\\\ & \\sum_{i=1}^{n}\\alpha_i y_i=0 \\\\ \\end{array} \\tag{5.1.3}大家可以看到，和线性 SVM 唯一的不同就是：之前的 $x_i$与 $x_j$的内积（点乘） 变成了 $\\phi(x_i)$与$\\phi(x_j)$的内积。 参考： Python3《机器学习实战》学习笔记（八）：支持向量机原理篇之手撕线性SVM 支持向量机的原理和实现 机器学习与数据挖掘-支持向量机(SVM) 支持向量机(SVM)是什么意思？ 支持向量机通俗导论（理解SVM的三层境界） Support Vector Machines\b 零基础学SVM—Support Vector Machine(一) THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"SVM","slug":"SVM","permalink":"http://ai.wisim.me/tags/SVM/"}]},{"title":"Logistic回归算法","slug":"2018-05-18_LogisticRegression","date":"2018-05-17T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/05/18/2018-05-18_LogisticRegression/","link":"","permalink":"http://ai.wisim.me/2018/05/18/2018-05-18_LogisticRegression/","excerpt":"一、前言Logistic回归虽然名字上是叫回归，但其实它是一种分类算法。Logistic回归也在一些文献中也称为logit回归、最大熵分类(MaxEnt)或对数线性分类器。 “回归”的意思就是要找到最佳拟合参数，其中涉及的数学原理和步骤如下： 需要一个合适的分类函数来实现分类。可以使用单位阶跃函数或者Sigmoid函数。 用 代价函数 来表示 预测值h(x) 与 实际值y 的偏差 (h−y)。要使得回归最佳拟合，那么偏差要尽可能小（偏差求和或取均值）。 记J(w,b)表示回归系数取w时的偏差，那么求最佳回归参数w,b就转换成了求J(w,b)的最小值。可以使用梯度下降法求回归参数w,b。 所以，接下来就围绕这几个步骤进行展开。","text":"一、前言Logistic回归虽然名字上是叫回归，但其实它是一种分类算法。Logistic回归也在一些文献中也称为logit回归、最大熵分类(MaxEnt)或对数线性分类器。 “回归”的意思就是要找到最佳拟合参数，其中涉及的数学原理和步骤如下： 需要一个合适的分类函数来实现分类。可以使用单位阶跃函数或者Sigmoid函数。 用 代价函数 来表示 预测值h(x) 与 实际值y 的偏差 (h−y)。要使得回归最佳拟合，那么偏差要尽可能小（偏差求和或取均值）。 记J(w,b)表示回归系数取w时的偏差，那么求最佳回归参数w,b就转换成了求J(w,b)的最小值。可以使用梯度下降法求回归参数w,b。 所以，接下来就围绕这几个步骤进行展开。 二、分类函数1.假设要实现二分类，那么可以找一个函数，根据不同的特征变量，输出0和1，并且只输出0和1，这种函数在某个点直接从0跳跃到1，如图： 但是这种函数处理起来，稍微有点麻烦。 2.我们选择另外一个连续可导的函数，也就是Sigmoid函数,函数的公式如下： $\\widehat{y}=h(z)=\\frac{1}{1+e^{-z}} （\\widehat{y}就表示预测值也就是分类结果）$ 这个函数的特点是，当z=0时，h(z)=0.5，而z越大，h(z)越接近1，z越小，h(z)越接近0。这个函数很像阶跃函数，当z&gt;0，就可以将数据分入1类；当z &lt; 0，就可以将数据分入0类。函数图如下： 确定了分类函数，接下来，我们将Sigmoid函数的输入记为z，那么输入特征变量为： $z=w_0x_0+w_1x_1+…+w_nx_n+b=w^Tx+b$，w是特征向量，b是一个值。 则分类函数：$\\widehat{y}=h(z)=\\frac{1}{1+e^{-z}}= \\frac{1}{1+e^{-(w^Tx+b)}}$ 向量x是特征变量，是输入数据，向量w,b是回归系数是特征。之后的事情就是如何确定最佳回归系数w(w0,w1,w2,…,wn,b)。 采用Sigmoid函数实际上就是将原始的输入x向量和某一合适的参数w向量相乘，得出的值作为sigmoid函数的输入，最终是的输出保持在0和1这两个值中的一个，从而达到分类的要求。 三、损失函数和代价函数1.损失函数（Loss function） 首先要知道损失函数是应用于单独一个训练样本的。而下面要说的代价函数则是针对整个训练集。 为了更好的进行凸优化，我们这里直接给出一个适合Logistic函数的损失函数： $L(\\widehat{y},y) = -[ylog\\widehat{y}+(1-y)log(1-\\widehat{y})]$ 来看一下这个损失函数的特点： 当y=1时，$ylog\\widehat{y}$ 这个部分的值是$log\\widehat{y}，\\widehat{y}表示预测分类$，$(1-y)log(1-\\widehat{y})$ 这个部分的值是0。所以最终的损失函数是：$L(\\widehat{y},y)=-log\\widehat{y}$，而我们要求损失函数越小越好，所以也就是要求 $-(log\\widehat{y})$ 越小越好，也就是要求 $\\widehat{y}$ 越大越好。而 $\\widehat{y}$和y一样，范围都是在0-1之间，所以 $\\widehat{y}$ 越接近于1（y=1），损失函数越小。 当y=0时，$ylog\\widehat{y}$ 这个部分的值是$0，\\widehat{y}表示预测分类$，$(1-y)log(1-\\widehat{y})$ 这个部分的值是 $log(1-\\widehat{y})$。所以最终的损失函数是：$L(\\widehat{y},y)=-(1-y)log(1-\\widehat{y})$，而我们要求损失函数越小越好，所以也就是要求 $-[(1-y)log(1-\\widehat{y})]$ 越小越好，也就是要求 $\\widehat{y}$ 越小越好，所以 $\\widehat{y}$ 越接近于0（y=0），损失函数越小。 2.代价函数（Cost function）或者叫 成本函数。 根据上面的损失函数可以得到整个训练集的代价函数： $J(w,b)=\\frac{1}{n}\\sum_{i=1}^{n}{L({\\widehat{y}}^i,y^i)}=-\\frac{1}{n}\\sum_{i=1}^{n}{[y^ilog{\\widehat{y}}^i+(1-y^i)log(1-{\\widehat{y}}^i)]}$ 由于损失函数越小，预测效果越好。所以代价函数也是越小越好。由于代价函数是一个凸函数，可以采用梯度下降法求到使得代价函数最小的时候的参数值(w,b)。 四、梯度上升/梯度下降要使得代价函数越小越好就是要 $\\frac{1}{n}\\sum_{i=1}^{n}{[y^ilog{\\widehat{y}}^i+(1-y^i)log(1-{\\widehat{y}}^i)]}$ 越大越好。为求最大值，这里采用梯度上升的方法。 1. 损失函数的梯度：首先还是要明确，损失函数是针对单独一个训练样本的。 由于 $L(\\widehat{y},y)=-[ylog\\widehat{y}+(1-y)log(1-\\widehat{y})]$ ，所以损失函数 $L(\\widehat{y},y)$ 对 $\\widehat{y}$ 求导可得： \\begin {aligned} d\\widehat{y}=\\frac{dL(\\widehat{y},y)}{d\\widehat{y}} &=-\\frac{y}{\\widehat{y}}+\\frac{1-y}{1-\\widehat{y}}\\\\\\ \\end {aligned}而 $\\widehat{y}=h(z)=\\frac{1}{1+e^{-z}}$，再利用链式求导法则，损失函数 $L(\\widehat{y},y)$ 对 $z$ 求导可得： \\begin {aligned}dz=\\frac{dL(\\widehat{y},y)}{dz} &=\\frac{dL}{d\\widehat{y}} \\cdot\\frac{d\\widehat{y}}{dz} \\\\\\ &=(-\\frac{y}{\\widehat{y}}+\\frac{1-y}{1-\\widehat{y}})\\cdot[\\widehat{y}(1-\\widehat{y})]\\\\\\ &=\\widehat{y}-y\\\\\\ \\end {aligned}amazing… 接着再求 $dw_j$，由于 $z=w^Tx+b$ ,利用链式法则可得： \\begin {aligned} dw_1=\\frac{\\partial L}{\\partial w_1} &=\\frac{dL}{dz} \\cdot \\frac{dz}{dw_1}\\\\\\ &=x_1 \\cdot dz\\\\\\ &=x_1 \\cdot (\\widehat{y}-y)\\\\\\ \\end {aligned}同理 $dw_2=x_2(\\widehat{y}-y)…dw_n=x_n(\\widehat{y}-y)$。 最后求db: $db=\\frac{dL}{dz} \\cdot \\frac{dz}{db}=dz=\\widehat{y}-y$ 在训练过程中我们要我们要不断更新参数w和b以使得损失函数最小，也就是梯度更新，梯度更新的逻辑是： $w_j:=w_j-\\alpha \\cdot dw_j$ $b:=b-\\alpha \\cdot db$ $\\alpha$ 在这里是学习速率 2. 代价函数的梯度上面已经得出了单个训练样本的梯度更新法，接着就看在整个训练集上如何使用梯度更新法。 由于 $\\widehat{y} = \\frac{1}{1+e^{-(w^Tx+b)}}$，所以 $dw_1^{(i)},dw_2^{(i)},…,dw_n^{(i)},d_b^{(i)}$ 分别表示第i个单个样本中对参数w向量中第j个分量$w_j$的导数以及对偏置b的导数。 令 $J(w,b)=\\frac{1}{n}\\sum_{i=1}^{n}{[y^ilog{\\widehat{y}}^i+(1-y^i)log(1-{\\widehat{y}}^i)]}$,则在整个训练集上,J(w,b)对 $w_j$的偏导数是： \\frac{\\partial J(w,b)}{\\partial w_j}=\\frac{1}{n}\\sum_{i=1}^{n}{\\frac{\\partial L(\\widehat{y}^{(i)},y)}{\\partial w_j}}由于对每个$w_j$都要进行梯度更新，所以我们先得到下面的伪代码： \\begin {aligned} &J=0;\\\\\\ &d_{w_1}=0,d_{w_2}=0,...d_{w_m}=0;\\\\\\ &d_b=0;\\\\\\ &for \\: i=1 \\: to \\: n://n个样本\\\\\\ &\\:\\:\\:\\:z^{(i)}=w^Tx{(i)}+b;\\\\\\ &\\:\\:\\:\\:\\widehat{y}^{i}=sigmoid(z^{i});\\\\\\ &\\:\\:\\:\\:J+=-[y^{i}log\\widehat{y}^{(i)}+(1-\\widehat{i}^{i})log(1-\\widehat{y}^{i})];\\\\\\ &\\:\\:\\:\\:dz^{(i)}=\\widehat{y}^{(i)}-y^{i};\\\\\\ &\\:\\:\\:\\:for \\: j=1 \\: to \\: m://m个参数\\\\\\ &\\:\\:\\:\\:\\:\\:\\:\\:dw_j+=x_jdz^{(i)};\\\\\\ &\\:\\:\\:\\:db+=dz^{(i)};\\\\\\ &J/=n;\\\\\\ &d_{w_1}/=n,d_{w_2}/=n,...d_{w_m}/=n;\\\\\\ &db/=n;\\\\\\ \\end{aligned} 注意这里$dw_j$没有上标，也训练集中的每个样本进行梯度运算的时候都是使用的一个全局的参数w。 在实际操作中，不建议使用for循环，可以进行向量化，使得运算更为迅速。 五、实现1. 数据准备testSet.txt 数据格式如下： 12345-0.017612 14.053064 0-1.395634 4.662541 1-0.752157 6.538620 0-1.322371 7.152853 0...... 数据没有实际意义。第一列是参数x1,第二列是参数x2，第三列是分类标签（0/1）。 假设Sigmoid函数的输入记为 z ，那么 $z=w_{0}+w_{1}x_{1} + w_{2}x_{2}$ ，其实$w_0$就是上面的参数b。为了方便将z表示成向量相乘的形式 $z=w^Tx$，可以添加一个值为1的变量$x_0$，于是前面的z就变形为： $z=w_{0}x_{0} +w_{1}x_{1} + w_{2}x_{2}$ 。下面代码中加载数据时手动插入一列1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: UTF-8 -*-import reimport numpy as npimport randomimport matplotlib.pyplot as plt\"\"\"从 testSet.txt 中加载数据\"\"\"def loadDataSet(): dataMat = [] #创建数据列表 labelMat = [] #创建标签列表 fr = open('testSet.txt') #打开文件 for line in fr.readlines(): #逐行读取 lineArr = line.strip().split() #去回车，放入列表 dataMat.append([1.0, float(lineArr[0]), float(lineArr[1])]) #添加数据(x,y) labelMat.append(int(lineArr[2])) #添加标签(分类结果) fr.close() #关闭文件 return dataMat, labelMat #返回\"\"\"绘制数据点图\"\"\"def plotDataSet(): dataMat, labelMat = loadDataSet() #加载数据集 dataArr = np.array(dataMat) #转换成numpy的array数组 n = np.shape(dataMat)[0] #数据个数 xcord1 = []; ycord1 = [] #正样本 xcord2 = []; ycord2 = [] #负样本 for i in range(n): #根据数据集标签进行分类 if int(labelMat[i]) == 1: xcord1.append(dataArr[i,1]); ycord1.append(dataArr[i,2]) #1为正样本 else: xcord2.append(dataArr[i,1]); ycord2.append(dataArr[i,2]) #0为负样本 fig = plt.figure() ax = fig.add_subplot(111) #添加subplot ax.scatter(xcord1, ycord1, s = 20, c = 'red', marker = 's',alpha=.5,label='1') #绘制1样本 ax.scatter(xcord2, ycord2, s = 20, c = 'green',alpha=.5,label='0') #绘制0样本 plt.legend() plt.title('DataSet') #绘制title plt.xlabel('x1'); plt.ylabel('x2') #绘制label plt.show() #显示if __name__ == '__main__': plotDataSet() 绘制结果： $z=w^Tx$ 这个方程未知的参数为 $w_{0},w_{1},w_{2}$ ，也就是我们需要求的回归系数(最优参数)。 2. 训练Logistic回归算法回顾一下上面得出的梯度更新公式：$w_j:=w_j-\\alpha \\cdot dw_j$，再对照伪代码，转化成python代码： 12345678910111213141516171819def sigmoid(inX): return 1.0 / (1 + np.exp(-inX))def gradAscent(dataMatIn, classLabels): dataMatrix = np.mat(dataMatIn) #变量转换成numpy的mat labelMat = np.mat(classLabels).transpose() #标签转换成numpy的mat,并进行转置 m, n = np.shape(dataMatrix) #返回dataMatrix的大小。m为行数,n为列数。 alpha = 0.001 #移动步长,也就是学习速率,控制更新的幅度。 maxCycles = 500 #最大迭代次数 weights = np.ones((n,1)) #weights就是要求的特征系数w，全部初始化为1 for k in range(maxCycles): h = sigmoid(dataMatrix * weights) #梯度上升矢量化公式 dY = labelMat - h weights = weights + alpha * dataMatrix.transpose() * dY #对w执行梯度更新 return weights.getA() #将矩阵转换为数组，返回权重数组if __name__ == '__main__': dataMat, labelMat = loadDataSet() print(gradAscent(dataMat, labelMat)) 运行结果： 123[[ 4.12414349] [ 0.48007329] [-0.6168482 ]] 也就是$w_0=4.12414349,w_1=0.48007329,w_2=-0.6168482$ 由于决策边界 $w^Tx=0$，可得 $w_0+w_1x_1+w_2x_2=0 =&gt; x_2=(-w_0-w_1x_1)/w_2$ 。顺便根据得出的特征值绘制一下预测函数的图像： 1234567891011121314151617181920212223242526def plotBestFit(weights): dataMat, labelMat = loadDataSet() #加载数据集 dataArr = np.array(dataMat) #转换成numpy的array数组 n = np.shape(dataMat)[0] #数据个数 xcord1 = []; ycord1 = [] #正样本 xcord2 = []; ycord2 = [] #负样本 for i in range(n): #根据数据集标签进行分类 if int(labelMat[i]) == 1: xcord1.append(dataArr[i,1]); ycord1.append(dataArr[i,2]) #1为正样本 else: xcord2.append(dataArr[i,1]); ycord2.append(dataArr[i,2]) #0为负样本 fig = plt.figure() ax = fig.add_subplot(111) #添加subplot ax.scatter(xcord1, ycord1, s = 20, c = 'red', marker = 's',alpha=.5)#绘制正样本 ax.scatter(xcord2, ycord2, s = 20, c = 'green',alpha=.5) #绘制负样本 x1 = np.arange(-3.0, 3.0, 0.1) x2 = (-weights[0] - weights[1] * x1) / weights[2] #w0+w1x1+w2x2=0 =&gt; x2=(-w0-w1x1)/w2 ax.plot(x1, x2) plt.title('BestFit') #绘制title plt.xlabel('x1'); plt.ylabel('x2') #绘制label plt.show() if __name__ == '__main__': dataMat, labelMat = loadDataSet() weights = gradAscent(dataMat, labelMat) plotBestFit(weights) 如图： 六、改进:随机梯度上升法1. 随机梯度算法上述算法，要进行maxCycles次循环，每次循环中矩阵会有mn次乘法计算，每次更新回归系数(最优参数)的时候，使用六所有的样本数据,所以时间复杂度（开销）是maxCyclesm*n，当数据量较大时，时间复杂度就会很大。因此，可以是用随机梯度上升法来进行算法改进，一次只用一个样本点去更新回归系数(最优参数)，这样就可以有效减少计算量了，这种方法就叫做随机梯度上升算法。 随机梯度上升法的思想是，每次只使用一个数据样本点来更新回归系数。这样就大大减小计算开销。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354\"\"\"改进后的随机梯度下降法\"\"\"def stocGradAscentBetter(dataMatrix, classLabels, numIter=150): m,n = np.shape(dataMatrix) #返回dataMatrix的大小。m为行数,n为列数。 weights = np.ones(n) #参数初始化 for j in range(numIter): dataIndex = list(range(m)) for i in range(m): alpha = 4/(1.0+j+i)+0.01 #降低alpha的大小，每次减小1/(j+i)。 randIndex = int(random.uniform(0,len(dataIndex))) #随机选取样本 h = sigmoid(sum(dataMatrix[randIndex]*weights)) #选择随机选取的一个样本，计算h error = classLabels[randIndex] - h #计算误差 weights = weights + alpha * error * np.array(dataMatrix[randIndex]) #更新回归系数,注意这里要转换为numpy.array才能正确运行 del(dataIndex[randIndex]) #删除已经使用的样本 return weightsdef plotBestFit(weights1,weights2): dataMat, labelMat = loadDataSet() #加载数据集 dataArr = np.array(dataMat) #转换成numpy的array数组 n = np.shape(dataMat)[0] #数据个数 xcord1 = []; ycord1 = [] #正样本 xcord2 = []; ycord2 = [] #负样本 for i in range(n): #根据数据集标签进行分类 if int(labelMat[i]) == 1: xcord1.append(dataArr[i,1]); ycord1.append(dataArr[i,2]) #1为正样本 else: xcord2.append(dataArr[i,1]); ycord2.append(dataArr[i,2]) #0为负样本 fig = plt.figure() plt.title('BestFit') plt.xlabel('x1'); plt.ylabel('x2') #绘制label ax = fig.add_subplot(111) #添加subplot ax.scatter(xcord1, ycord1, s = 20, c = 'red', marker = 's',alpha=.5)#绘制正样本 ax.scatter(xcord2, ycord2, s = 20, c = 'green',alpha=.5) #绘制负样本 x1 = np.arange(-3.0, 3.0, 0.1) x2 = (-weights1[0] - weights1[1] * x1) / weights1[2] ax.plot(x1, x2,label='GradAscent') x22 = (-weights2[0] - weights2[1] * x1) / weights2[2] ax.plot(x1, x22,label='StocGradAscent') plt.legend() plt.show()if __name__ == '__main__': dataMat, labelMat = loadDataSet() start1 = time.time() weights = gradAscent(dataMat, labelMat) start2 = time.time() weightsBetter = stocGradAscentBetter(dataMat, labelMat) plotBestFit(weights,weightsBetter) 改进后的效果和原先的差不多： 该算法第一个改进之处在于，alpha在每次迭代的时候都会调整 : alpha = 4/(1.0+j+i)+0.01，并且，虽然alpha会随着迭代次数不断减小，但永远不会减小到0，因为这里还存在一个常数项。必须这样做的原因是为了保证在多次迭代之后新数据仍然具有一定的影响。如果需要处理的问题是动态变化的，那么可以适当加大上述常数项，来确保新的值获得更大的回归系数。另一点值得注意的是，在降低alpha的函数中，alpha每次减少1/(j+i)，其中j是迭代次数，i是样本点的下标。 第二个改进的地方在于更新回归系数(最优参数)时，只使用一个样本点，并且选择的样本点是随机的，每次迭代不使用已经用过的样本点。这样的方法，就有效地减少了计算量，并保证了回归效果。 2. 回归系数与迭代次数的关系来直观地看一下回归系数是怎么样变化地： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091def gradAscent(dataMatIn, classLabels): weights_array = np.array([]) dataMatrix = np.mat(dataMatIn) #变量转换成numpy的mat labelMat = np.mat(classLabels).transpose() #标签转换成numpy的mat,并进行转置 m, n = np.shape(dataMatrix) #返回dataMatrix的大小。m为行数,n为列数。 alpha = 0.001 #移动步长,也就是学习速率,控制更新的幅度。 maxCycles = 500 #最大迭代次数 weights = np.ones((n,1)) #weights就是要求的特征系数w，全部初始化为1 for k in range(maxCycles): h = sigmoid(dataMatrix * weights) #梯度上升矢量化公式 dY = labelMat - h weights = weights + alpha * dataMatrix.transpose() * dY #对w执行梯度更新 weights_array = np.append(weights_array,weights) weights_array = weights_array.reshape(maxCycles,n) return weights.getA(),weights_array #将矩阵转换为数组，返回权重数组def stocGradAscentBetter(dataMatrix, classLabels, numIter=5): m,n = np.shape(dataMatrix) #返回dataMatrix的大小。m为行数,n为列数。 weights = np.ones(n) #参数初始化 weights_array = np.array([]) for j in range(numIter): dataIndex = list(range(m)) for i in range(m): alpha = 4/(1.0+j+i)+0.01 #降低alpha的大小，每次减小1/(j+i)。 randIndex = int(random.uniform(0,len(dataIndex))) #随机选取样本 h = sigmoid(sum(dataMatrix[randIndex]*weights)) #选择随机选取的一个样本，计算h error = classLabels[randIndex] - h #计算误差 weights = weights + alpha * error * np.array(dataMatrix[randIndex]) #更新回归系数,注意这里要转换为numpy.array才能正确运行 weights_array = np.append(weights_array,weights,axis=0) del(dataIndex[randIndex]) #删除已经使用的样本 return weights,weights_array\"\"\"绘制回归参数和迭代次数的关系\"\"\"def plotWeights(weights_array0,weights_array1): #将fig画布分隔成1行1列,不共享x轴和y轴,fig画布的大小为(13,8) #当nrow=3,nclos=2时,代表fig画布被分为六个区域,axs[0][0]表示第一行第一列 fig, axs = plt.subplots(nrows=3, ncols=2,sharex=False, sharey=False, figsize=(20,10)) x0 = np.arange(0, len(weights_array0), 1) #绘制w0与迭代次数的关系 axs[0][1].plot(x0,weights_array0[:,0]) axs0_title_text = axs[0][0].set_title('GradAscent:weight and times') axs0_ylabel_text = axs[0][0].set_ylabel('w0') plt.setp(axs0_title_text, size=20, color='black') plt.setp(axs0_ylabel_text, size=20, color='black') #绘制w1与迭代次数的关系 axs[1][1].plot(x0,weights_array0[:,1]) axs0_ylabel_text = axs[1][0].set_ylabel('w1') plt.setp(axs0_ylabel_text, size=20, color='black') #绘制w2与迭代次数的关系 axs[2][1].plot(x0,weights_array0[:,2]) axs0_xlabel_text = axs[2][0].set_xlabel('times') axs0_ylabel_text = axs[2][0].set_ylabel('w2') plt.setp(axs0_xlabel_text, size=20, color='black') plt.setp(axs0_ylabel_text, size=20, color='black') x1 = np.arange(0, len(weights_array1)/3, 1) #由于weights_array1是一个一行n列的数组，保存列所有的参数值，这里要处以参数的个数3 #绘制w0与迭代次数的关系 axs[0][0].plot(x1,weights_array1[0::3]) #[0::3]表示从位置0开始每隔3个取一位 axs1_title_text = axs[0][1].set_title('BetterStocGradAscent:weight and times') axs1_ylabel_text = axs[0][1].set_ylabel('w0') plt.setp(axs1_title_text, size=20, color='black') plt.setp(axs1_ylabel_text, size=20, color='black') #绘制w1与迭代次数的关系 axs[1][0].plot(x1,weights_array1[1::3]) #[1::3]表示从位置1开始每隔3个取一位 axs1_ylabel_text = axs[1][1].set_ylabel('w1') plt.setp(axs1_ylabel_text, size=20, color='black') #绘制w2与迭代次数的关系 axs[2][0].plot(x1,weights_array1[2::3]) #[2::3]表示从未知2开始每隔3个取一位 axs1_xlabel_text = axs[2][1].set_xlabel('times') axs1_ylabel_text = axs[2][1].set_ylabel('w2') plt.setp(axs1_xlabel_text, size=20, color='black') plt.setp(axs1_ylabel_text, size=20, color='black') plt.show() if __name__ == '__main__': dataMat, labelMat = loadDataSet() start1=time.time() weights0,weights_array0 = gradAscent(dataMat, labelMat) print(time.time()-start1) start2=time.time() weights1,weights_array1 = stocGradAscentBetter(np.array(dataMat), labelMat) print(time.time()-start2) plotWeights(weights_array0, weights_array1) plotBestFit(weights0,weights1) 注意 gradAscent和 stocGradAscentBetter 方法中分别添加了一个全局变量 weights_array 用来保存所有迭代出来地回归参数。 下面这是将 stocGradAscentBetter方法中的numIter参数设置成5的运行结果： 123运行时间：gradAscent ： 0.0238189697265625stocGradAscentBetter ： 0.009566068649291992 可以看到随机梯度上升算法的迭代时间比原始的梯度上升算法少很多，但是拟合效果却差别不大。并且回归参数也更快的趋于平稳。可以试着把numIter参数增大或减小，看看具体效果。 附： code 参考： 广义线性模型(Generalized Linear Models) Python3《机器学习实战》学习笔记（六）：Logistic回归基础篇之梯度上升算法 机器学习之Logistic回归与Python实现 机器学习实战笔记5(logistic回归) Logistic 回归损失函数 Logistic分类函数 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"LogisticRegression","slug":"LogisticRegression","permalink":"http://ai.wisim.me/tags/LogisticRegression/"}]},{"title":"朴素贝叶斯分类算法实践-垃圾邮件过滤器","slug":"2018-05-14_BayesPraticeEmail","date":"2018-05-13T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/05/14/2018-05-14_BayesPraticeEmail/","link":"","permalink":"http://ai.wisim.me/2018/05/14/2018-05-14_BayesPraticeEmail/","excerpt":"一、前言这个例子中，我们将了解朴素贝叶斯的一个最著名的应用：电子邮件垃圾过滤。 首先看一下使用朴素贝叶斯对电子邮件进行分类的步骤： 收集数据：提供文本文件。 准备数据：将文本文件解析成词条向量。 分析数据：检查词条确保解析的正确性。 训练算法：使用我们之前建立的trainNB0()函数。 测试算法：使用classifyNB()，并构建一个新的测试函数来计算文档集的错误率。 使用算法：构建一个完整的程序对一组文档进行分类，将错分的文档输出到屏幕上。","text":"一、前言这个例子中，我们将了解朴素贝叶斯的一个最著名的应用：电子邮件垃圾过滤。 首先看一下使用朴素贝叶斯对电子邮件进行分类的步骤： 收集数据：提供文本文件。 准备数据：将文本文件解析成词条向量。 分析数据：检查词条确保解析的正确性。 训练算法：使用我们之前建立的trainNB0()函数。 测试算法：使用classifyNB()，并构建一个新的测试函数来计算文档集的错误率。 使用算法：构建一个完整的程序对一组文档进行分类，将错分的文档输出到屏幕上。 二、实现1. 收集数据数据我已经为大家准备好了，可以在这里下载： 有两个文件夹ham和spam，ham文件夹下是正常邮件，spam文件夹下的txt文件为垃圾邮件。 2. 准备数据对于英文文本，我们可以以非字母、非数字作为符号进行切分，使用split函数即可。编写代码如下： 1234567891011121314151617181920212223242526272829import re\"\"\"接收一个文本里的字符串并将其解析为字符串列表\"\"\"def textParse(bigString): #将字符串转换为字符列表 listOfTokens = re.split(r'\\W*', bigString) #将特殊符号作为切分标志进行字符串切分，即非字母、非数字 return [tok.lower() for tok in listOfTokens if len(tok) &gt; 2] #除了单个字母，例如大写的I，其它单词变成小写\"\"\"将切分的实验样本词条整理成不重复的词条列表，也就是词汇表\"\"\"def createVocabList(dataSet): vocabSet = set([]) #创建一个空的不重复列表 for document in dataSet: vocabSet = vocabSet | set(document) #取并集 return list(vocabSet)if __name__ == '__main__': docList = []; classList = [] for i in range(1, 26): #遍历25个txt文件 wordList = textParse(open('email/spam/%d.txt' % i, 'r', encoding = \"ISO-8859-1\").read()) #读取每个垃圾邮件，并字符串转换成字符串列表 docList.append(wordList) classList.append(1) #标记垃圾邮件，1表示垃圾文件 wordList = textParse(open('email/ham/%d.txt' % i, 'r', encoding = \"ISO-8859-1\").read()) #读取每个非垃圾邮件，并字符串转换成字符串列表 docList.append(wordList) classList.append(0) #标记非垃圾邮件，1表示垃圾文件 vocabList = createVocabList(docList) #创建词汇表，不重复 print(vocabList) 这里注意要加上 encoding 参数，才能正确读取文本内容，否则会报错。运行之后就得到所有邮件文本的词汇表，这里就不展示里。 3. 构建词向量模型/词袋模型12345678910111213141516171819\"\"\"词向量模：根据vocabList词汇表，型创建词向量\"\"\"def setOfWords2Vec(vocabList, inputSet): returnVec = [0] * len(vocabList) #创建一个其中所含元素都为0的向量 for word in inputSet: #遍历每个词条 if word in vocabList: #如果词条存在于词汇表中，则置1 returnVec[vocabList.index(word)] = 1 return returnVec #返回文档向量\"\"\"词袋量模：根据vocabList词汇表，型创建词袋模型\"\"\"def bagOfWords2VecMN(vocabList, inputSet): returnVec = [0]*len(vocabList) #创建一个其中所含元素都为0的向量 for word in inputSet: #遍历每个词条 if word in vocabList: #如果词条存在于词汇表中，则计数加一 returnVec[vocabList.index(word)] += 1 return returnVec 两种模型里面选择一种即可，这里选择的是词向量模型 4. 训练分类器12345678910111213141516171819\"\"\"训练分类器\"\"\"def trainNB0(trainMatrix,trainCategory): numTrainDocs = len(trainMatrix) #计算训练的文档数目 numWords = len(trainMatrix[0]) #计算每篇文档的词条数 pAbusive = sum(trainCategory)/float(numTrainDocs) #文档属于侮辱类的概率 p0Num = np.ones(numWords); p1Num = np.ones(numWords) #创建numpy.ones数组,词条出现数初始化为1，拉普拉斯平滑 p0Denom = 2.0; p1Denom = 2.0 #分母初始化为2,拉普拉斯平滑 for i in range(numTrainDocs): if trainCategory[i] == 1: #统计属于垃圾邮件的条件概率所需的数据，即P(w0|1),P(w1|1),P(w2|1)··· p1Num += trainMatrix[i] p1Denom += sum(trainMatrix[i]) else: #统计属于正常邮件的条件概率所需的数据，即P(w0|0),P(w1|0),P(w2|0)··· p0Num += trainMatrix[i] p0Denom += sum(trainMatrix[i]) p1Vect = np.log(p1Num/p1Denom) #取对数，防止下溢出 p0Vect = np.log(p0Num/p0Denom) return p0Vect,p1Vect,pAbusive #返回属于正常邮件的条件概率数组，属于垃圾邮件的条件概率数组，文档属于垃圾邮件的概率 5. 测试分类器1234567def classifyNB(vec2Classify, p0Vec, p1Vec, pClass1): p1 = sum(vec2Classify * p1Vec) + np.log(pClass1) #对应元素相乘。logA * B = logA + logB，所以这里加上log(pClass1) p0 = sum(vec2Classify * p0Vec) + np.log(1.0 - pClass1) if p1 &gt; p0: return 1 else: return 0 6. 使用分类器123456789101112131415161718192021222324252627282930313233def spamTest(): docList = []; classList = []; fullText = [] for i in range(1, 26): #遍历25个txt文件 wordList = textParse(open('email/spam/%d.txt' % i, 'r').read()) #读取每个垃圾邮件，并字符串转换成字符串列表 docList.append(wordList) fullText.append(wordList) classList.append(1) #标记垃圾邮件，1表示垃圾文件 wordList = textParse(open('email/ham/%d.txt' % i, 'r').read()) #读取每个非垃圾邮件，并字符串转换成字符串列表 docList.append(wordList) fullText.append(wordList) classList.append(0) #标记非垃圾邮件，1表示垃圾文件 vocabList = createVocabList(docList) #创建词汇表，不重复 trainingSet = list(range(50)); testSet = [] #创建存储训练集的索引值的列表和测试集的索引值的列表 for i in range(10): #从50个邮件中，随机挑选出40个作为训练集,10个做测试集 randIndex = int(random.uniform(0, len(trainingSet))) #随机选取索索引值 testSet.append(trainingSet[randIndex]) #添加测试集的索引值 del(trainingSet[randIndex]) #在训练集列表中删除添加到测试集的索引值 trainMat = []; trainClasses = [] #创建训练集矩阵和训练集类别标签系向量 for docIndex in trainingSet: #遍历训练集 trainMat.append(setOfWords2Vec(vocabList, docList[docIndex])) #将生成的词集模型添加到训练矩阵中 trainClasses.append(classList[docIndex]) #将类别添加到训练集类别标签系向量中 p0V, p1V, pSpam = trainNB0(np.array(trainMat), np.array(trainClasses)) #训练朴素贝叶斯模型 errorCount = 0 #错误分类计数 for docIndex in testSet: #遍历测试集 wordVector = setOfWords2Vec(vocabList, docList[docIndex]) #测试集的词集模型 if classifyNB(np.array(wordVector), p0V, p1V, pSpam) != classList[docIndex]: #如果分类错误 errorCount += 1 #错误计数加1 print(\"分类错误的测试集：\",docList[docIndex]) print('错误率：%.2f%%' % (float(errorCount) / len(testSet) * 100))if __name__ == '__main__': spamTest() 运行结果： 1234分类错误的测试集： [&apos;yeah&apos;, &apos;ready&apos;, &apos;may&apos;, &apos;not&apos;, &apos;here&apos;, &apos;because&apos;, &apos;jar&apos;, &apos;jar&apos;, &apos;has&apos;, &apos;plane&apos;, &apos;tickets&apos;, &apos;germany&apos;, &apos;for&apos;]错误率：10.00%/Users/wxp/anaconda3/lib/python3.6/re.py:212: FutureWarning: split() requires a non-empty pattern match. return _compile(pattern, flags).split(string, maxsplit) 由于测试数据是随机选的几个邮件文本，所以每次运行结果都可能不一样。 参考： Python3《机器学习实战》学习笔记（五）：朴素贝叶斯实战篇之新浪新闻分类 附： code THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"NaiveBayes","slug":"NaiveBayes","permalink":"http://ai.wisim.me/tags/NaiveBayes/"}]},{"title":"线性回归算法","slug":"2018-05-14_LinearRegression","date":"2018-05-13T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/05/14/2018-05-14_LinearRegression/","link":"","permalink":"http://ai.wisim.me/2018/05/14/2018-05-14_LinearRegression/","excerpt":"","text":"THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"LinearRegression","slug":"LinearRegression","permalink":"http://ai.wisim.me/tags/LinearRegression/"}]},{"title":"朴素贝叶斯分类算法实践-言论过滤器","slug":"2018-05-10_BayesPraticeComment","date":"2018-05-09T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/05/10/2018-05-10_BayesPraticeComment/","link":"","permalink":"http://ai.wisim.me/2018/05/10/2018-05-10_BayesPraticeComment/","excerpt":"一、前言以在线社区留言为例。为了不影响社区的发展，我们要屏蔽侮辱性的言论，所以要构建一个快速过滤器，如果某条留言使用了负面或者侮辱性的语言，那么就将该留言标志为内容不当。过滤这类内容是一个很常见的需求。对此问题建立两个类型：侮辱类和非侮辱类，使用1和0分别表示。","text":"一、前言以在线社区留言为例。为了不影响社区的发展，我们要屏蔽侮辱性的言论，所以要构建一个快速过滤器，如果某条留言使用了负面或者侮辱性的语言，那么就将该留言标志为内容不当。过滤这类内容是一个很常见的需求。对此问题建立两个类型：侮辱类和非侮辱类，使用1和0分别表示。 二、实现1.准备工作：加载数据我们把文本看成单词向量或者词条向量，也就是说将句子转换为向量。考虑出现所有文档中的单词，再决定将哪些单词纳入词汇表或者说所要的词汇集合，然后必须要将每一篇文档转换为词汇表上的向量。简单起见，我们先假设已经将本文切分完毕，存放到列表中，并对词汇向量进行分类标注。编写代码如下： 12345678910111213141516# -*- coding: UTF-8 -*-def loadDataSet(): postingList=[['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'], #切分的词条 ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'], ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'], ['stop', 'posting', 'stupid', 'worthless', 'garbage'], ['mr', 'licks', 'ate', 'my', 'steak', 'how', 'to', 'stop', 'him'], ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']] classVec = [0,1,0,1,0,1] #类别标签向量，1代表侮辱性词汇，0代表不是 return postingList,classVecif __name__ == '__main__': postingLIst, classVec = loadDataSet() for each in postingLIst: print(each) print(classVec) 我们已经知道贝叶斯分类属于监督学习算法，所以这里的训练数据是6个词条和对应的类别。 我们最终要判断某一个测试词条是否属于侮辱分类是根据之前文章朴素贝叶斯分类算法原理中的贝叶斯公式得到结果，也就是如下公式： (1).$P(词条属于侮辱类|测试词条中每个词汇的分类) = \\frac{P(词条中每个词汇的分类|词条属于侮辱类)}{P(词条中每个词汇的分类)}P(词条属于侮辱类)$ (2).$P(词条属于非侮辱类|测试词条中每个词汇的分类) = \\frac{P(词条中每个词汇的分类|词条属于非侮辱类)}{P(词条中每个词汇的分类)}P(词条属于非侮辱类)$ 拿（1）公式举例，P(词条属于侮辱类|测试词条中每个词汇的分类)是要求的结果，P(词条中每个词汇的分类|词条属于侮辱类)可以计算出来，P(词条中每个词汇的分类)是提前计算好的，P(词条属于侮辱类)也是已知的0.5。最终计算结果，比较两个结果大小，值更大就表示测试词条属于该类。 2.再创建一个词汇表，并将切分好的词条转换为词条向量。1234567891011121314151617181920212223242526272829303132333435\"\"\"根据原始词条创建一个包含所有词汇且不重复的词汇表\"\"\"def createVocabList(dataSet): vocabSet = set([]) #创建一个空的不重复列表 for document in dataSet: vocabSet = vocabSet | set(document) #取并集 return list(vocabSet)\"\"\"创建一个和词汇表相同大小的列表，标记出输入词条inputSet中的词在词汇表中的位置。如果存在就是1，不存在就是0。\"\"\"def setOfWords2Vec(vocabList, inputSet): returnVec = [0] * len(vocabList) #创建一个其中所含元素都为0的向量 for word in inputSet: #遍历每个词条 if word in vocabList: #如果词条存在于词汇表中，则置1 returnVec[vocabList.index(word)] = 1 else: print(\"the word: %s is not in my Vocabulary!\" % word) return returnVec #返回文档向量if __name__ == '__main__': #1. 加载数据 print('postingList:') postingList, classVec = loadDataSet() for each in postingList: print(each) print('classVec:\\n',classVec) #2. 创建词汇表 myVocabList = createVocabList(postingList) print('myVocabList:\\n',myVocabList) #3. 创建词条向量 trainMat = [] for postinDoc in postingList: trainMat.append(setOfWords2Vec(myVocabList, postinDoc)) print('trainMat:\\n', trainMat) 运行结果： 1234567891011121314151617181920postingList:[&apos;my&apos;, &apos;dog&apos;, &apos;has&apos;, &apos;flea&apos;, &apos;problems&apos;, &apos;help&apos;, &apos;please&apos;][&apos;maybe&apos;, &apos;not&apos;, &apos;take&apos;, &apos;him&apos;, &apos;to&apos;, &apos;dog&apos;, &apos;park&apos;, &apos;stupid&apos;][&apos;my&apos;, &apos;dalmation&apos;, &apos;is&apos;, &apos;so&apos;, &apos;cute&apos;, &apos;I&apos;, &apos;love&apos;, &apos;him&apos;][&apos;stop&apos;, &apos;posting&apos;, &apos;stupid&apos;, &apos;worthless&apos;, &apos;garbage&apos;][&apos;mr&apos;, &apos;licks&apos;, &apos;ate&apos;, &apos;my&apos;, &apos;steak&apos;, &apos;how&apos;, &apos;to&apos;, &apos;stop&apos;, &apos;him&apos;][&apos;quit&apos;, &apos;buying&apos;, &apos;worthless&apos;, &apos;dog&apos;, &apos;food&apos;, &apos;stupid&apos;]classVec: [0, 1, 0, 1, 0, 1]myVocabList: [&apos;food&apos;, &apos;has&apos;, &apos;to&apos;, &apos;quit&apos;, &apos;stupid&apos;, &apos;help&apos;, &apos;park&apos;, &apos;so&apos;, &apos;how&apos;, &apos;love&apos;, &apos;not&apos;, &apos;I&apos;, &apos;ate&apos;, &apos;my&apos;, &apos;licks&apos;, &apos;dalmation&apos;, &apos;flea&apos;, &apos;him&apos;, &apos;worthless&apos;, &apos;take&apos;, &apos;steak&apos;, &apos;cute&apos;, &apos;buying&apos;, &apos;stop&apos;, &apos;mr&apos;, &apos;garbage&apos;, &apos;dog&apos;, &apos;is&apos;, &apos;posting&apos;, &apos;problems&apos;, &apos;maybe&apos;, &apos;please&apos;]trainMat: [[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]] 从运行结果可以看出，postingList 是原始的词条列表。 myVocabList 是词汇表。 myVocabList 是所有单词出现的集合，没有重复的元素。词汇表 是用来干什么的？没错，它是用来将词条 向量化 的，myVocabList中的一个位置上的单词在某一个原始词条中出现过一次，那么就在相应位置记作1，如果没有出现就在相应位置记作0。这样就构成了一个词条向量。 trainMat 是所有的词条向量组成的列表。它里面存放的是根据myVocabList向量化的词条向量。 我们已经得到了词条向量。接下来，我们就可以通过词条向量训练朴素贝叶斯分类器。 3.训练数据1234567891011121314151617181920212223242526272829303132333435363738394041\"\"\"根据原始词条和对应分类结果训练贝叶斯分类\"\"\"def trainNB0(trainMatrix,trainCategory): numTrainDocs = len(trainMatrix) #计算训练的文档数目 numWords = len(trainMatrix[0]) #计算每篇文档的词条数 pAbusive = sum(trainCategory)/float(numTrainDocs) #文档属于侮辱类的概率 p0Num = np.zeros(numWords); p1Num = np.zeros(numWords) #创建numpy.zeros数组,词条出现数初始化为0 p0Denom = 0.0; p1Denom = 0.0 #分母初始化为0 for i in range(numTrainDocs): if trainCategory[i] == 1: #统计属于侮辱类的条件概率所需的数据，即P(w0|1),P(w1|1),P(w2|1)··· p1Num += trainMatrix[i] p1Denom += sum(trainMatrix[i]) else: #统计属于非侮辱类的条件概率所需的数据，即P(w0|0),P(w1|0),P(w2|0)··· p0Num += trainMatrix[i] p0Denom += sum(trainMatrix[i]) p1Vect = p1Num/p1Denom p0Vect = p0Num/p0Denom return p0Vect,p1Vect,pAbusive #返回属于非侮辱类的条件概率数组p0Vect，属于侮辱类的条件概率数组p1Vect，词条属于侮辱类的概率pAbusiveif __name__ == '__main__': print('postingList:') postingList, classVec = loadDataSet() for each in postingList: print(each) print('classVec:\\n',classVec) myVocabList = createVocabList(postingList) print('myVocabList:\\n',myVocabList) trainMat = [] for postinDoc in postingList: trainMat.append(setOfWords2Vec(myVocabList, postinDoc)) print('trainMat:\\n', trainMat) p0V, p1V, pAb = trainNB0(trainMat, classVec) print('p0V:\\n', p0V) #p0V: 属于非侮辱类的条件概率数组 print('p1V:\\n', p1V) #p1V: 属于侮辱类的条件概率数组 print('classVec:\\n', classVec) #classVec: 原始词条分类结果 print('pAb:\\n', pAb) #pAb: 文档属于侮辱类的概率 运行结果如下: 123456789101112131415161718p0V: [0. 0.04166667 0.04166667 0. 0. 0.04166667 0. 0.04166667 0.04166667 0.04166667 0. 0.04166667 0.04166667 0.125 0.04166667 0.04166667 0.04166667 0.08333333 0. 0. 0.04166667 0.04166667 0. 0.04166667 0.04166667 0. 0.04166667 0.04166667 0. 0.04166667 0. 0.04166667]p1V: [0.05263158 0. 0.05263158 0.05263158 0.15789474 0. 0.05263158 0. 0. 0. 0.05263158 0. 0. 0. 0. 0. 0. 0.05263158 0.10526316 0.05263158 0. 0. 0.05263158 0.05263158 0. 0.05263158 0.10526316 0. 0.05263158 0. 0.05263158 0. ]classVec: [0, 1, 0, 1, 0, 1]pAb: 0.5 p0V存放的是每个单词属于类别0，也就是非侮辱类词汇的概率。比如p0V的倒数第6个概率，就是stupid这个单词属于非侮辱类的概率为0。 同理，p1V的倒数第6个概率，就是stupid这个单词属于侮辱类的概率为0.15789474，也就是约等于15.79%的概率。显而易见，这个单词属于侮辱类。 pAb是所有侮辱类的样本占所有样本的概率，从classVec中可以看出，共有3个侮辱类，3个非侮辱类。所以侮辱类的概率是0.5。 因此p0V存放的就是P(him|非侮辱类) = 0.0833、P(is|非侮辱类) = 0.0417，一直到P(dog|非侮辱类) = 0.0417，这些单词的条件概率。表示词条是非侮辱类的前提下，这些单词是属于非侮辱类的概率。 同理，p1V存放的就是在词条属于侮辱类的前提下，各个单词在属于侮辱类的条件概率。 pAb就是先验概率。 已经训练好分类器，接下来，使用分类器进行分类。 4.使用贝叶斯分类器12345678910111213141516171819202122232425262728293031323334def classifyNB(vec2Classify, p0Vec, p1Vec, pClass1): p1 = reduce(lambda x,y:x*y, vec2Classify * p1Vec) * pClass1 #对应元素相乘 p0 = reduce(lambda x,y:x*y, vec2Classify * p0Vec) * (1.0 - pClass1) print('p0:',p0) print('p1:',p1) if p1 &gt; p0: return 1 else: return 0def testingNB(): listOPosts,listClasses = loadDataSet() #创建实验样本 myVocabList = createVocabList(listOPosts) #创建词汇表 trainMat=[] for postinDoc in listOPosts: trainMat.append(setOfWords2Vec(myVocabList, postinDoc)) #将实验样本向量化 p0V,p1V,pAb = trainNB0(np.array(trainMat),np.array(listClasses)) #训练朴素贝叶斯分类器 testEntry = ['love', 'my', 'dalmation'] #测试样本1 thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry)) #测试样本向量化 if classifyNB(thisDoc,p0V,p1V,pAb): print(testEntry,'属于侮辱类') #执行分类并打印分类结果 else: print(testEntry,'属于非侮辱类') #执行分类并打印分类结果 testEntry = ['stupid', 'garbage'] #测试样本2 thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry)) #测试样本向量化 if classifyNB(thisDoc,p0V,p1V,pAb): print(testEntry,'属于侮辱类') #执行分类并打印分类结果 else: print(testEntry,'属于非侮辱类') #执行分类并打印分类结果if __name__ == '__main__': testingNB() 这里的classifyNB函数还是根据下面两个公式得出的，由于只要比较大小，两个公式中 P(词条中每个词汇的分类) 值相同，所以只要计算比较P(词条中每个词汇的分类|词条属于侮辱类)P(词条属于侮辱类)和P(词条中每个词汇的分类|词条属于非侮辱类)P(词条属于非侮辱类)的大小。 (1).$P(词条属于侮辱类|测试词条中每个词汇的分类) = \\frac{P(词条中每个词汇的分类|词条属于侮辱类)}{P(词条中每个词汇的分类)}P(词条属于侮辱类)$ (2).$P(词条属于非侮辱类|测试词条中每个词汇的分类) = \\frac{P(词条中每个词汇的分类|词条属于非侮辱类)}{P(词条中每个词汇的分类)}P(词条属于非侮辱类)$ 计算的结果：123456p0: 0.0p1: 0.0[&apos;love&apos;, &apos;my&apos;, &apos;dalmation&apos;] 属于非侮辱类p0: 0.0p1: 0.0[&apos;stupid&apos;, &apos;garbage&apos;] 属于非侮辱类 但是这样写的算法无法进行分类，p0和p1的计算结果都是0，最终分类都是非侮辱类，显然结果错误。这是为什么呢？之前已经提过，利用贝叶斯分类器对文档进行分类时，要计算多个概率的乘积以获得文档属于某个类别的概率，即计算 p(w_{0}|1)p(w_{1}|1)p(w_{2}|1)…p(w_{n}|1) 。如果其中有一个概率值为0，那么最后的计算结果也为0。 5.平滑处理为了降低这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2。这种做法就叫做拉普拉斯平滑(Laplace Smoothing)又被称为加1平滑，是比较常用的平滑方法，它就是为了解决0概率问题。 除此之外，另外一个遇到的问题就是下溢出，这是由于太多很小的数相乘造成的。学过数学的人都知道，两个小数相乘，越乘越小，这样就造成了下溢出。在程序中，在相应小数位置进行四舍五入，计算结果可能就变成0了。为了解决这个问题，对乘积结果取自然对数。通过求对数可以避免下溢出或者浮点数舍入导致的错误。同时，采用自然对数进行处理不会有任何损失。 根据上面这两种改进方法，改进之后的trainNB0方法和classifyNB方法： 1234567891011121314151617181920212223242526def trainNB0(trainMatrix,trainCategory): numTrainDocs = len(trainMatrix) #计算训练的文档数目 numWords = len(trainMatrix[0]) #计算每篇文档的词条数 pAbusive = sum(trainCategory)/float(numTrainDocs) #文档属于侮辱类的概率 p0Num = np.ones(numWords); p1Num = np.ones(numWords) #创建numpy.ones数组,词条出现数初始化为1，拉普拉斯平滑 p0Denom = 2.0; p1Denom = 2.0 #分母初始化为2,拉普拉斯平滑 for i in range(numTrainDocs): if trainCategory[i] == 1: #统计属于侮辱类的条件概率所需的数据，即P(w0|1),P(w1|1),P(w2|1)··· p1Num += trainMatrix[i] p1Denom += sum(trainMatrix[i]) else: #统计属于非侮辱类的条件概率所需的数据，即P(w0|0),P(w1|0),P(w2|0)··· p0Num += trainMatrix[i] p0Denom += sum(trainMatrix[i]) p1Vect = np.log(p1Num/p1Denom) #取对数，防止下溢出 p0Vect = np.log(p0Num/p0Denom) return p0Vect,p1Vect,pAbusive #返回属于侮辱类的条件概率数组，属于非侮辱类的条件概率数组，文档属于侮辱类的概率def classifyNB(vec2Classify, p0Vec, p1Vec, pClass1): p1 = sum(vec2Classify * p1Vec) + np.log(pClass1) #对应元素相乘。logA * B = logA + logB，所以这里加上log(pClass1) p0 = sum(vec2Classify * p0Vec) + np.log(1.0 - pClass1) print('p0:',p0) print('p1:',p1) if p1 &gt; p0: return 1 else: return 0 最终计算出来的分类结果： 123456p0: -7.694848072384611p1: -9.826714493730215[&apos;love&apos;, &apos;my&apos;, &apos;dalmation&apos;] 属于非侮辱类p0: -7.20934025660291p1: -4.702750514326955[&apos;stupid&apos;, &apos;garbage&apos;] 属于侮辱类 参考： Python3《机器学习实战》学习笔记（四）：朴素贝叶斯基础篇之言论过滤器 Python3《机器学习实战》学习笔记（五）：朴素贝叶斯实战篇之新浪新闻分类 附： code THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"NaiveBayes","slug":"NaiveBayes","permalink":"http://ai.wisim.me/tags/NaiveBayes/"}]},{"title":"Numpy 常用功能简介","slug":"2018-05-03_Numpy","date":"2018-05-02T16:00:00.000Z","updated":"2018-09-17T07:56:27.000Z","comments":true,"path":"2018/05/03/2018-05-03_Numpy/","link":"","permalink":"http://ai.wisim.me/2018/05/03/2018-05-03_Numpy/","excerpt":"一、创建ndarray123456789101112131415161718192021222324252627282930import numpy as npa = np.array([1, 2, 3, 4])b = np.array([[1, 2, 3, 4],[4, 5, 6, 7], [7, 8, 9, 10]])# np.ones(x):创建一个长度为x，且元素全为1的ndarrayc = np.ones(2,dtype = np.int)[1, 1]# np.ones(x，y):创建一个长度为x行y列，且元素全为1的ndarrayd = np.ones((3,2))[[1., 1.], [1., 1.], [1., 1.]]# np.zeros(x,y):创建一个x行y列且元素全为0的ndarraye = np.zeros((3,2))[[0., 0.], [0., 0.], [0., 0.]]# np.empty(x,y):创建一个x行y列且未初始化的ndarray(随机数填充数据)f = np.empty((1,2), dtype = int)[[4607182418800017408, 4607182418800017408]]# 使用 np.arange 生成连续元素的ndarrayg = np.arange(6) #从0到6，默认间隔(步长)为1[0, 1, 2, 3, 4, 5]h = np.arange(0,6,2) #从0到6，间隔为2，不包括6[0, 2, 4]","text":"一、创建ndarray123456789101112131415161718192021222324252627282930import numpy as npa = np.array([1, 2, 3, 4])b = np.array([[1, 2, 3, 4],[4, 5, 6, 7], [7, 8, 9, 10]])# np.ones(x):创建一个长度为x，且元素全为1的ndarrayc = np.ones(2,dtype = np.int)[1, 1]# np.ones(x，y):创建一个长度为x行y列，且元素全为1的ndarrayd = np.ones((3,2))[[1., 1.], [1., 1.], [1., 1.]]# np.zeros(x,y):创建一个x行y列且元素全为0的ndarraye = np.zeros((3,2))[[0., 0.], [0., 0.], [0., 0.]]# np.empty(x,y):创建一个x行y列且未初始化的ndarray(随机数填充数据)f = np.empty((1,2), dtype = int)[[4607182418800017408, 4607182418800017408]]# 使用 np.arange 生成连续元素的ndarrayg = np.arange(6) #从0到6，默认间隔(步长)为1[0, 1, 2, 3, 4, 5]h = np.arange(0,6,2) #从0到6，间隔为2，不包括6[0, 2, 4] 1234567# 使用 np.linspace(start, stop, num, endpoint, retstep, dtype) 生成ndarray,num:生成ndarray的元素个数a = np.linspace(1.0, 2.0, num = 10)[1.,1.11111111,1.22222222,1.33333333,1.44444444,1.55555556,1.66666667,1.77777778,1.88888889,2.]# np.logspace(start, stop, num, endpoint, base, dtype) ： 返回一个 ndarray 对象，其实就是linespace生成的元素值对应的base作为底数的幂y = np.logspace(1.0, 2.0, num = 10)[ 10.,12.91549665,16.68100537,21.5443469,27.82559402,35.93813664,46.41588834,59.94842503,77.42636827,100.] 我们来看一下上面生成的两个ndarray所画出的函数是不是10的幂函数图像： 对应代码：123456789plt.subplot(2, 1, 1)plt.xlabel('linspace')plt.ylabel('logspace')plt.plot(a,b,'b-',label='logspace')plt.legend()plt.subplot(2, 1, 2)plt.plot(a,np.power(10,a),'r-',label='10^a')plt.legend()plt.show() 12345678910# np.fromiter(iterable, dtype, count = -1) : 从任何可迭代对象构建一个ndarray对象list = range(5)it = iter(list)# 使用迭代器创建 ndarrayx = np.fromiter(it, dtype = int)[0 1 2 3 4]# np.frombuffer():此函数将缓冲区解释为一维ndarray。但是参数是String类型的会报错误，原因如下：https://stackoverflow.com/questions/43362986/numpy-frombuffer-attributeerror-str-object-has-no-attribute-buffer 二、ndarray的属性1234567891011121314151617181920212223# array.size ndarray元素个数a.size4# array.dtype ndarray元素的类型a.dtypedtype('int64')# array.itemsize ndarray每个元素所占字节大小a.itemsize8 # int64类型大小为8字节# array.ndim ndarray纬度a.nidm1b.ndim2# array.shape ：ndarray各个维度的长度a.shape(4,)b.shape(3,4) 三、ndarray操作单个ndarray操作123456789101112131415161718192021222324252627282930313233# array.sum()：求ndarray所有元素的和值。也可以加上axis参数，求各行或者各列的元素和值# array.min()：求ndarray所有元素中的最小值。也可以加上axis参数，求各行或者各列的元素最小值# array.max()：求ndarray所有元素中的最大值。也可以加上axis参数，求各行或者各列的元素最大值# array.shape = x,y : 通过改变ndarray的shape值，可以改变ndarray的行数和列数.（总数必须一致）b.shape = 4,3[[ 1, 2, 3], [ 4, 4, 5], [ 6, 7, 7], [ 8, 9, 10]]# array.reshape(x,y) 的作用和指定shape值的效果一样，但是会返回一个新的ndarray，并且这个ndarray和原ndarray共享内存，无论修改哪一个ndarray都会引起另外一个ndarray的变化b.reshape(3,4)# array.resize(x,y) 用于原地设置形状,也就是修改的是原ndarray。而reshape和shape都是修改之后返回一个新ndarrayb.resize(2,6)[[ 1, -1, 4, 6, 7, 9], [ 2, 4, 5, 7, 8, 10]]# array.ravel() 将ndarray展开，创建视图,视图和原ndarray共享内存，无论修改哪一个ndarray都会引起另外一个ndarray的变化i = b.ravel()[ 1, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10]# array.flatten() 将ndarray展开，创建副本,副本修改不影响原ndarray变化j = b.flatten()[ 1, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10]# array.transpose() 用于转置矩阵k = b.transpose()[[ 1, 4, 7], [ 2, 5, 8], [-1, 6, 9], [ 4, 7, 10]] 多个ndarray操作1234567891011121314151617181920# np.vstack(a1,a2) : 纵向（vertical）合并两个ndarraya1 = np.array([1,2,3])a2 = np.array([4,5,6])np.vstack((a1,a2))[[1, 2, 3], [4, 5, 6]]# np.hstack(a1,a2) : 横向（horizontal）合并两个ndarraya1 = np.array([1,2,3])a2 = np.array([4,5,6])np.hstack((a1,a2))[1, 2, 3, 4, 5, 6]# np.stach((a1,a2),axis = 1) : axis可以设置堆叠的维度,默认是0，效果和vstack相同，如果设置为1，则是vstack的转置矩阵。a1 = np.array([1,2,3])a2 = np.array([4,5,6])np.stack((a1,a2),axis = 1)[[1, 4], [2, 5], [3, 6]] ndarray分割123456789101112131415# np.vsplit(a,num) : 纵向分割a= np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])np.vsplit(a,3)[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]# np.hsplit(a,num) : 横向分割a= np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])np.hsplit(a,3)[array([[0],[3],[6]]), array([[1],[4],[7]]), array([[2],[5],[8]])]# 也可使用np.split(a, 3, axis=1) 指定axis作为分割方向 四、矩阵运算12345678910111213141516171819202122232425262728293031323334353637# ndarray相乘# *操作符：每个位置的元素对应相乘.术语广播a = np.array([[2,3],[3,4]])b = np.array([[3,4],[5,6]])a * b[[ 6, 12], [15, 24]]a = np.array([[2,3],[3,4]])b = np.array([[3,4],[5,6]])a+b[[ 5, 7], [ 8, 10]]a = np.array([[2,3],[3,4]])b = np.array([[3,4],[5,6]])a-b[[-1, -1], [-2, -2]]a = np.array([[2,3],[3,4]])b = np.array([[3,4],[5,6]])a&gt;b[[False, False], [False, False]]# dot操作符：按照矩阵乘法规则相乘a.dot(b) # 或者np.dot(a,b)[[21, 26], [29, 36]]# 使用 linalg 模块求逆矩阵。import numpy.linalg as nlax = np.array([[1,1],[1,2]])y = nla.inv(x)[[ 2., -1.], [-1., 1.]] linalg 还有其他多种功能。比如：trace:对角线元素之和， det:计算矩阵行列式，等。 五、ndarray数组的基本索引和切片ndarray的基本索引1234x = np.array([[1,2],[3,4],[5,6]])x[0] # [1, 2]x[0][1] # 2 ,普通python数组的索引x[0,1] # 2 ,同x[0][1],ndarray数组的索引 ndarray的切片123456789x = np.array([1,2,3,4,5])x[1:3] # [2, 3], 左闭右开的区间x[:3] # [1,2,3], 左边默认为 0，仍然是左闭右开x[1:] # [2,3,4,5], 右边默认为数组的长度，仍然是左闭右开x = np.array([[1,2],[3,4],[5,6]])x[:2] # [[1, 2],[3, 4]],x[:2,:1] # [[1],[3]]x[:2,:1] = 0 # 用标量赋值,x=[[0, 2],[0, 4],[5, 6]] 六、其他用法12345678# 使用 where 进行 ndarray 的条件应用cond = np.array([True,False,True,False])x = np.where(cond,-2,2)[-2, 2, -2, 2]cond = np.array([1,2,3,4])x = np.where(cond&gt;2,-2,2)[ 2, 2, -2, -2] THE END.","categories":[{"name":"Numpy","slug":"Numpy","permalink":"http://ai.wisim.me/categories/Numpy/"}],"tags":[{"name":"Numpy","slug":"Numpy","permalink":"http://ai.wisim.me/tags/Numpy/"}]},{"title":"Matplotlib","slug":"2018-05-03_Matplotlib","date":"2018-05-02T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/05/03/2018-05-03_Matplotlib/","link":"","permalink":"http://ai.wisim.me/2018/05/03/2018-05-03_Matplotlib/","excerpt":"画一个简单的图形1234567import matplotlib.pyplot as pltimport numpy as npx = np.linspace(0, 2 * np.pi, 50) #生成一个包含 50 个元素的数组，这 50 个元素均匀的分布在 [0, 2pi] 的区间上。plt.plot(x, np.sin(x)) # 如果没有第一个参数 x，图形的 x 坐标默认为数组的索引plt.plot(x, np.sin(x), x, np.sin(2 * x)) #绘制两个数据集plt.show() # 显示图形","text":"画一个简单的图形1234567import matplotlib.pyplot as pltimport numpy as npx = np.linspace(0, 2 * np.pi, 50) #生成一个包含 50 个元素的数组，这 50 个元素均匀的分布在 [0, 2pi] 的区间上。plt.plot(x, np.sin(x)) # 如果没有第一个参数 x，图形的 x 坐标默认为数组的索引plt.plot(x, np.sin(x), x, np.sin(2 * x)) #绘制两个数据集plt.show() # 显示图形 自定义图形的外观1234x = np.linspace(0, 2 * np.pi, 50)plt.plot(x, np.sin(x), 'r-o', x, np.cos(x), 'g--') #'r' 和 'g' 代表线条的颜色，'-o' 代表包含实心点标记的实线，'--' 代表虚线plt.show() 使用子图，可以在一个窗口绘制多张图。123456x = np.linspace(0, 2 * np.pi, 50)plt.subplot(2, 1, 1) # （行，列，活跃区）plt.plot(x, np.sin(x), 'r')plt.subplot(2, 1, 2) #在调用 plot() 函数之前需要先调用 subplot() 函数。plt.plot(x, np.cos(x), 'g')plt.show() 简单散点图1234x = np.linspace(0, 2 * np.pi, 50)y = np.sin(x)plt.scatter(x,y) #通过 plot 命令并将线的样式设置为 'bo' 也可以实现同样的效果。实际设置'o'就可以，'bo'表示蓝色的点。plt.show() 直方图123x = np.random.randn(1000)plt.hist(x, 50)plt.show() 彩色映射散点图1234567x = np.random.rand(1000)y = np.random.rand(1000)size = np.random.rand(1000) * 50colour = np.random.rand(1000)plt.scatter(x, y, size, colour)plt.colorbar() #加了一个颜色栏。plt.show() 添加标题，坐标轴标记和图例12345678x = np.linspace(0, 2 * np.pi, 50)plt.plot(x, np.sin(x), 'r-x', label='Sin(x)')plt.plot(x, np.cos(x), 'g-^', label='Cos(x)')plt.legend() # 应用label，展示图例plt.xlabel('Rads') # 给 x 轴添加标签plt.ylabel('Amplitude') # 给 y 轴添加标签plt.title('Sin and Cos Waves') # 添加图形标题plt.show() 饼图1234567891011121314slices = [7,2,2,13]activities = ['sleeping','eating','working','playing']cols = ['c','m','r','b']plt.pie(slices, labels=activities, colors=cols, startangle=90, shadow= True, explode=(0,0.1,0,0), autopct='%1.1f%%')plt.title('Interesting Graph\\nCheck it out')plt.show() 从文件读取数据123456789101112131415161718192021import numpy as npimport matplotlib.pyplot as pltimport random%matplotlib inlineimport csvx = []y = []with open('example.txt','r') as csvfile: plots = csv.reader(csvfile, delimiter=',') for row in plots: x.append(int(row[0])) y.append(int(row[1]))plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\\nCheck it out')plt.legend()plt.show() 附：code THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://ai.wisim.me/tags/Matplotlib/"}]},{"title":"基本概念","slug":"2018-05-02_BaseConcept","date":"2018-05-01T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/05/02/2018-05-02_BaseConcept/","link":"","permalink":"http://ai.wisim.me/2018/05/02/2018-05-02_BaseConcept/","excerpt":"假设空间假设空间是指所有可能的能满足样本输入和输出的假设函数h(x)的集合。注意，假设函数一定是一个无穷大的集合。也就是说，如果样本是一串有穷的离散点（xi，yi），i属于1到N，那么能够拟合这这些点的无穷多个函数都是可能的假设函数。 那么，怎样的假设函数是最合理呢？这就涉及到归纳偏好的概念了。","text":"假设空间假设空间是指所有可能的能满足样本输入和输出的假设函数h(x)的集合。注意，假设函数一定是一个无穷大的集合。也就是说，如果样本是一串有穷的离散点（xi，yi），i属于1到N，那么能够拟合这这些点的无穷多个函数都是可能的假设函数。 那么，怎样的假设函数是最合理呢？这就涉及到归纳偏好的概念了。 分类 ： 输出值如果是不连续的学习算法称为分类器（classifier）。 回归 ： 输出值连续的学习算法称为回归函数（regression function）。 监督学习 广义线性模型(Generalized Linear Models) 线性和二次判别分析(Linear and Quadratic Discriminant Analysis) 核岭回归(Kernel ridge regression) SVM(Support Vector Machines) 随机梯度下降法(Stochastic Gradient Descent) 最邻近算法(Nearest Neighbors) 高斯过程(Gaussian Processes) 交叉分解(Cross decomposition) 朴素贝叶斯(Naive Bayes) 决策树(Decision Trees) 集成方法(Ensemble methods) 多分类和多标签算法(Multiclass and multilabel algorithms) 特征选择(Feature selection) 半监督(Semi-Supervised) 序回归(Isotonic regression) Probability calibration 有监督神经网络模型(Neural network models (supervised)) 无监督学习 高斯混合模型(Gaussian mixture models) 流形学习(Manifold learning) 聚类(Clustering) 双聚类(Biclustering) Decomposing signals in components (matrix factorization problems) 协方差估计(Covariance estimation) Novelty and Outlier Detection 密度估计(Density Estimation) 无监督神经网络模型(Neural network models (unsupervised)) 损失函数对于给定的输入X和假设空间中选择的决策函数模型f，由f(X)给出相应的输入Y，这个输出的预没值f(X)与真实值Y可能一致，也可能不一致，用一个损失函数或代价函数来度量预测的错误程度。损失函数是f(x)和Y的非负实值函数，记作L(Y,f(X)) 几种常用的损失函数： 0-1损失函数(0-1 loss function) $L(Y,f(X)) = \\begin{cases}1, &amp;Y\\neq f(X) \\\\ 0, &amp; Y=f(X)\\end{cases}$ 平方损失函数（quadratic loss function） $L(Y,f(X)) = (Y – f(X))^2$ 绝对损失函数（absolute loss function） $L(Y,f(X)) = |Y-f(X)|$ 对数损失函数（logarithmic loss function）或对数似然损失函数 $L(Y,P(Y|X)) = –logP(Y|X)$ 风险函数损失函数值越小，模型就越好。由于模型的输入、输出(X,Y)是随机变量，遵循联合分布P(X,Y)，所以损失函数的期望是 : $R_{exp}(f)=E_P[L(Y,f(X))]=\\int_{\\mathcal{X}\\times\\mathcal{Y}}L(y,f(x))P(x,y)dxdy$ 这是理论上模型f(X)关于联合分布P(X,Y)的平均意义下的损失，称为风险函数(risk function)或期望损失(expected loss)。 学习的目标就是选择期望风险最小的模型。由于联合分布P(X,Y)是所有样本所遵循的统计规律，它是未知的，所以Rexp(f)不能直接计算。实际上如果知道了联合分布，那么可以直接计算出P(Y|X)=∫P(x,y)dx，也就不需要学习了。所以用上面那种方式定义风险函数是不行的，那样的话监督学习变成了一个病态问题。 对于给定的训练数据集 T=(x1,y1),(x2,y2),…,(xN,yN),模型f(X)关于训练数据集的平均损失称为经验风险（empirical risk）或经验损失（empirical loss），记作Remp： $R_{emp}(f) = \\frac{1}{N}\\sum_{i=1}^NL(y_i,f(x_i))$ 期望风险Rexp(f)是模型关于联合分布的期望损失，经验风险Remp(f)是模型关于训练样本集的平均损失。根据大数定律，当样本容量N趋于无穷时，经验风险Remp(f)趋向于期望风险Rexp(f)。 所以，一个很自然的想法是用经验风险估计期望风险。但是，由于现实中训练样本数目很有限，所以用经验风险估计期望风险常常不理想，要对经验风险进行一定的矫正。这就关系到监督学习的两个基本策略：经验风险最小化和结构风险最小化。 经验风险最小化在假设空间、损失函数以及训练数据集确定的情况下，经验风险函数式就可以确定。经验风险最小化的策略认为，经验风险最小的模型就是最优的模型。根据这一策略，按照经验风险最小化求最佳模型就是求解最优化问题： $\\min_{f\\in\\mathcal{F}}\\frac{1}{N}\\sum_{i=1}^NL(y_i,f(x_i))$ 其中F是假设空间。 当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中广泛采用。比如极大似然估计就是经验风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。但是当样本容量很小时，经验风险最小化学习效果就未必很好，会产生“过拟合(over-fitting)”现象。 结构风险最小化结构风险最小化（structural risk minimization SRM）是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化。结构风险在经验风险上加上表示模型复杂度的正则化项或罚项。在假设空间，损失函数以及训练样本集确定的情况下，结构风险的定义是 $R_{srm}(f) = \\frac{1}{N}\\sum_{i=1}^NL(y_i,f(x_i))+\\lambda J(f)$ 其中J(f)为模型的复杂度，是定义在假设空间F上的泛函。模型f越复杂，复杂度J(f)就越大；反之，模型f越简单，复杂度J(f)就越小。也就是说复杂度表示了对复杂模型的惩罚。λ≥0是系数，用以权衡经验风险和模型的复杂度。结构风险小需要经验风险与模型复杂度同时小。结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。比如，贝叶斯估计中的最大后验概率估计（maximum posterior probability estimation,MAP）就是结构风险最小化的例子。当模型是条件概率分布、损失函数就是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。 结构风险最小化的策略认为结构风险最小的模型是最优的模型。所以求最优化模型时，就是求解最优化问题： $\\min_{f\\in\\mathcal{F}}\\frac{1}{N}L(y_i,f(x_i))+\\lambda J(f)$ 这样，监督学习问题就变成了经验风险或结构风险函数的最优化问题。这时经验或结构风险函数是最优化的目标函数。 归纳偏好归纳偏好是一个能挑选最佳假设函数的基准。以韦小宝的7个老婆为例，这7个老婆均满足小宝的要求，因此构成了大小为7的假设空间。（实际上，假设空间的大小一定是无穷大的。为了说明问题，我们暂时以7为大小）。那么，如何衡量哪一个假设空间中哪一个假设函数（老婆）最好呢？如果以温柔体贴为偏好来选，当然是小双；如果以小宝的迷恋为偏好来讲，假设函数就是阿珂。说白了，归纳偏好就是一个用于挑选假设函数的基准。 一般情况下，我们都使用“奥卡姆剃刀”原则，也就是选择最简单的假设函数。也就是变量最少，变量的幂指数最小的函数。也就是说，一次函数能拟合时就不选二次函数作为假设函数。 极大似然估计极大似然估计是根据样本(x1,x2，…，xi，…，xn)的值来估计样本模型中参数（θ1,θ2，…，θi，…，θn）的。是一种参数估计方法。 其中，似然是似然函数的简称。可由L(x1,x2，…，xi，…，xn,θ1,θ2，…，θi，…，θn )来表示。实际上，样本一旦确定，人们一般会假设一个可拟合这些样本的模型，即参数个数是确定的，待求的是参数的具体值。比如，基于班上同学的身高数据，一般会假设身高是符合正态分布(μ,σ)，待求的是这两个参数具体的值。 那么，如何基于已有的样本数据来求得模型中参数得具体值呢？ 极大似然估计的意思是说，你只要能使L(x1,x2，…，xi，…，xn,θ1,θ2，…，θi，…，θn )最大，你的参数θ1,θ2，…，θi，…，θn 就是有效的。以身高样本为例（假定身高样本是独立同分布的）。即当L(x1,x2，…，xi，…，xn,μ,σ )最大时，(μ,σ)被估计的是准确的。 求极大似然函数估计值的一般步骤： 写出似然函数； 对似然函数取对数，并整理； 求导数 ； 导数为零时，似然函数取得极大值 。 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://ai.wisim.me/tags/FAQ/"}]},{"title":"朴素贝叶斯分类算法原理","slug":"2018-03-17_Bayes","date":"2018-03-26T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/03/27/2018-03-17_Bayes/","link":"","permalink":"http://ai.wisim.me/2018/03/27/2018-03-17_Bayes/","excerpt":"一、朴素贝叶斯分类简介朴素贝叶斯（Naive Bayesian）是基于贝叶斯定理和特征条件独立假设的分类方法，它通过特征计算分类的概率，选取概率大的情况进行分类，因此它是基于概率论的一种机器学习分类方法。因为分类的目标是确定的，所以也是属于监督学习。 朴素贝叶斯有如下几种： 离散型朴素贝叶斯: MultinomialNB 连续型朴素贝叶斯: GaussianNB 混合型朴素贝叶斯: MergedNB","text":"一、朴素贝叶斯分类简介朴素贝叶斯（Naive Bayesian）是基于贝叶斯定理和特征条件独立假设的分类方法，它通过特征计算分类的概率，选取概率大的情况进行分类，因此它是基于概率论的一种机器学习分类方法。因为分类的目标是确定的，所以也是属于监督学习。 朴素贝叶斯有如下几种： 离散型朴素贝叶斯: MultinomialNB 连续型朴素贝叶斯: GaussianNB 混合型朴素贝叶斯: MergedNB 二、原理朴素贝叶斯基于条件概率、贝叶斯定理和独立性假设原则。 (1) 条件概率原理原理 123基于概率论的方法告诉我们，当只有两种分类时：如果p1(x,y)&gt;p2(x,y)，那么分入类别1如果p1(x,y)&lt;p2(x,y)，那么分入类别2 (2) 贝叶斯定理 $p(c_i|x,y)=\\frac{p(x,y|c_i)p(c_i)}{p(x,y)}$ 其中，x,y表示特征变量，ci表示分类，p(ci|x,y)即表示在特征为x,y的情况下分入类别ci的概率，因此，结合条件概率和贝叶斯定理，有： 12如果p(c1|x,y)&gt;p(c2|x,y)，那么分类应当属于c1；如果p(c1|x,y)&lt;p(c2|x,y)，那么分类应当属于c2 贝叶斯定理最大的好处是可以用已知的三个概率去计算未知的概率，而如果仅仅是为了比较p(ci|x,y)和p(cj|x,y)的大小，只需要已知两个概率即可，分母相同，比较p(x,y|ci)p(ci)和p(x,y|cj)p(cj)即可。 (3) 特征条件独立假设原则 见FAQ4. 三、朴素贝叶斯分类的流程123(1). 数据准备：收集数据，并将数据预处理为数值型或者布尔型，如对文本分类，需要将文本解析为词向量(2). 训练数据：根据训练样本集计算词项出现的概率，训练数据后得到各类下词汇出现概率的向量(3). 测试数据：用测试样本集去测试分类的准确性 四、优缺点1234561. 监督学习，需要确定分类的目标2. 对缺失数据不敏感，在数据较少的情况下依然可以使用该方法3. 可以处理多个类别 的分类问题4. 适用于标称型数据5. 对输入数据的形势比较敏感6. 由于用先验数据去预测分类，因此存在误差 五、平滑处理有时候样本量较少的时候，无论该样本的其他属性是什么，计算出来的分类结果始终是一种分类，这样的情况不合理。为了避免上述弊端的出现，我们在计算概率值时要进行平滑处理，常用 拉普拉斯平滑处理 $P(c) = \\frac{|D_c+1|}{|D|+N}$ $P(x_i|c) = \\frac{|D_{cx_i}+1|}{|D_c|+N_i}$ 拉普拉斯修正避免了因训练集样本不充分而导致的概率值为零的问题。 参考： Naive Bayes 机器学习之朴素贝叶斯(NB)分类算法与Python实现 EM(最大期望)算法 FAQ： 基于概率论的方法和基于统计学的方法： 基于概率论的方法是通过概率来衡量事件发生的可能性。概率论和统计学恰好是两个相反的概念，统计学是抽取部分样本进行统计来估算总体的情况，而概率论是通过总体情况来估计单个事件或者部分事情的发生情况。 朴素贝叶斯，朴素在什么地方： 之所以叫朴素贝叶斯，因为它简单、易于操作，基于特征独立性假设，假设各个特征不会相互影响，这样就大大减小了计算概率的难度。 概率论中的基本概念 (1)事件交和并： A和B两个事件的交，指的是事件A和B同时出现，记为A∩B;A和B两个事件的并，指的是事件A和事件B至少出现一次的情况，记为A∪B。 (2)条件概率(conditional probability)： 某个事件发生时另外一个事件发生的概率，如事件A发生条件下事件B发生的概率： $P(B|A)=\\frac{P(A \\cap B)}{P(A)} &lt;=&gt; P(B|A)=\\frac{P(A|B)}{P(A)}P(B)$ $P(A \\cap B)=P(A)P(B|A) &lt;=&gt; P(A \\cap B)=P(B)P(A|B)$ P(B)称为”先验概率”（Prior probability），即在A事件发生之前，我们对B事件概率的一个判断。 P(B|A)称为”后验概率”（Posterior probability），即在A事件发生之后，我们对B事件概率的重新评估。 P(A|B)/P(A)称为”可能性函数”（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。 所以，条件概率可以理解成下面的式子： 1后验概率 ＝ 先验概率 ｘ 调整因子 (3)独立事件交的概率： 两个相互独立的事件，其交的概率为： $P(A \\cap B)=P(A)P(B)$ 贝叶斯定理（Bayes’s Rule）： 如果有k个互斥且有穷个事件:B1,B2···，Bk ，并且，P(B1)+P(B2)+···+P(Bk)=1和一个可以观测到的事件A，那么有： $P(B_i | A)=\\frac{P(B_i \\cap A)}{P(A)}=\\frac{P(B_i)P(A | B_i)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)+···+P(B_k)P(A|B_k)}$ p(A) : 事件A发生的概率； p(B∩A) : 事件B 和事件A 同时发生的概率； p(B|B) : 表示事件B在事件A发生的条件下发生的概率。 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"NaiveBayes","slug":"NaiveBayes","permalink":"http://ai.wisim.me/tags/NaiveBayes/"}]},{"title":"平衡二叉树的旋转及其代码实现","slug":"2018-03-13_AVL","date":"2018-03-12T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/03/13/2018-03-13_AVL/","link":"","permalink":"http://ai.wisim.me/2018/03/13/2018-03-13_AVL/","excerpt":"平衡二叉树的构造问题以及为了维护它的平衡所要进行的LL旋转、RR旋转、LR旋转、RL旋转。","text":"平衡二叉树的构造问题以及为了维护它的平衡所要进行的LL旋转、RR旋转、LR旋转、RL旋转。 一、平衡二叉树的构造1234567891011121314151617181920node *insert(node *root, int x) &#123; if (root == 0) &#123; root = &amp;all[total++]; root-&gt;left = root-&gt;right = 0; root-&gt;val = x; root-&gt;height = 0; &#125; else if (x &lt; root-&gt;val) &#123; root-&gt;left = insert(root-&gt;left, x); if (height(root-&gt;left) - height(root-&gt;right) == 2) &#123; root = (x &lt; root-&gt;left-&gt;val) ? LL(root) : LR(root); &#125; &#125; else &#123; root-&gt;right = insert(root-&gt;right, x); if (height(root-&gt;right) - height(root-&gt;left) == 2) &#123; root = (x &gt; root-&gt;right-&gt;val) ? RR(root) : RL(root); &#125; &#125; root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + 1; return root;&#125; 二、LL旋转所谓LL旋转并不是指旋转方向，而是指新插入导致不平衡的元素位于左子树的左儿子位置，也就是LeftLeft。 看一下这种旋转的示意图： 12345678node *LL(node *k2) &#123; node *k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; return k1;&#125; 三、RR旋转同样LL旋转是指新插入导致不平衡的元素位于右子树的右儿子位置，也就是RightRight。 看一下这种旋转的方式示意图： 12345678node *RR(node *k1) &#123; node *k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; return k2;&#125; 四、LR旋转和RL旋转LR和RL则分别表示位于左子树的右儿子和右子树的左儿子。 1.对于LR旋转，首先将最近的不平衡结点k3的左子树进行RR旋转，再将k3本身进行LL旋转。 1234node *LR(node *k3) &#123; k3-&gt;left = RR(k3-&gt;left); return LL(k3);&#125; 2.对于RL旋转，首先将最近的不平衡结点k3的右子树进行LL旋转，再将k3本身进行RR旋转。 1234node *RL(node *k1) &#123; k1-&gt;right = LL(k1-&gt;right); return RR(k1);&#125; THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"TREE","slug":"TREE","permalink":"http://ai.wisim.me/tags/TREE/"}]},{"title":"机器学习构建chatbot","slug":"2018-02-24_chatbot","date":"2018-02-24T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/02/25/2018-02-24_chatbot/","link":"","permalink":"http://ai.wisim.me/2018/02/25/2018-02-24_chatbot/","excerpt":"预备知识机器人应答逻辑（Logic Adapter），针对每个部分设计了不同的适配器 Closet Match Adapter:字符串模糊匹配（编辑距离） Closet Meaning Adapter:借助nltk的WordNet，近义词评估 Time Logic Adapter:处理涉及实践的提问 Mathematical Evaluation Adapter:涉及数学运算 存储器后段（Storage Adapter） Read Only Mode:只读模式 Json Database Mode:Json格式存储对话数据 Mongo Database Mode:以MongoDb方式存储对话数据库 输入形式（Input Adapter） Variable input type Adapter:允许chatbot接收不同类型的输入 Terminal Adapter:以终端方式进行对话 HipChat Adapter:通过HipChat聊天室和chatbo进行对话 Speech recognition:语音识别输入 输出形式（Output Adapters） Output format adapter:支持text，json和object格式的输出 Terminal adapter HipChat Adapter Mailgun adapter:允许chat bot基于Mailgun API进行邮件的发送 Speech synthesis TTS(Text to speech)部分，详见chatterbot-voice","text":"预备知识机器人应答逻辑（Logic Adapter），针对每个部分设计了不同的适配器 Closet Match Adapter:字符串模糊匹配（编辑距离） Closet Meaning Adapter:借助nltk的WordNet，近义词评估 Time Logic Adapter:处理涉及实践的提问 Mathematical Evaluation Adapter:涉及数学运算 存储器后段（Storage Adapter） Read Only Mode:只读模式 Json Database Mode:Json格式存储对话数据 Mongo Database Mode:以MongoDb方式存储对话数据库 输入形式（Input Adapter） Variable input type Adapter:允许chatbot接收不同类型的输入 Terminal Adapter:以终端方式进行对话 HipChat Adapter:通过HipChat聊天室和chatbo进行对话 Speech recognition:语音识别输入 输出形式（Output Adapters） Output format adapter:支持text，json和object格式的输出 Terminal adapter HipChat Adapter Mailgun adapter:允许chat bot基于Mailgun API进行邮件的发送 Speech synthesis TTS(Text to speech)部分，详见chatterbot-voice 使用ChatterBot构建聊天机器人1. 首先构建ChatBot并指定Adapter123456789101112131415161718# -*- coding: utf-8 -*-from chatterbot import ChatBotbot = ChatBot( 'Default Response Example Bot', #置信度低于0.65时回复default_response logic_adapters=[ &#123; 'import_path': 'chatterbot.logic.BestMatch' &#125;, &#123; 'import_path': 'chatterbot.logic.LowConfidenceAdapter', 'threshold': 0.65, 'default_response': 'I am sorry, but I do not understand.' &#125; ], #指定对话类型是列表 trainer='chatterbot.trainers.ListTrainer') 2. 接着手动给定一点语料用于训练1234567bot.train([ 'How can I help you?', 'I want to create a chat bot', 'Have you read the documentation?', 'No, I have not', 'This should help get you started: http://chatterbot.rtfd.org/en/latest/quickstart.html']) 3. 给定问题并取回结果12345678910question = 'How do I make an omelette?'print(question)response = bot.get_response(question)print(response)print(\"\\n\")question = 'how to make a chat bot?'print(question)response = bot.get_response(question)print(response) 各自输出： 123456How do I make an omelette?I am sorry, but I do not understand.how to make a chat bot?Have you read the documentation? 4. 使用chatterbot自带的中文语料库训练1234567891011121314#!/usr/bin/python# -*- coding: utf-8 -*-from chatterbot import ChatBotfrom chatterbot.trainers import ChatterBotCorpusTrainerchatbot = ChatBot(\"ChineseChatBot\")chatbot.set_trainer(ChatterBotCorpusTrainer)# 使用中文语料库训练它chatbot.train(\"chatterbot.corpus.chinese\")# 开始对话while True: print(chatbot.get_response(input(\"&gt;\"))) 试了一下，问答比较二。。。 seq2seq LSTM THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://ai.wisim.me/tags/NLP/"}]},{"title":"NLP基础","slug":"2018-02-25_nltk","date":"2018-02-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2018/02/24/2018-02-25_nltk/","link":"","permalink":"http://ai.wisim.me/2018/02/24/2018-02-25_nltk/","excerpt":"NLTKNLTK在NLP上的应用 情感分析 文本相似度 文本分类","text":"NLTKNLTK在NLP上的应用 情感分析 文本相似度 文本分类 一、安装NLTK1234sudo pip install nltkpython3&gt;&gt;&gt; import nltk&gt;&gt;&gt; nltk.download() 其中 nltk.download() 用来下载nltk自带的一些语料库 测试布朗大学的语料库： 1234567&gt;&gt;&gt; from nltk.corpus import brown&gt;&gt;&gt; brown.categories()[&apos;adventure&apos;, &apos;belles_lettres&apos;, &apos;editorial&apos;, &apos;fiction&apos;, &apos;government&apos;, &apos;hobbies&apos;, &apos;humor&apos;, &apos;learned&apos;, &apos;lore&apos;, &apos;mystery&apos;, &apos;news&apos;, &apos;religion&apos;, &apos;reviews&apos;, &apos;romance&apos;, &apos;science_fiction&apos;]&gt;&gt;&gt; len(brown.sents())57340 #句子长度&gt;&gt;&gt; len(brown.words())1161192 #单词个数 二、文本处理流程1. 文本预处理（1）Tokenize:把长句子拆分成“有意义”的小部分 12345&gt;&gt;&gt; import nltk&gt;&gt;&gt; sentence = “hello, world&quot;&gt;&gt;&gt; tokens = nltk.word_tokenize(sentence)&gt;&gt;&gt; tokens[&apos;hello&apos;, ‘,&apos;, &apos;world&apos;] （2）词形归一化，包括Stemming和Lemmatization Stemming 词干提取:一般来说，就是把不影响词性的inflection的小尾巴砍掉 可以使用nltk中的 PorterStemmer/LancasterStemmer/SnowballStemmer/PorterStemmer Lemmatization 词形归一:把各种类型的词的变形，都归为一个形式 可以使用nltk中的 WordNetLemmatizer Part-Of-Speech:NLTK更好地实现Lemma （3）去除停止词 1234from nltk.corpus import stopwords# 先token得到word_list,再去除停止词filtered_words =[word for word in word_list if word not in stopwords.words('english')] （4）最终得到一个干净的word list 分词的方式：启发式Heuristic（查数据库）机器学习／统计方法：HMM、CRF 三、应用：情感分析最简单的方法是给每个词打分，然后判断句子总的分数。 配上ML的情感分析： 123456789101112# 把训练集给做成标准形式training_data = [[preprocess(s1), 'pos'],[preprocess(s2), 'pos'],[preprocess(s3), 'neg'],[preprocess(s4), 'neg']]# 构建modelmodel = NaiveBayesClassifier.train(training_data)# 测试结果print(model.classify(preprocess('this is a good book'))) 四：应用:文本相似度用元素频率表示文本特征 原理就是使用余弦定理来计算文本相似度: $similarity = cos( \\theta ) = \\dfrac{A \\cdot B}{||A|| \\: ||B||}$ 使用NLTK中的FreqDist包来进行频率统计 12345678&gt;&gt;&gt; from nltk.corpus import stopwords&gt;&gt;&gt; from nltk import FreqDist&gt;&gt;&gt; corpus = &apos;this is my sentence this is my life this is the day&apos;&gt;&gt;&gt; tokens = nltk.word_tokenize(corpus)&gt;&gt;&gt; fdist = FreqDist(tokens)&gt;&gt;&gt; standard_freq_vector = fdist.most_common(50)&gt;&gt;&gt; print(standard_freq_vector)[(&apos;this&apos;, 3), (&apos;is&apos;, 3), (&apos;my&apos;, 2), (&apos;sentence&apos;, 1), (&apos;life&apos;, 1), (&apos;the&apos;, 1), (&apos;day&apos;, 1)] 这一步得到了一个类似词典的东西，里面保存了我们给出的句子里面每个单词出现的频率，并且取出来出现频率最高的50个单词。 然后按照出现频率 ,记录下每个单词的位置： 1234567891011def position_lookup(v): res = &#123;&#125; counter = 0 for word in v: res[word[0]] = counter counter += 1 return res# 把标准的单词位置记录下来standard_position_dict = position_lookup(standard_freq_vector) print(standard_position_dict)# 得到 个位置对照表# &#123;'is': 0, 'the': 3, 'day': 4, 'this': 1,'sentence': 5, 'my': 2, 'life': 6&#125; 这时如果我们有个新句子，对于这个新句子的每个单词如果在我们的词库出现过那么就在”标准位置”上+1 1234567891011sentence = 'this is cool'# 先新建个跟我们的标准vector同样的向量 freq_vector = [0] * size# 简单的Preprocessingtokens = nltk.word_tokenize(sentence)for word in tokens: try: freq_vector[standard_position_dict[word]] += 1 except KeyError: # 如果是个新词就pass掉 continueprint(freq_vector)# [1, 1, 0, 0, 0, 0, 0] 结巴分词 Word2Vec THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"NLTK","slug":"NLTK","permalink":"http://ai.wisim.me/tags/NLTK/"}]},{"title":"KNN 简介","slug":"2018-02-23_introduce_to_knn","date":"2018-02-22T16:00:00.000Z","updated":"2018-09-20T07:53:59.000Z","comments":true,"path":"2018/02/23/2018-02-23_introduce_to_knn/","link":"","permalink":"http://ai.wisim.me/2018/02/23/2018-02-23_introduce_to_knn/","excerpt":"一、前言k-近邻算法（kNN，k-NearestNeighbor），是一种监督分类算法，是最简单的机器学习分类算法之一。其核心思想在于用距离目标最近的 k 个样本数据的分类来代表目标的分类（这k个样本数据和目标数据最为相似）。kNN 是一种惰性学习方法。 k-近邻算法的缺点是对数据的局部结构非常敏感。","text":"一、前言k-近邻算法（kNN，k-NearestNeighbor），是一种监督分类算法，是最简单的机器学习分类算法之一。其核心思想在于用距离目标最近的 k 个样本数据的分类来代表目标的分类（这k个样本数据和目标数据最为相似）。kNN 是一种惰性学习方法。 k-近邻算法的缺点是对数据的局部结构非常敏感。 二、算法描述1. 具体算法过程：（1）. 计算分类未知数据 x_new 与训练样本集数据 x 的欧氏距离 distance （2）. 将 distance 递增排序 （3）. 选取 distance 的前 k 个点 （4）. 选取前 k 个点中，出现频率最高的类别 y 作为 x_new的分类 2. k 值得选择\bk 值的选择对 KNN 算法的性能有较大影响，选得太小容易欠拟合，选得太大容易过拟合。在实际应用中，一般选取一个区间，采用交叉验证法来选取最优的 k 值。 3. \bKNN 分类决策规则由于 KNN 属于惰性\b学习算法，所以\b并不存在事先的训练过程，\b决策都是在预测时直接根据决策规则做出的。KNN 分类的决策规则往往是多数表决，也就是由输入实例的 k 个邻近的训练实例中的多数决定的。那么为什么多数表决规则可以\b作为 KNN 的决策规则呢？具体解释如下： 首先设 KNN 分类算法的分类函数是 f(x) ，损失函数是 0-1 损失函数，即： L(Y,f(X)) = \\begin{cases}1, &Y\\neq f(X) \\\\ 0, & Y=f(X)\\end{cases}那么误分类的概率是： $P(Y \\neq f(X))=1-p(Y = f(X))$ 对于某一个给定的实例 $x_i$，以及它的最邻近的 k 个训练实例构成集合 N。如果涵盖 N 的区域的类别是 $c_j$，那么误分类率是： \\frac{1}{k}\\sum_{x_i \\in N}I(y_i \\neq c_j)=1-\\frac{1}{k}\\sum_{x_i \\in N}I(y_i = c_j)这里的 函数 I\b 是指示函数，它是定义在某集合X上的函数，表示其中有哪些元素属于某一子集A。 要使误分类率最小就是要使 $\\sum_{x_i \\in N}I(y_i = c_j)$ 最大，也就是在 N \b集合中，属于类别 c 的实例个数越多越好。所以多数表决规则等价于经验风险最小化。 三、代码实现123456789101112131415161718192021222324252627282930import numpy as npdef createDataSet(): group = np.array([[1, 1.1], [1, 1], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels\"\"\"定义knn算法分类器函数:param inX: 测试数据:param dataSet: 训练数据:param labels: 分类类别:param k: k值:return: 所属分类\"\"\"def classify(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] #shape（m, n）m列n个特征 diffMat = np.tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 #欧式距离 sortedDistIndicies = distances.argsort() #排序并返回index classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1 #default 0 sortedClassCount = sorted(classCount.items(), key=lambda d:d[1], reverse=True) return sortedClassCount[0][0] 测试1234if __name__ == '__main__': dataSet, labels = createDataSet() r = classify([0, 0.2], dataSet, labels, 3) print(r) 输出 B 四、k 邻近法的特殊实现：kd 树KNN 最简单地实现就是线性扫描，计算出训练集中每个点到输入实例的距离，再排序取前 k 个，采用多数表决判断输入实例的类别。但是当训练集很大时，这种方法的性能很差。为了提高 KNN 的\b性能，可以考虑使用特殊的存储结构，减少计算距离的次数，提高搜索效率。下面介绍一种 kd 树方法: 1. kd 树的构造kd 树是一种对 k 维空间中的实例进行存储以便快速检索的树形数据结构。kd 树是二叉树，表示对 k 维空间的不断划分。构造 kd 树相当于用垂直于坐标轴的超平面将 k 维空间划分为一系列 k 维超矩形区域。kd树的每一个节点对应于一个 k 维超矩形区域。kd 树\b的具体构造过程： 每次选出一个特征上的中位数(median)，将这个实例构造为 kd 树的一个节点，并对训练集进行\b切分。然后依次换一个特征，再取其中位数构造 kd 树节点。如此迭代，直到每个实例都被作为节点插入到 kd 树中。 之所要要选择中位数作为划分点，是因为这样构造出的 kd 树是平衡的。不过平衡的 kd 树搜索效率不一定是最高的。 2. kd 树的搜索对于 KNN 算法\b，我们要找的是前 k 个距离最近的实例。这里使用 kd 树，先寻找最邻近节点。对于给定一个输入实例，先从\b kd 树的根节点开始搜索，比较第一个特征，如果输入实例第一个特征值小于根节点的第一个特征值，则向左子树继续搜索，否则向右子树继续搜索。而继续搜索\b子树的\b时候，则要切换到下一个特征比较。最终到达某一个叶节点，这个叶节点就是要找的最邻近节点。如果 k&gt;1，则要继续寻找剩下的 k-1 个邻近点。这里比较重要了，\b继续寻找的时候，采用回溯的方法，从刚刚找到的那个节点回退到它的父节点，再寻找和输入\b实例最靠近的节点。如此迭代，直到找到 k 个邻近点结束。 如果训练样本是随进分布的，kd 树搜索的计算复杂度是 O(log N)。 参考： [1]. 《统计学习方法（李航）》：k 邻近法 [2]. k-d tree算法 [3]. KD tree algorithm THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"KNN","slug":"KNN","permalink":"http://ai.wisim.me/tags/KNN/"}]},{"title":"感知机 简介","slug":"2018-02-19_introduce_to_perceptron","date":"2018-02-18T16:00:00.000Z","updated":"2018-09-19T09:18:36.000Z","comments":true,"path":"2018/02/19/2018-02-19_introduce_to_perceptron/","link":"","permalink":"http://ai.wisim.me/2018/02/19/2018-02-19_introduce_to_perceptron/","excerpt":"一、感知机模型感知机（perceptron）是一种\b\b二分类的线性分类模型，它是一种监督式学习算法。感知机的输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的分离超平面 S。感知机旨在求出该超平面 S，为求得超平面导入了基于误分类的损失函数，利用梯度下降法对损失函数进行最优化（最优化）。 感知机也是 Neural Networks（神经网络） 和 SVM（支持向量机） 的基础，它是一个单层神经网络。 感知机的模型\b如下： f(x)=sign(w \\cdot x+b)其中 w 叫做权值（weight）或权值向量（weight vector），b 叫做偏置（bias），sign 是符号函数，即： \\operatorname{sign}(x) = \\begin{cases} +1 & x \\geq 0 \\\\ -1 & x < 0 \\end{cases}.而分割超平面则为： w \\cdot x+b = 0","text":"一、感知机模型感知机（perceptron）是一种\b\b二分类的线性分类模型，它是一种监督式学习算法。感知机的输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的分离超平面 S。感知机旨在求出该超平面 S，为求得超平面导入了基于误分类的损失函数，利用梯度下降法对损失函数进行最优化（最优化）。 感知机也是 Neural Networks（神经网络） 和 SVM（支持向量机） 的基础，它是一个单层神经网络。 感知机的模型\b如下： f(x)=sign(w \\cdot x+b)其中 w 叫做权值（weight）或权值向量（weight vector），b 叫做偏置（bias），sign 是符号函数，即： \\operatorname{sign}(x) = \\begin{cases} +1 & x \\geq 0 \\\\ -1 & x < 0 \\end{cases}.而分割超平面则为： w \\cdot x+b = 0 二、感知机的损失函数1.这个损失函数怎么得到呢？我们先考虑一下，正常最直接的想法就是损失函数嘛，直接用误分类的点的个数来表示不就好了吗，这样误分类的点越少，损失函数的值不就越小嘛。但是这样的函数显然是离散的，不是参数w和b的可导函数，不易优化。 然后再考虑一下所有误分类的点到分割超平面的距离之和作为损失函数，这样的函数貌似是连续可导的。\b那可行吗？实际上，确实感知机也是采用的这种损失函数。 （1）为此，我们先考察任意某一点到超平面的距离： \\frac{1}{||w||}|w \\cdot x_0+b| \\tag{2.1}这里的 $||w||$ 是 w\b 的 $L_2$ 范式，$|w \\cdot x_0+b|$表示绝对值。 （2）其次，对于任意一个误分类的点 $(x_i,y_i)$ 来说， -y_i(w \\cdot x_i+b) < 0（3）因此，误分类的点 $x_i$ 到超平面的距离可以写作： -\\frac{1}{||w||}y_i(w \\cdot x_i+b)这样就把公式2.1的绝对值去掉了，而 $y_i$ 的取值只有 +1 或 -1，也不影响最终结果大小。 （4）最终，设误分类点得集合为 M ，则所有误分类的点到超平面的距离之和为： -\\frac{1}{||w||} \\sum_{x_i \\in M}{y_i(w \\cdot x_i+b)}不考虑 $-\\frac{1}{||w||} $ ，就可以得到感知机的损失函数了： L(w,b)=-\\sum_{i=1}^{M} {y_i(w*x_i+b)}显然，损失函数L(w,b)是非负的。如果没有误分类点，那么L(w,b)为0，误分类点数越少，L(w,b)值越小。一个特定的损失函数：在误分类时是参数w,b的线性函数，在正确分类时，是0。 2. 感知机学习算法感知机学习的过程也就是它的损失函数不断优化达到最小值的过程。具体就是采用随机梯度下降法(SGD)。损失函数L(w,b)的梯度为： $\\nabla_w L(w,b)=-\\sum_{i=1}^{M}y_i\\:x_i$ $\\nabla_b L(w,b)=-\\sum_{i=1}^{M}y_i$ 随机选出一个误分类点 $(x_i,y_i)$，对参数 w，b进行更新： w+ \\eta y_i x_i \\rightarrow wb+ \\eta y_i \\rightarrow b式中η（0≤η≤1）是步长，在统计学是中成为学习速率。步长越大，梯度下降的速度越快，更能接近极小点。如果步长过大，有可能导致跨过极小点，导致函数发散；如果步长过小，有可能会耗很长时间才能达到极小点。 具体算法过程如下： 输入训练集 T，\b学习率 $\\eta$。输出 w,b 和 感知机模型 $f(x)=sign(w \\cdot x+b)$。 （1）首先任选一个超平面，参数分别为 $w_0,b_0$； （2）在训练集中\b任选一条数据 $(x_i,y_i)$； （3）如果 $y_i(w \\cdot x_i+b) \\leq 0$，则执行： w+ \\eta y_i x_i \\rightarrow wb+ \\eta y_i \\rightarrow b（4）转至（2），直至训练集中没有误分类的点。 这种方法直观地解释就是：不断调整参数 w,b ，将超平面向\b当前选择的误分类点得方向移动（一个点可能会更新多次，最终使得误分类点分类正确为止），以减少误分类点，最终所有误分类点都被正确分类。 此外，\b感知机学习算法是可能有很多解的，为了得到唯一的超平面，就要对超平面增加约束条件，也就是 SVM 的想法。 三、实现代码从输入参数得到训练文件和模型文件： 123n = float(sys.argv[1])trainFile = open(sys.argv[2])modelFile= open(sys.argv[3], 'w') 从训练文件中读取训练数据： 123456789101112for line in trainFile: chunk = line.strip().split(' ') #每行的数据 lens = len(chunk) - 1 #最后一行是训练输出 tmp_all = [] tmp = [] for i in range(1, lens+1): tmp.append(int(chunk[i])) tmp_all.append(tmp) tmp_all.append(int(chunk[0])) training_set.append(tmp_all)trainFile.close() 训练数据：1231 3 31 4 3-1 1 1 计算点到超平面的距离：12345678def cal(item): global w, b res = 0 for i in range(len(item[0])): res += item[0][i] * w[i] #w和xi的内积 res += b res *= item[1] return res 判断是否是误分类点，如果是误分类点则更新参数:1234for item in training_set: if cal(item) &lt;= 0: flag = True update(item) 使用随机梯度下降法更新参数：12345def update(item): global w, b, lens, n #n就是学习速率η for i in range(lens): w[i] = w[i] + n * item[1] * item[0][i] b = b + n * item[1] 四、感知机学习算法的对偶形式感知机学习算法的对偶形式的基本思想就是将参数 w 和偏置 b用实例 $x_i$ 和标签 $y_i$ 的线性组合来表示。通过求解这个线性组合的系数来求得 w 和 b。这里还是设初值 $w_0,b_0$ 均为0。对\b误分类的点也还是按如下规则更新： w+ \\eta y_i x_i \\rightarrow wb+ \\eta y_i \\rightarrow b如果对于某个误分类点 $(x_i,y_i)$ ，我们通过上面这个规则更新了 $n_i$ 次参数 w 和 b。那么 w 和 b 关于 $(x_i,y_i)$ 的增量为：$a_iy_ix_i$ 和 $a_iy_i$，由于每个点更新了 $n_i$ 次，且学习率为 $\\eta$，所以 $a_i=n_i \\eta$\b （这里也就解释了下面具体算法过程中 a 每次只增加 η）。通过这个学习过程，最终 w 和 b 为： w=\\sum_{i=1}^{N} a_iy_ix_ib=\\sum_{i=1}^{N} a_iy_i由于 $a_i &gt; 0,i=1,2,…,N$，所以当 $\\eta=1$ 时，$a_i=n_i$ 实际上就是第 i 个误分类点更新到正确之后\b所用的次数。某个误分类点更新次数越多，意味着它离超平面距离越近,\b也就越难分类正确。这样的点对感知机学习算法影响最大。 具体算法过程如下： 输入训练集 T，学习率 $\\eta$。输出 a，b 和感知机模型 $f(x)=sign(\\sum_{j=1}^{N} a_jy_jx_j \\cdot x+b)$。 （1） $a \\leftarrow 0,b \\leftarrow 0$ （2） 任选误分类点 $(x_i,y_i)$ （3） 如果 $y_i(\\sum_{j=1}^{N} a_jy_jx_j \\cdot x+b) \\leq 0$，则更新： a_i \\leftarrow a_i+\\etab_i \\leftarrow b_i+\\eta y_i（4）转至（2），直至训练集中没有误分类的点。 另外，可以看第三步的判断条件\b，说明每次都要判断实例的内积 $(x_j \\cdot x_i)$，所以可以预先将训练集的实例之间的内积算出来并以\b矩阵形式表示，这就是所谓的 Gram 矩阵: G = [x_i \\cdot x_j]_{N \\times N} 注： [1]. 线性可分：存在超平面能够将所有的数据点完全划分到两侧。 [2]. 验证单层感知机不能表示异或逻辑 [3]. 异或运算（XOR）：a⊕b = (¬a ∧ b) ∨ (a ∧¬b)，如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。 参考： [1]. 感知机（python实现） [2]. 《统计学习方法（李航）》：感知机 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[{"name":"Perceptron","slug":"Perceptron","permalink":"http://ai.wisim.me/tags/Perceptron/"}]},{"title":"线性代数陌生公式","slug":"2017-12-25","date":"2017-12-24T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/12/25/2017-12-25/","link":"","permalink":"http://ai.wisim.me/2017/12/25/2017-12-25/","excerpt":"$\\left(kA\\right)^{\\ast}=k^{n-1}A^{\\ast}$ $|A^{\\ast}|=|A|^{n-1}$ $|kA|=k^{n}|A|$","text":"$\\left(kA\\right)^{\\ast}=k^{n-1}A^{\\ast}$ $|A^{\\ast}|=|A|^{n-1}$ $|kA|=k^{n}|A|$ $\\begin{vmatrix}A &amp; O \\\\O &amp; B\\end{vmatrix}^{-1}=\\begin{vmatrix}A^{-1} &amp; O \\\\O &amp; B^{-1}\\end{vmatrix}$ $\\begin{vmatrix}O &amp; A \\\\B &amp; O\\end{vmatrix}^{-1}=\\begin{vmatrix}O &amp; B^{-1} \\\\A^{-1} &amp; O\\end{vmatrix}$ $A^{-1}=\\dfrac{A^{\\ast}}{|A|} &lt;=&gt; (A^{\\ast})^{-1}=\\dfrac{A}{|A|} &lt;=&gt; AA^{\\ast}=|A|E$ $(A^{T})^{\\ast}=(A^{\\ast})^{T}$ $(A^{T})^{-1}=(A^{-1})^{T}$ $(A^{-1})^{\\ast}=(A^{\\ast})^{-1}$ $(A^{\\ast})^{\\ast}=|A|^{n-2}A$ $(AB)^{\\ast}=B^{\\ast}A^{\\ast}$ $r(A^{\\ast})=\\begin{cases}n,r(A)=n\\\\1,r(A)=n-1\\\\0,r(A)&lt;n-1 \\end{cases}$ $r(AB)\\geq r(A)+r(B)-n$ $r(A)=r(A^{T}A)$ $r(A|B)\\leq r(A)+r(B)$ $r(A|B)\\geq r(A)$ $(A+B)^n=A^n+C_n^1A^{n-1}B+C_n^{2}A^{n-2}B^2+…+C_n^{n-1}AB^{n-1}+B^n$ THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[]},{"title":"线性代数难点题型","slug":"2017-12-24","date":"2017-12-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/12/24/2017-12-24/","link":"","permalink":"http://ai.wisim.me/2017/12/24/2017-12-24/","excerpt":"1. 关于矩阵的n阶的题型(1) 如果$A=αβ^{T}$,其中α和β是n维非零列向量，则$A^{n}=l^{n-1}A$,其中$l=β^{T}α=tr(A)$ (2) 如果$A=\\begin{pmatrix}0 &amp; a &amp; c \\\\0 &amp; 0 &amp; b \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,则$A^{2}=\\begin{pmatrix}0 &amp; 0 &amp; ab \\\\0 &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,$A^{3}=0$,$A^{4}=0$… (3) 如果$A \\sim B$,则$A^{n} \\sim B^{n}$,于是$A^{n} \\sim P^{-1}B^{n}P$,其中B是对角矩阵。 (4) 用归纳法：先求 $A^{2},A^{3}$ 等,看出规律，再求 $A^{n}$","text":"1. 关于矩阵的n阶的题型(1) 如果$A=αβ^{T}$,其中α和β是n维非零列向量，则$A^{n}=l^{n-1}A$,其中$l=β^{T}α=tr(A)$ (2) 如果$A=\\begin{pmatrix}0 &amp; a &amp; c \\\\0 &amp; 0 &amp; b \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,则$A^{2}=\\begin{pmatrix}0 &amp; 0 &amp; ab \\\\0 &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; 0\\end{pmatrix}$,$A^{3}=0$,$A^{4}=0$… (3) 如果$A \\sim B$,则$A^{n} \\sim B^{n}$,于是$A^{n} \\sim P^{-1}B^{n}P$,其中B是对角矩阵。 (4) 用归纳法：先求 $A^{2},A^{3}$ 等,看出规律，再求 $A^{n}$ 2. 证明可逆的方法主要有：n阶矩阵A可逆 &lt;=&gt; $|A|\\neq0$ &lt;=&gt; r(A)=n &lt;=&gt; A的列（行）向量组线性无关 &lt;=&gt; Ax=0只有0解 &lt;=&gt; 0不是矩阵A的特征值 3. 关于两个矩阵的和的公式只有：$(A+B)^T=A^T+B^T$ 4. 满足交换律的一些特殊矩阵：(1) $AA^2=A^2A=A^3$ (2) $AA^{\\ast}=A^{\\ast}A=|A|E$ (3) $AE=EA=A$ (4) $AA^{-1}=A^{-1}A=E$ (5) $AB=aA+bB(ab\\neq0)$ (6) $A^2-kAB=E(k\\neq0)$ 注：一般矩阵不满足交换律。 THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[]},{"title":"动态规划-数对之差最大值","slug":"2017-11-22-DynamicProgrammingMaxDiff","date":"2017-11-21T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/11/22/2017-11-22-DynamicProgrammingMaxDiff/","link":"","permalink":"http://ai.wisim.me/2017/11/22/2017-11-22-DynamicProgrammingMaxDiff/","excerpt":"题目描述 在数组中，某个数字减去它右边的数字得到一个数对之差。求所有数对之差的最大值。例如，在数组{2,4,1,16,7,5,11,9}中，数对之差的最大值是11，是16减去5的结果。","text":"题目描述 在数组中，某个数字减去它右边的数字得到一个数对之差。求所有数对之差的最大值。例如，在数组{2,4,1,16,7,5,11,9}中，数对之差的最大值是11，是16减去5的结果。 分析 定义D[i]是以数组中第i个数字为减数的所有数对之差的最大值。根据题意，用N[i]表示数组的第i个元素，就是说对于任意h=N[h]-N[i]。所以D[i]的最大值就是整个数组的最大的数对之差。来手写求一下最大数对之差的过程。 123456789101112131415161718192021222324252627M[0] = 2;D[1] = M[0] - N[1] = 2 - 4 = -2;maxDiff = 2;M[1] = max&#123;M[0],N[1]&#125; = max&#123;2,4&#125; = 4;D[2] = M[1] - N[2] = 4 - 1 = 3;maxDiff = max&#123;maxDiff,D[2]&#125; = 3;M[2] = max&#123;M[1],N[2]&#125; = max&#123;4,1&#125; = 4;D[3] = M[2] - N[3] = -12;maxDiff = max&#123;maxDiff,D[3]&#125; = 3;M[3] =16;D[4] = 9;maxDiff = 9;M[4] = 16;D[5] = 11;maxDiff = 11;M[5] = 16;D[6] = 5;maxDiff = 11;M[6] = 16;D[7] = 7;maxDiff = 11; 这里的 M[i-1] 表示的是当前第i个元素之前的i-1个元素中的最大值。而maxDiff则是i之前包括位置i在内的最大数对之差的值。 C代码实现12345678910111213141516int MaxDiff(int numbers[], int length) &#123; if(numbers == NULL || length &lt; 2) return 0; int max = numbers[0]; int maxDiff = max - numbers[1]; for(int i=2;i&lt;length;++i) &#123; if(numbers[i] &lt; max) &#123; max = numbers[i]; &#125; int curDiff = max - numbers[i]; if(curDiff &gt; maxDiff) &#123; maxDiff = curDiff; &#125; &#125; return maxDiff;&#125; THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"http://ai.wisim.me/tags/DynamicProgramming/"}]},{"title":"201709304","slug":"2017-09-30-4","date":"2017-09-29T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/09/30/2017-09-30-4/","link":"","permalink":"http://ai.wisim.me/2017/09/30/2017-09-30-4/","excerpt":"题 4:设 f(x) 在[0,1] 上有二阶导数，f(0)=f(1)=f’(0)=f’(1)=0，证明存在 𝛏∈(0,1)，使得f’’(𝛏)=f(𝛏).","text":"题 4:设 f(x) 在[0,1] 上有二阶导数，f(0)=f(1)=f’(0)=f’(1)=0，证明存在 𝛏∈(0,1)，使得f’’(𝛏)=f(𝛏). 证明构造辅助函数 $F(x)=[f(x)+f’(x)]e^{-x}$. 由题设可知F(x)在[0,1]上连续，在(0,1)可导，且F(0)=F(1).由罗尔定理可知至少存在一点 𝛏∈(0,1)，使得F’(𝛏)=0. 又 $F’(x)=[f’(x)+f’’(x)]e^{-x}-[f(x)+f’(x)]e^{-x}=[f’’(x)-f(x)]e^{-x}$.由于 $e^{-x}\\neq0，可知有f’’(𝛏)-f(𝛏)=0，即f’’(𝛏)=f(𝛏).$ THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[]},{"title":"20170929.3","slug":"2017-09-29-3","date":"2017-09-28T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/09/29/2017-09-29-3/","link":"","permalink":"http://ai.wisim.me/2017/09/29/2017-09-29-3/","excerpt":"题 3:求极限 $\\lim _{\\tiny{x\\rightarrow\\infty}} {(b^{\\tiny{\\dfrac{1}{n}}}-1)}\\sum_{j=0}^{n-1} {b^{\\tiny{\\dfrac{i}{n}}} \\: sin\\: b^{\\tiny{\\dfrac{2i+1}{2n}}}(b&gt;1).}$","text":"题 3:求极限 $\\lim _{\\tiny{x\\rightarrow\\infty}} {(b^{\\tiny{\\dfrac{1}{n}}}-1)}\\sum_{j=0}^{n-1} {b^{\\tiny{\\dfrac{i}{n}}} \\: sin\\: b^{\\tiny{\\dfrac{2i+1}{2n}}}(b&gt;1).}$ 证明:原式 = $\\lim _{\\tiny{x\\rightarrow\\infty}}(b^{\\tiny{\\dfrac {i+1} {n}}}-b^{\\tiny{\\dfrac{i}{n}}})\\sum _{i=0}^{n-1}{sin\\: b^{\\tiny{\\dfrac{2i+1}{2n}}}}$ ,这里的和式可以看作sin x 在[1,b]上划分所做的积分和,区间划分如下: $1=b^{\\tiny\\dfrac{0}{n}}&lt;b^{\\tiny\\dfrac{1}{n}}&lt;b^{\\tiny\\dfrac{2}{n}}&lt;…&lt;b^{\\tiny\\dfrac{n}{n}}=b$ 其中 $\\Delta x_{i}=b^{\\tiny{\\dfrac {i+1} {n}}}-b^{\\tiny{\\dfrac{1}{n}}}$ 是区间 $[b^{\\tiny{\\dfrac{i}{n}}},b^{\\tiny{\\dfrac{i+1}{n}}}]$ 的长度，最大的长度: $\\lambda=max_{\\tiny{0\\leq i \\leq n-1}}\\Delta x_i\\leq b(b^{\\tiny\\dfrac{1}{n}}-1)\\rightarrow0$, $\\xi_i=b^{\\tiny\\dfrac{2i+1}{2n}}\\in[b^{\\tiny{\\dfrac{i}{n}}},b^{\\tiny{\\dfrac{i+1}{n}}}]$ 是小区间两端点的比例中项. 因此原极限= $\\int _{1}^{b}sin\\: xdx=cos\\:1-cos\\:b$. THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[]},{"title":"20170928.2","slug":"2017-09-28-2","date":"2017-09-27T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/09/28/2017-09-28-2/","link":"","permalink":"http://ai.wisim.me/2017/09/28/2017-09-28-2/","excerpt":"题 2:设 y=f(x) 在(-1,1)内有二阶连续导数，且f’’(x)≠0. 证明 (1) 对于任意非零x∈(-1,1),存在唯一 θ(x)∈(0,1), 使得 f(x)=f(0)+xf’[ θ(x),x] 成立； (2) $\\lim _{x\\rightarrow 0^{+}}\\theta \\left( x\\right) =\\dfrac {1} {2}$.","text":"题 2:设 y=f(x) 在(-1,1)内有二阶连续导数，且f’’(x)≠0. 证明 (1) 对于任意非零x∈(-1,1),存在唯一 θ(x)∈(0,1), 使得 f(x)=f(0)+xf’[ θ(x),x] 成立； (2) $\\lim _{x\\rightarrow 0^{+}}\\theta \\left( x\\right) =\\dfrac {1} {2}$. 证明:(1) 对于f(x)在[0,1]上使用拉格朗日定理，得:f(x)-f(0)=xf’[0+θ(x)*(x-0)], f(x)=f(0)+xf’(θ(x)*x). 又f’’(x)≠在[0,1]内连续且f’’(x)≠0,故保号，于是不妨设f’’(x)&gt;0.所以f’(x)严格单调，所以θ(x)唯一. (2) 由泰勒公式有 $f\\left( x\\right) =f\\left( 0\\right) +f’\\left( 0\\right)x +\\dfrac {1} {2}f’’(\\varepsilon )x ^{2}$ 又由(1)中的拉格朗日定理可知：f(x)=f(0)+xf’[θ(x)]. 所以: $f(0)+xf’[θ(x)*x] =f\\left( 0\\right) +f’\\left( 0\\right)x +\\dfrac {1} {2}f’’(\\varepsilon )x ^{2}$ =&gt; $xf’[θ(x)*x] =f’\\left( 0\\right)x +\\dfrac {1} {2}f’’(\\varepsilon )x ^{2}$ =&gt; $\\dfrac {f’[θ(x)*x]-f’(0)}{x} =\\dfrac {1} {2}f’’(\\varepsilon )$ =&gt; $\\lim _{x\\rightarrow 0^{+}} \\dfrac {f’[0+θ(x)*x]-f’(0)} {θ(x)x} θ(x)$ $=\\lim _{x\\rightarrow 0^{+}}f’’(0)*θ(x)$ $=\\lim _{x\\rightarrow 0^{+}}\\dfrac {1} {2}f’’(\\varepsilon ) =\\dfrac {1} {2}f’’(0)$ =&gt; $\\lim _{x\\rightarrow 0^{+}}f’’(0)*θ(x)=\\dfrac {1} {2}f’’(0)$ 因此 $\\lim _{x\\rightarrow 0^{+}}θ(x)=\\dfrac {1} {2}$ THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[]},{"title":"20170927.1","slug":"2017-09-27-1","date":"2017-09-26T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/09/27/2017-09-27-1/","link":"","permalink":"http://ai.wisim.me/2017/09/27/2017-09-27-1/","excerpt":"题 1:设 $0 &lt; a &lt; b$ ,证明：$\\ln \\dfrac {b} {a}&gt;2\\dfrac {b-a} {b+a}$.","text":"题 1:设 $0 &lt; a &lt; b$ ,证明：$\\ln \\dfrac {b} {a}&gt;2\\dfrac {b-a} {b+a}$. 证明:$\\ln \\dfrac {b} {a}&gt;\\dfrac {\\dfrac {b} {a}-1} {\\dfrac {b} {a}+1}$ , 令 $\\dfrac {b} {a}=x$ , 即证 $\\ln x&gt;2\\dfrac {x-1} {x+1}$。 令 F(x) = (1+x)lnx-2(x-1) ，则：$F’\\left( x\\right) =\\dfrac {1} {x}+\\ln x-1$$F’’\\left( x\\right) =-\\dfrac {1} {x^{2}}+\\dfrac {1} {x}=\\dfrac {1} {x}\\left( 1-\\dfrac {1} {x}\\right) &gt; 0$ 因此 F’(x) &gt; F’(1) = 0 ,故 F(x) &gt;F(1)=0。得证。 THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[]},{"title":"使用 UI Automator 来实现Android自动化测试","slug":"2017-05-25-UIAutomator","date":"2017-05-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/05/24/2017-05-25-UIAutomator/","link":"","permalink":"http://ai.wisim.me/2017/05/24/2017-05-25-UIAutomator/","excerpt":"1. 配置直接添加 com.android.support.test 相关依赖的话会报如下冲突：1Error:Conflict with dependency &apos;com.android.support:support-annotations&apos;. Resolved versions for app (25.3.1) and test app (23.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details. 所以需要把 support 包剔除：1234567androidTestCompile (&apos;com.android.support.test:runner:0.5&apos;) &#123; exclude group: &apos;com.android.support&apos;&#125;androidTestCompile (&apos;com.android.support.test:rules:0.5&apos;) &#123; exclude group: &apos;com.android.support&apos;&#125;androidTestCompile &apos;com.android.support.test.uiautomator:uiautomator-v18:2.1.2&apos;","text":"1. 配置直接添加 com.android.support.test 相关依赖的话会报如下冲突：1Error:Conflict with dependency &apos;com.android.support:support-annotations&apos;. Resolved versions for app (25.3.1) and test app (23.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details. 所以需要把 support 包剔除：1234567androidTestCompile (&apos;com.android.support.test:runner:0.5&apos;) &#123; exclude group: &apos;com.android.support&apos;&#125;androidTestCompile (&apos;com.android.support.test:rules:0.5&apos;) &#123; exclude group: &apos;com.android.support&apos;&#125;androidTestCompile &apos;com.android.support.test.uiautomator:uiautomator-v18:2.1.2&apos; 2. 编写业务代码直接新建一个Activity，并修改他的布局文件，在里面添加一个 EditText :1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/id_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;weex.wisim.com.weexdemo.MainDemoActivity&quot;&gt; &lt;EditText android:id=&quot;@+id/id_input&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; /&gt;&lt;/LinearLayout&gt; 3. 编写测试用例这里我们来测试一下 EditText 里面的内容跟我们需要的是不是一致，直接新建一个测试用例 ： 12345678910111213141516@Testpublic void testEdit() &#123; UiDevice uiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation()); try &#123; UiObject allAppsButton = uiDevice.findObject(new UiSelector().description(\"MY\"));//new UiObject(new UiSelector().description(\"MY\")); allAppsButton.clickAndWaitForNewWindow(); UiObject et1 = uiDevice.findObject(new UiSelector().resourceId(\"weex.wisim.com.weexdemo:id/id_input\")); et1.setText(\"2\"); assertEquals(12, Integer.parseInt(et1.getText().toString())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 运行之后发现测试用例未通过。 4. 说明(1) UiDevice 这个对象可以完成一些针对设备的动作UiDevice 对象可以通过如下方式获得： 1UiDevice uiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation()); click(int x, int y) : 在(x,y)表示的像素地方点击 pressBack() : 点击返回键 pressDelete() : 点击删除键 pressEnter() : 点击Enter键 pressHome() : 点击Home键 pressMenu() : 点击Menu键 pressSearch() : 点击Search键 wakeUp() : 当手机处于灭屏状态时，唤醒屏幕，并解锁。 swipe(startX, startY, endX, endY, steps) : 在手机上滑动，从(startX,startY)到(endX,endY)。steps表示滑动的这个距离分为几步完成，数目越少，滑动幅度越大。 setOrientationLeft() / setOrientationRight(): 将手机向相应方向旋转。 setOrientationNatural() : 将手机旋转状态回归正常。 (2) UiObject对象,这个对象可以理解为控件的对象。一般一个UiObject对象可以通过一下形式得到，也就是配合一个UiSelector就可以得到一个控件。： 1UiObject allAppsButton = uiDevice.findObject(new UiSelector().description(\"MY\")); click() : 点击控件 clickAndWaitForNewWindow() : 点击某个控件，并等待窗口刷新 longClick() : 长按 clearTextField() : -清除文本，主要针对编辑框 getChildCount() : 获取子控件个数。这个方法可以看出，其实UiObject也可以是一个控件的集合 getPackageName() : 得到控件的包名 getSelector() : 得到当前控件的选择条件 getText() : 得到控件上的Text isCheckable() : 是否可以被check isChecked() : 是否处于checked状态 isClickable() : 是否可点击 isLongClickable() : 是否可长按 isScrollable() : 是否可滑动 isSelected() : 是否可选中 (3) UiSelector对象,这个对象可以理解为一种条件对象，描述的是一种条件UiSelector经常配合UiObject使用，可以得到某个（某些）符合条件的控件对象。 checked(boolean val) : 描述一种check状态为val的关系。 className(className) : 描述一种类名为className的对象关系 clickable(boolean val) : 与checked类似，描述clickable状态为val的关系 description(desc) : 文案描述 descriptionContains(desc) : 与description类似 focusable(boolean val) : 与checked类似 index(index) : 用当前对象在父对象集中的索引作为描述 packageName(String name) : 用包名作为条件描述 selected(val) : 描述一种选择关系 text(text) : 最为常用的一种关系，用控件上的文本即可找到当前控件，需要注意，所有使用text属性找到的控件，必须是英文的。也就是说，不支持通过中文查找控件！ textContains(text) : 与text类似 textStartsWith(text) : 与text类似 (4) UiCollection对象，这个对象可以理解为一个对象的集合。因为UiSelector描述后得到的有可能是多个满足条件的控件集合，因此可以用来生成UiCollection: 1UiCollection mUiCollection = new UiCollection(new UiSelector().text(\"Settings\")); getChild(selector) : 从集合中再次通过UiSelector选择一个UiObject对象 getChildByDescription(childPattern, text) : 从一个匹配模式中再次以text为条件选择UiObject getChildByText(childPattern, text) : 与上面类似。 getChildCount() : 得到当前集合中控件的个数 (5) UiScrollable可以生成一个滚动动作的对象，其最大的作用就是可以实现滚动的查找某个元素。比如在“设置”菜单中，“语言和输入法”这个菜单比较靠下，需要滚动后才可以看到（找到），因此就用上了UiScrollable： 1234UiScrollable settingItems = new UiScrollable( new UiSelector().scrollable(true)); UiObject languageAndInputItem = settingItems.getChildByText( new UiSelector().text(\"Language &amp; input\"), \"Language &amp; input\", true); 上面的形式就可以在滚动中查找显示有“Language &amp; input”的控件，也就是“语言和输入法”的设置项。 (6) 添加Log的方法也可以通过Java标准的println来实现System.out.println(“This used to print some log!!!” + setLanItem.getText()); THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Print all sub-array with 0 sum","slug":"2017-04-19-AlogrithmPrintSubarray","date":"2017-04-16T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/04/17/2017-04-19-AlogrithmPrintSubarray/","link":"","permalink":"http://ai.wisim.me/2017/04/17/2017-04-19-AlogrithmPrintSubarray/","excerpt":"1234567891011121314151617Given an array of integers, print all subarrays having 0 sum.For example,Input: &#123; 4, 2, -3, -1, 0, 4 &#125;Sub-arrays with 0 sum are&#123; -3, -1, 0, 4 &#125;&#123; 0 &#125;Input: &#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125;Sub-arrays with 0 sum are&#123; 3, 4, -7 &#125;&#123; 4, -7, 3 &#125;&#123; -7, 3, 1, 3 &#125;&#123; 3, 1, -4 &#125;&#123; 3, 1, 3, 1, -4, -2, -2 &#125;&#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125;","text":"1234567891011121314151617Given an array of integers, print all subarrays having 0 sum.For example,Input: &#123; 4, 2, -3, -1, 0, 4 &#125;Sub-arrays with 0 sum are&#123; -3, -1, 0, 4 &#125;&#123; 0 &#125;Input: &#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125;Sub-arrays with 0 sum are&#123; 3, 4, -7 &#125;&#123; 4, -7, 3 &#125;&#123; -7, 3, 1, 3 &#125;&#123; 3, 1, -4 &#125;&#123; 3, 1, 3, 1, -4, -2, -2 &#125;&#123; 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 &#125; 意思就是给定一个数组，找到所有和为0的子数组。 解法1：暴力求解双重循环，从当前数组开始往后遍历，找到和为0的子数组。时间复杂度是O(n^3)，其中O(n^2)用于遍历出子数组，O(n)用于计算和。 解法2：使用HashMap来解决构造一个 Map&lt;Integer, ArrayList&gt; hashMap 用来存放遍历数组，以当前位置（包含当前位置）之前的所有元素之和sum为key，如果hashMap中不存在这个key，则将这个key插入到hashMap中，并将这个元素所在位置插入到对应的ArrayList中。如果hashMap中已经存在这个key，则遍历key对应的ArrayList，以ArrayList中(每个元素所在位置+1)为起始值，当前元素所在位置为结束值，这之间的子数组的和就是0，接着还是要把当前位置插入到已经存在的key所对应的ArrayList中。 举个例子：数组{ 3, 4, -7, 3, 1, 3, 1, -4, -2, -2 }我们来一步一步的分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374(1)首先初始化的时候插入key为0，对应的ArrayList中插入-1，这样以后如果找到子数组就是从位置0开始了。插入之后hashMap的内容是：&#123;0,[-1]&#125;(2)位置0的元素为3，hashMap中不含(0+3=3)。插入之后hashMap的内容是：&#123;0,[-1]&#125;,&#123;3,[0]&#125;(3)位置1的元素是4,hashMap中不含(3+4=7)，插入之后hashMap的内容是：&#123;0,[-1]&#125;,&#123;3,[0]&#125;,&#123;7,[1]&#125;(4)位置2的元素是-7,hashMap包含(-7+7=0)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0]&#125;,&#123;7,[1]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[0,1,2](5)位置3的元素是3,hashMap包含(0+3=3)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[1,2,3](6)位置4的元素是1,hashMap不含(1+3=4)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1]&#125;,&#123;4,[4]&#125;(7)位置5的元素是3,hashMap包含(4+3=7)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[2,3,4,5](8)位置6的元素是1,hashMap不含(7+1=8)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4]&#125;,&#123;8,[6]&#125;(9)位置7的元素是-4,hashMap包含(-4+8=4)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4,7]&#125;,&#123;8,[6]&#125;并且此时有一个满足条件的子数组，对应的位置序列：[5,6,7](10)位置8的元素是-2,hashMap包含(-2+4=2)，插入之后hashMap的内容是：&#123;0,[-1,2]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4,7]&#125;,&#123;8,[6]&#125;,&#123;2,[8]&#125;(11)位置9的元素是-2,hashMap包含(-2+2=0)，插入之后hashMap的内容是：&#123;0,[-1,2,9]&#125;,&#123;3,[0,3]&#125;,&#123;7,[1,5]&#125;,&#123;4,[4,7]&#125;,&#123;8,[6]&#125;,&#123;2,[8]&#125;并且此时有两个满足条件的子数组，对应的位置序列：[0,1,2,3,4,5,6,7,8,9][3,4,5,6,7,8,9] 来总结一下这种解法的:这种解法的时间复杂度是O(n)。初始化的时候向hashMap中插入了key为0的一个元素，这一步很重要。之后从数组中遍历出的元素累加，每次累加得到的结果肯定会发生变化。如果发现某一次累加之后的值之前已经出现过一次，说明什么，说明在第一次出现这个值之后中间的累加操作一定会使得第一次之后（不包含第一次）到第二次（包含第二次）的和的值为0。 ￼￼结合下面这张折线图来看一下： 从-1位置开始，初始sum为0，经过了0，1，2三个位置的元素累加之后，sum又重新变为0。这期间发生了什么呢，依次发生了+3，+4，-7的操作，所以一旦发现两次的累加的和相等的话，表明这之间一定经过了和为0的加减操作。同理，其他几个位置的变化也是如此。 我们再用数学公式抽象一下：设从 0 到 i 位置的累加和为 Si且i位置的元素为e[i]，从 0 到 n 位置的累加和为 Sn且n位置的元素为e[n]，Si = Sn。 从累加的定义我们知道： S_{i} + e[i+1] = S_{i+1}于是可以得到： S_i + e[i+1] + e[i+2] + ... + e[n] = S_n又有：S_i = S_n 所以 e[i+1] + e[i+2] + ... + e[n] = 0 。也就是从 i+1 开始到 n 的子数组之和为0 Link : find-sub-array-with-0-sum THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"http://ai.wisim.me/tags/DynamicProgramming/"}]},{"title":"Sunday 算法","slug":"2017-04-17-AlogrithmSunday","date":"2017-04-16T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/04/17/2017-04-17-AlogrithmSunday/","link":"","permalink":"http://ai.wisim.me/2017/04/17/2017-04-17-AlogrithmSunday/","excerpt":"KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，有一种比BM算法更快的查找算法即Sunday算法。","text":"KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，有一种比BM算法更快的查找算法即Sunday算法。 Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似： 只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1； 否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。 下面举个例子说明下Sunday算法。假定现在要在文本串”substring searching algorithm”中查找模式串”search”。 1.刚开始时，把模式串与文本串左边对齐： 2.结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图： 3.结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下： 4.匹配成功。 回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。 THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"String","slug":"String","permalink":"http://ai.wisim.me/tags/String/"}]},{"title":"Android Service相关问题","slug":"2017-03-30-AndroidServiceProblems","date":"2017-03-29T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/03/30/2017-03-30-AndroidServiceProblems/","link":"","permalink":"http://ai.wisim.me/2017/03/30/2017-03-30-AndroidServiceProblems/","excerpt":"一、Service里面的 onStartCommand() 方法详解通过 startService() 多次启动service的时候，onCreate方法只有第一次会调用，onStartCommand和onStart每次都被调用。onStartCommand会告诉系统如何重启服务， 比如会判断是否异常终止后重新启动，以及在何种情况下异常终止Service。","text":"一、Service里面的 onStartCommand() 方法详解通过 startService() 多次启动service的时候，onCreate方法只有第一次会调用，onStartCommand和onStart每次都被调用。onStartCommand会告诉系统如何重启服务， 比如会判断是否异常终止后重新启动，以及在何种情况下异常终止Service。 二、Service两种启动方式的生命周期对比 启动服务时依次执行onCreate，onStartCommand；如果在系统显示调用stopService和stopSelf之前终止服务，service再次重启，onStartCommand会被调用。 三、onStartCommand和onStart区别1234567891011121314151617// This is the old onStart method that will be called on the pre-2.0// platform. On 2.0 or later we override onStartCommand() so this// method will not be called.// 2.0 API level之后，实现onStart等同于重写onStartCommand并返回START_STICKY@Overridepublic void onStart(Intent intent, int startId) &#123;handleCommand(intent);&#125;// 2.0 API level之后，onStart()方法被onStartCommand()取代了@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123;handleCommand(intent);// We want this service to continue running until it is explicitly// stopped, so return sticky.return START_STICKY;&#125; 四、onStartCommand返回值onStartComand使用时，返回的是一个int值。这个整型可以有四个返回值： 1.START_STICKY 如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。 2.START_NOT_STICKY “非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务 3.START_REDELIVER_INTENT 重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。 4.START_STICKY_COMPATIBILITY。 START_STICKY的兼容版本，但不保证服务被kill后一定能重启。 五、onStartComand参数flags含义flags表示启动服务的方式： Additional data about this start request. Currently either 0, START_FLAG_REDELIVERY, or START_FLAG_RETRY. START_FLAG_REDELIVERY ：如果你实现onStartCommand()来安排异步工作或者在另一个线程中工作, 那么你可能需要使用START_FLAG_REDELIVERY 来让系统重新发送一个intent。这样如果你的服务在处理它的时候被Kill掉, Intent不会丢失. START_FLAG_RETRY：表示服务之前被设为START_STICKY，则会被传入这个标记。 六、Service和线程的区别我们都知道普通的Service是运行在主线程里的，也就是说如果你在Service里编写了非常耗时的代码，程序必定会出现ANR的。 那我要Service又有何用呢？其实大家不要把后台和子线程联系在一起就行了，这是两个完全不同的概念。Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。你可能又会问，前面不是刚刚验证过Service是运行在主线程里的么？在这里一直执行着心跳连接，难道就不会阻塞主线程的运行吗？当然会，但是我们可以在Service中再创建一个子线程，然后在这里去处理耗时逻辑就没问题了。 那既然在Service里也要创建一个子线程，那为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Java静态多态和动态多态","slug":"2017-03-22-JavaAssign","date":"2017-03-20T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/03/21/2017-03-22-JavaAssign/","link":"","permalink":"http://ai.wisim.me/2017/03/21/2017-03-22-JavaAssign/","excerpt":"静态分派所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派，静态分派的最典型应用就是多态性中的方法重载。 动态分派根据变量的实际类型来分派方法的执行版本的。而实际类型的确定需要在程序运行时才能确定下来，这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。","text":"静态分派所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派，静态分派的最典型应用就是多态性中的方法重载。 动态分派根据变量的实际类型来分派方法的执行版本的。而实际类型的确定需要在程序运行时才能确定下来，这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。 单分派和多分派方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派是根据多个宗量对目标方法进行选择。 方法重载属于静态多分派 方法重写属于动态单分派 多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[]},{"title":"Alarm实现机制分析","slug":"2017-03-06-AndroidAlarm","date":"2017-03-05T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/03/06/2017-03-06-AndroidAlarm/","link":"","permalink":"http://ai.wisim.me/2017/03/06/2017-03-06-AndroidAlarm/","excerpt":"alarm的使用这里就不说了，来看看alarm是怎么实现提醒的。","text":"alarm的使用这里就不说了，来看看alarm是怎么实现提醒的。 当我们创建一个alarm的时候，是先加到一个 batch 中，系统中有一个 batch 列表，专门用于存储所有的alarm。AlarmManagerService 中会启动一个 AlarmThread 线程，不停的遍历这个 batch 列表，一旦发现有alram的时间已经到达，就把它取出来，然后发送一个PendingIntent。 System.currentTimeMillis() 系统时间，也就是日期时间，可以被系统设置修改，然后值就会发生跳变。 SystemClock.uptimeMillis() 自开机后，经过的时间，不包括深度睡眠的时间 SystemClock.elapsedRealtime() 自开机后，经过的时间，包括深度睡眠的时间 参考网址 :http://blog.csdn.net/singwhatiwanna/article/details/18448997 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"学习MachineLearning过程中的一些问题","slug":"2017-03-05-MachineLearningFAQ","date":"2017-03-04T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/03/05/2017-03-05-MachineLearningFAQ/","link":"","permalink":"http://ai.wisim.me/2017/03/05/2017-03-05-MachineLearningFAQ/","excerpt":"环境相关 python Anaconda Anaconda 本质上是一个软件发行版 ，包含了 conda、Python 等 180 多个科学包及其依赖项。 pydot pydot是用python实现的绘制graphviz的接口。 graphviz Graphviz的是AT&amp;T Labs Research开发的图形绘制工具软件如果运行过程中报出 Exception: &quot;dot&quot; not found in path. 则需要安装 graphviz，如果已经安装了Anacoda，直接执行 conda install graphviz。","text":"环境相关 python Anaconda Anaconda 本质上是一个软件发行版 ，包含了 conda、Python 等 180 多个科学包及其依赖项。 pydot pydot是用python实现的绘制graphviz的接口。 graphviz Graphviz的是AT&amp;T Labs Research开发的图形绘制工具软件如果运行过程中报出 Exception: &quot;dot&quot; not found in path. 则需要安装 graphviz，如果已经安装了Anacoda，直接执行 conda install graphviz。 概念问题 分类 聚类 回归 异常检测 关联规则 强化学习 结构预测 特征学习 在线学习 半监督学习 语法归纳 监督学习 分类 ： 输出值如果是不连续的监督学习算法称为分类器（classifier）。 回归 ： 输出值连续的监督学习算法称为回归函数（regression function）。 线性回归 代价函数 ： J(\\theta)=\\frac{1}{2m}\\sum_{i=1}^m{({h_\\theta }({x^{(i)}})-{y^{(i)}})^{2}}向量化实现 : J(\\theta)=\\frac{1}{2m}(X*\\theta-\\vec{y})^{T} (X*\\theta-\\vec{y}) 归一化 : y_{i}=\\frac{x_{i}-\\overline{x}}{s(x)} 梯度下降算法 : 代价函数对 \\theta_j 求偏导得到 : \\frac{\\partial{J(\\theta)}}{\\partial{\\theta_j}} = \\frac{1}{m}\\sum\\limits_{i = 1}^m {[({h_\\theta }({x^{(i)}})-{y^{(i)}})x_j^{(i)}]}所以对 \\theta 的更新可以写为 : {\\theta_j}={\\theta_j}-\\alpha\\frac{1}{m}\\sum\\limits_{i=1}^m {[({h_\\theta }({x^{(i)}})-{y^{(i)}})x_j^{(i)}]} 向量化实现 : {\\theta_j} = {\\theta_j}-{\\alpha\\frac{1}{m}(X^T(X*{\\theta- \\vec{y}}))} 分类器 人工神经网络 支持向量机（support vector machine） 最邻近法 高斯混合模型 朴素贝叶斯法 决策树（decision tree） 径向量函数分类 解决步骤 决定训练的样本类型 搜集训练集 决定学习函数的特征表示 决定学习函数的结构以及对应的学习算法 完成设计 评价学习函数的准确性 决策树 表征（装袋, 提升，随机森林） k-NN 线性回归 朴素贝叶斯 神经网络 逻辑回归 感知器 支持向量机（SVM） 相关向量机（RVM） 聚类 BIRCH 层次 k平均 期望最大化（EM） DBSCAN OPTICS 均值飘移 降维 因子分析 CCA ICA LDA NMF PCA LASSO t-SNE 结构预测 概率图模型（贝叶斯网络，CRF, HMM） 异常检测 k-NN 局部离群因子 神经网络 自编码 深度学习 多层感知机 RNN 受限玻尔兹曼机 SOM CNN 理论 偏差/方差偏置(Bias-Variance Tradeoff)：一般而言高偏差意味着欠拟合，高方差意味着过拟合 计算学习理论 经验风险最小化 PAC学习 统计学习 VC理论 THE END.","categories":[{"name":"ML","slug":"ML","permalink":"http://ai.wisim.me/categories/ML/"}],"tags":[]},{"title":"RxAndroid","slug":"2017-02-24-RxAndroid","date":"2017-02-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/02/24/2017-02-24-RxAndroid/","link":"","permalink":"http://ai.wisim.me/2017/02/24/2017-02-24-RxAndroid/","excerpt":"Observer创建Observer :12345678910111213141516Observer observer = new Observer&lt;Model&gt;() &#123; @Override public void onComplete() &#123; ...... &#125; @Ovrride public void onError(Throwable e) &#123; ...... &#125; @Override public void onNext(Model model) &#123; ...... &#125;&#125;;","text":"Observer创建Observer :12345678910111213141516Observer observer = new Observer&lt;Model&gt;() &#123; @Override public void onComplete() &#123; ...... &#125; @Ovrride public void onError(Throwable e) &#123; ...... &#125; @Override public void onNext(Model model) &#123; ...... &#125;&#125;; Observable创建Observable :1234567Observable observable = Observable.create(new Observable.OnSubscribe&lt;Model&gt;() &#123; @Override public void call(Subcriber&lt;? extends Model&gt; subcriber) &#123; ...... subcriber.onComplete(); &#125;&#125;); 其他方式创建Observable :12Observable.from(model...);Observable.just(model); OnSubscribe :123public interface OnSubscribe&lt;T&gt; extends Action1&lt;Subscriber&lt;? super T&gt;&gt; &#123; // cover for generics insanity&#125; subcribe()1observable.subcribe(obsever); Action0 and Action1自定义Subcriber :1234567891011121314151617Action1&lt;Model&gt; nextAction= new Action1&lt;Model&gt;() &#123; @Override public void call(Model model) &#123; ...... &#125;&#125;Action0 completeAction= new Action0() &#123; @Override public void call() &#123; ...... &#125;&#125;observable.subscribe(nextAction);//observable.susbcribe(nextAction,errorAction);//observable.subscribe(nextAction,errorAction,completeAction); Scheduler线程控制12345678910Observable .from(new String[]&#123;\"HE\", \"LLO\"&#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; android.util.Log.d(TAG, \"loadNewProductData action1 : \" + s); &#125; &#125;); Observable 通过 subscribeOn 来指定事件产生的线程，也就是指定创建Observable的线程，用 observeOn 指定 Subscriber 所运行的线程，也就是指定回调函数执行的线程。 Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 变换 所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列 map()123456789101112131415161718Observable .just(-1) .map(new Func1&lt;Integer, String&gt;() &#123; @Override public String call(Integer integer) &#123; ...... return String.valueOf(integer); &#125; &#125;) .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; ...... android.util.Log.d(TAG, \"loadNewProductData action1 : \" + s); &#125; &#125;); 可以看到这里把传入的Integer对象转换成了String对象，并在Observer的回调函数中接收了String对象，这就是上面说的变换。 注意这里 map() 里面的时间还是发生在当前线程，如果是在主线程的话可能会导致线程阻塞。需要使用上面的 Schedulers 来指定运行的线程。 flatMap()12345678910111213141516171819Observable .from(new String[]&#123;\"HE\", \"LLO\"&#125;) .flatMap(new Func1&lt;String, Observable&lt;Character&gt;&gt;() &#123; @Override public Observable&lt;Character&gt; call(String str) &#123; Character[] characters = new Character[str.length()]; for (int i = 0; i &lt; str.length(); i++) &#123; characters[i] = str.charAt(i); &#125; return Observable.from(characters); &#125; &#125;) .subscribe(new Action1&lt;Character&gt;() &#123; @Override public void call(Character c) &#123; android.util.Log.d(TAG, \"subscribeAction1 : \" + c); &#125; &#125;); 这里的需求是把String数组变换成String,在把String变换成Character flatMap()方法参数Func1的返回值是一个Observable，相当于用String数组里的每个String再构造了一个Observable，然后传递给Subscriber里的Action，这里就接收到拆开之后的每个Character了。 map() 方法相当于一对一的转换，而 flatMap() 有点类似于多（一）对多的转换。 参考：http://gank.io/post/560e15be2dca930e00da1083 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"Rx","slug":"Rx","permalink":"http://ai.wisim.me/tags/Rx/"}]},{"title":"Java 中的 IncompatibleClassChangeError 错误","slug":"2017-02-23-JavaIncompatibleClassChangeError","date":"2017-02-22T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/02/23/2017-02-23-JavaIncompatibleClassChangeError/","link":"","permalink":"http://ai.wisim.me/2017/02/23/2017-02-23-JavaIncompatibleClassChangeError/","excerpt":"最近发现了一个从来没遇到过的崩溃 IncompatibleClassChangeError ,出现这种错误的原因可能是因为jar包的代码发生了一些无法执行 二进制兼容 的变化。最有可能的是将非静态的成员变量或者方法变成了静态的，还有将私有的成员变量和方法变成了共有的。并且引用jar包的客户端没有重新编译源码。 IncompatibleClassChangeError 这个错误只是二进制兼容问题其中的一种错误。","text":"最近发现了一个从来没遇到过的崩溃 IncompatibleClassChangeError ,出现这种错误的原因可能是因为jar包的代码发生了一些无法执行 二进制兼容 的变化。最有可能的是将非静态的成员变量或者方法变成了静态的，还有将私有的成员变量和方法变成了共有的。并且引用jar包的客户端没有重新编译源码。 IncompatibleClassChangeError 这个错误只是二进制兼容问题其中的一种错误。 一、如下几种情况是Java支持的二进制兼容的变化： Reimplementing existing methods, constructors, and initializers to improve performance. Changing methods or constructors to return values on inputs for which they previously either threw exceptions that normally should not occur or failed by going into an infinite loop or causing a deadlock. Adding new fields, methods, or constructors to an existing class or interface. Deleting private fields, methods, or constructors of a class. When an entire package is updated, deleting default (package-only) access fields, methods, or constructors of classes and interfaces in the package. Reordering the fields, methods, or constructors in an existing type declaration. Moving a method upward in the class hierarchy. Reordering the list of direct superinterfaces of a class or interface. Inserting new class or interface types in the type hierarchy. 二、可能不兼容的二进制变化 从非abstract类变为abstract类（注意从abstract类变为非abstract类不会引起二进制兼容问题） 从非final类变为final类 （注意从final类变为非final类不会引起二进制兼容问题） 从public类变为非public类 （注意从非public类变为public类不会引起二进制兼容问题） 改变类的类型参数的约束 删除一个类的非private构造函数或者非private成员变量 非static的函数或者成员变量变成static，反之亦然 其他还有好多种可以参考下面的文档。 参考文档 ：http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html 这里有一个工具可以检测二进制变化 ：https://github.com/lvc/japi-compliance-checker THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[]},{"title":"Android ANR 分析的几个要点","slug":"2017-02-22-AndroidANRAnalysis","date":"2017-02-21T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2017/02/22/2017-02-22-AndroidANRAnalysis/","link":"","permalink":"http://ai.wisim.me/2017/02/22/2017-02-22-AndroidANRAnalysis/","excerpt":"一、找到trace.txt中的ANR1234----- pid 23835 at 2017-02-21 20:11:48 -----Cmd line: com.wisim.example...... trace.txt中,上面这种形式就是一个ANR日志的开始标志了。一个trace.txt中会有好多ANR，有的可能在界面上弹出提示框，有的没有。","text":"一、找到trace.txt中的ANR1234----- pid 23835 at 2017-02-21 20:11:48 -----Cmd line: com.wisim.example...... trace.txt中,上面这种形式就是一个ANR日志的开始标志了。一个trace.txt中会有好多ANR，有的可能在界面上弹出提示框，有的没有。 二、ANR类型1. CPU满负荷12345678...CPU usage from 3330ms to 814ms ago:6% 178/system_server: 3.5% user + 1.4% kernel / faults: 86 minor 20 major4.6% 2976/com.anly.githubapp: 0.7% user + 3.7% kernel /faults: 52 minor 19 major0.9% 252/com.android.systemui: 0.9% user + 0% kernel...100%TOTAL: 5.9% user + 4.1% kernel + 89% iowait 看到最后一行表明： 当是CPU占用100%, 满负荷了. 其中绝大数是被iowait即I/O操作占用了. 此时分析方法调用栈, 一般来说会发现是方法中有频繁的文件读写或是数据库读写操作放在主线程来做了. 2. 内存原因123456789101112131415161718......DALVIK THREADS:&quot;main&quot;prio=5 tid=3 VMWAIT|group=&quot;main&quot; sCount=1 dsCount=0 s=N obj=0x40026240self=0xbda8| sysTid=1815 nice=0 sched=0/0 cgrp=unknownhandle=-1344001376atdalvik.system.VMRuntime.trackExternalAllocation(NativeMethod)atandroid.graphics.Bitmap.nativeCreate(Native Method)atandroid.graphics.Bitmap.createBitmap(Bitmap.java:468)atandroid.view.View.buildDrawingCache(View.java:6324)atandroid.view.View.getDrawingCache(View.java:6178)......MEMINFO in pid 1360 [android.process.acore] ** native dalvik other totalsize: 17036 23111 N/A 40147allocated: 16484 20675 N/A 37159free: 296 2436 N/A 2732 free那行就是剩余的内存，可以看到free的内存已所剩无几.当然这种情况可能更多的是会产生OOM的异常. 查看内存信息也可以搜搜看如下代码1RAM: 2932124K total, 603160K free, 19100K buffers, 382832K cached, 3496K shmem, 77900K slab\\ 3. 线程死锁123456789101112&quot;main&quot; prio=5 tid=1 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x763ac390 self=0xf48a4500 ...... at com.tencent.android.tpush.common.p.a(ProGuard:96) at com.tencent.android.tpush.common.n.a(ProGuard:107) at com.tencent.android.tpush.service.channel.b.m(ProGuard:808) at com.tencent.android.tpush.service.channel.b.k(ProGuard:609) - locked &lt;0x0e28719c&gt; (a com.tencent.android.tpush.service.channel.b) at com.tencent.android.tpush.service.channel.b.f(ProGuard:75) at com.tencent.android.tpush.service.channel.j.onReceive(ProGuard:791) at ...... 12345678910&quot;TpnsClient&quot; prio=5 tid=32 Blocked | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x32ee3160 self=0xee818200 | sysTid=5469 nice=0 cgrp=bg_non_interactive sched=0/0 handle=0xdd5fa930 | state=S schedstat=( 0 0 0 ) utm=5 stm=1 core=1 HZ=100 | stack=0xdd4f8000-0xdd4fa000 stackSize=1038KB | held mutexes= at com.tencent.android.tpush.service.channel.b.a(ProGuard:912) - waiting to lock &lt;0x0e28719c&gt; (a com.tencent.android.tpush.service.channel.b) held by thread 1 at com.tencent.android.tpush.service.channel.a.a.b(ProGuard:121) at com.tencent.android.tpush.service.channel.a.a.run(ProGuard:161) 这里tid=1的线程locked 这个锁，而tid=32的线程又在waiting to lock 还有循环等待的情况，也会导致死锁发生ANR。 4. 其他原因当然其他异常也会导致出现ANR。这个要在实践中积累。最主要的还是要耐心分析。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android ViewDragHelper","slug":"2016-11-16-AndroidViewDragHelper","date":"2016-11-15T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/11/16/2016-11-16-AndroidViewDragHelper/","link":"","permalink":"http://ai.wisim.me/2016/11/16/2016-11-16-AndroidViewDragHelper/","excerpt":"ViewDragHelper 作为处理手势滑动，实现复杂滑动效果很有一套。一起来看看它的实现原理。","text":"ViewDragHelper 作为处理手势滑动，实现复杂滑动效果很有一套。一起来看看它的实现原理。 一、先来看看 ViewDragHelper 的 shouldInterceptTouchEvent 方法：(1) 从 MotionEvent.ACTION_DOWN 开始：12345678910111213141516171819202122switch (action) &#123; case MotionEvent.ACTION_DOWN: &#123; final float x = ev.getX(); final float y = ev.getY(); final int pointerId = MotionEventCompat.getPointerId(ev, 0); saveInitialMotion(x, y, pointerId); final View toCapture = findTopChildUnder((int) x, (int) y); // Catch a settling view if possible. if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123; tryCaptureViewForDrag(toCapture, pointerId); &#125; final int edgesTouched = mInitialEdgesTouched[pointerId]; if ((edgesTouched &amp; mTrackingEdges) != 0) &#123; mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId); &#125; break; &#125; ......&#125; 调用 findTopChildUnder 方法，根据 x,y 的值找到当前坐标下的第一个子View。 123if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123; tryCaptureViewForDrag(toCapture, pointerId);&#125; 先是判断如果刚刚拿到的子View就是想要拖拽的子View，并且当前的状态是自然滚动状态，则调用 tryCaptureViewForDrag ： 123456789101112boolean tryCaptureViewForDrag(View toCapture, int pointerId) &#123; if (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123; // Already done! return true; &#125; if (toCapture != null &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123; mActivePointerId = pointerId; captureChildView(toCapture, pointerId); return true; &#125; return false;&#125; 如果当前拖拽的View已经是mCapturedView，并且 mActivePointerId == pointerId 则表明已经获取了需要拖拽的View，直接返回true。否则调用 mCallback.tryCaptureView(toCapture, pointerId) 主动判断，再调用 captureChildView 方法： 1234567891011public void captureChildView(View childView, int activePointerId) &#123; if (childView.getParent() != mParentView) &#123; throw new IllegalArgumentException(\"captureChildView: parameter must be a descendant \" + \"of the ViewDragHelper's tracked parent view (\" + mParentView + \")\"); &#125; mCapturedView = childView; mActivePointerId = activePointerId; mCallback.onViewCaptured(childView, activePointerId); setDragState(STATE_DRAGGING);&#125; 这里就是赋值一下内部的成员变量以及更新拖动的状态为 STATE_DRAGGING。 (2) 再看看 MotionEvent.ACTION_MOVE 里面：123456789101112131415161718192021222324252627282930313233343536373839404142case MotionEvent.ACTION_MOVE: &#123; // First to cross a touch slop over a draggable view wins. Also report edge drags. final int pointerCount = MotionEventCompat.getPointerCount(ev); for (int i = 0; i &lt; pointerCount; i++) &#123; final int pointerId = MotionEventCompat.getPointerId(ev, i); final float x = MotionEventCompat.getX(ev, i); final float y = MotionEventCompat.getY(ev, i); final float dx = x - mInitialMotionX[pointerId]; final float dy = y - mInitialMotionY[pointerId]; final View toCapture = findTopChildUnder((int) x, (int) y); final boolean pastSlop = toCapture != null &amp;&amp; checkTouchSlop(toCapture, dx, dy); if (pastSlop) &#123; final int oldLeft = toCapture.getLeft(); final int targetLeft = oldLeft + (int) dx; final int newLeft = mCallback.clampViewPositionHorizontal(toCapture, targetLeft, (int) dx); final int oldTop = toCapture.getTop(); final int targetTop = oldTop + (int) dy; final int newTop = mCallback.clampViewPositionVertical(toCapture, targetTop, (int) dy); final int horizontalDragRange = mCallback.getViewHorizontalDragRange( toCapture); final int verticalDragRange = mCallback.getViewVerticalDragRange(toCapture); if ((horizontalDragRange == 0 || horizontalDragRange &gt; 0 &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == 0 || verticalDragRange &gt; 0 &amp;&amp; newTop == oldTop)) &#123; break; &#125; &#125; reportNewEdgeDrags(dx, dy, pointerId); if (mDragState == STATE_DRAGGING) &#123; break; &#125; if (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123; break; &#125; &#125; saveLastMotion(ev); break;&#125; mCallback.clampViewPositionHorizontal 是用来获取拖拽的子View toCapture 在竖直方向上的 top 值。在实现 mCallback 的 clampViewPositionVertical 方法时，可以根据 targetTop 值以及你的需求，返回一个范围内的值。 接着看： 123if (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123; break;&#125; 同样是调用 tryCaptureViewForDrag 方法，就不赘述了。 题外话：关于使用位运算的技巧：ViewDragHelper 内部定义了几个静态成员变量： 1234public static final int EDGE_LEFT = 1 &lt;&lt; 0; //0001public static final int EDGE_RIGHT = 1 &lt;&lt; 1; //0010public static final int EDGE_TOP = 1 &lt;&lt; 2; //0100public static final int EDGE_BOTTOM = 1 &lt;&lt; 3; //1000 在 saveInitialMotion 保存位置信息的时候会调用 getEdgesTouched 方法： 12345678private int getEdgesTouched(int x, int y) &#123; int result = 0; if (x &lt; mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT; if (y &lt; mParentView.getTop() + mEdgeSize) result |= EDGE_TOP; if (x &gt; mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT; if (y &gt; mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM; return result;&#125; 这样使用 | 和 &amp; 位操作可以让 mInitialEdgesTouched 数组里面的某一位保存多个边界状态。这种思路很有趣。比如说我一个手势，既在左边界又在上边界，这个时候就会执行： 123int result = 0;if (x &lt; mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;if (y &lt; mParentView.getTop() + mEdgeSize) result |= EDGE_TOP; result 执行两次 | 操作之后会得到 0101 如果我要判断这个收拾是否在上边界，可以直接和 EDGE_TOP 执行 &amp; 操作： 1234int code = result &amp; EDGE_TOP;if (code == EDGE_TOP) &#123; ......&#125; 这样就可以判断收拾是否在上边界了，同理也可以判断是否在左边界。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Java中 a=a+b 和 a+=b 的区别","slug":"2016-10-29-JavaPlusEqual","date":"2016-10-28T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/10/29/2016-10-29-JavaPlusEqual/","link":"","permalink":"http://ai.wisim.me/2016/10/29/2016-10-29-JavaPlusEqual/","excerpt":"千万不要放过任何一个小的知识点（一个这么小的点也可以拿来写一篇文章 哈？）","text":"千万不要放过任何一个小的知识点（一个这么小的点也可以拿来写一篇文章 哈？） 首先网传 a+=b 的效率会比 a=a+b 的效率要高一点，但是我验证了一下，好像并没有这回事。运行 1000000000 次 a=a+1的时间和 a+=1的时间几乎差不多，而且有时候前者快，有时候后者快。这里就不讨论效率高低这个区别了。 说一下另外一个很显著的区别： += 这个运算中包含了强制转换的操作。所以当我们把两个不同类型的变量使用 += 操作的时候，其实编译器已经自动帮我们强制转型了。而 =+ 并没有自动转型，所以如果我们没有手动强制转型的话，编译的时候是会报错的。 看一下测试代码： 12345678public class PlusEqual &#123; static char a = 1; static int b = 3; public static void main(String[] args) &#123; a += b; a = a + b;//(char)(a + b); &#125;&#125; 现在我们编译的话，是会报错的： 12错误: 不兼容的类型: 从int转换到char可能会有损失 a = a + b; 因为此时a+b此时得到的结果是int，不能直接赋给 char 型的 a。需要强制转型成 a = (char)(a + b); 要记住两点： 一、运算过程中，低精度的类型向高精度类型转换。二、如果将高精度的数值赋值给低精度类型变量，则必须要进行显性的强制转换。 课外阅读：关于小数浮点数精度的问题你猜 System.out.println(0.1 * 3); 打印出来的结果是什么？对，是 0.30000000000000004。这就是我们要讨论的小数浮点数的精度问题，而整数浮点数没有精度这个问题。为啥子呢？ 先说整数为啥没有这个问题，其实不管是小数还是整数，计算机都是使用二进制存储的。例如 3 用二进制可以表示为 11。因为 2^0 = 1, 2^1 = 2，就这两，我一个一个往上怼，就可以表示一切整数了，对吧，我就不证明了啊哈哈（不会）。 但是小数呢？ 2^-1 = 0.5 , 2^-2 = 0.25。由于 double 的长度是64位，其中符号位S占1位，阶码e占11位，尾数M占52位。最终浮点数可以表达为：(-1)^S * M * 2(e)。这样能精确表达的出来的小数其实是有限的，比如 0.25可以直接表达成：(-1)^0 * 1.000000000000 * 2^(-2)。但是0.3这种小数呢？很显然是无法精确表达的，只能通过近似表达，精确到小数点后的16位。 这样也引申出了一个题目哟：3 * 0.1 == 0.3 将会返回什么？true 还是 false？ THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[]},{"title":"Java多线程-ThreadLocal的使用","slug":"2016-10-22-JavaThreadLocal","date":"2016-10-24T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/10/25/2016-10-22-JavaThreadLocal/","link":"","permalink":"http://ai.wisim.me/2016/10/25/2016-10-22-JavaThreadLocal/","excerpt":"ThreadLocal的设计不是为了解决多线程之间的数据共享问题，而是为了实现了线程间的数据隔离。ThreadLocal 很残暴的在每个线程内部自己维护一个变量，你别的线程的数据我不要，我只管我自己的数据。这样的结果是降低了线程的同步的复杂度，但是内存使用也就上去了。是一种“以控件换空间”的方式。而已 “synchronized” 为代表的一系列线程同步方式，则是“以时间换空间”的方式。那就来看看ThreadLocal要怎么使用吧。","text":"ThreadLocal的设计不是为了解决多线程之间的数据共享问题，而是为了实现了线程间的数据隔离。ThreadLocal 很残暴的在每个线程内部自己维护一个变量，你别的线程的数据我不要，我只管我自己的数据。这样的结果是降低了线程的同步的复杂度，但是内存使用也就上去了。是一种“以控件换空间”的方式。而已 “synchronized” 为代表的一系列线程同步方式，则是“以时间换空间”的方式。那就来看看ThreadLocal要怎么使用吧。 一、ThreadLocal 的简单使用1. 首先创建一个简单的Student类吧1234567891011public static class Student &#123; private int age = 0; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 2. 再来一个 ThreadLocalDemo123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ThreadLocalDemo implements Runnable &#123; //创建线程局部变量studentLocal用来保存Student对象 private final static ThreadLocal studentLocal = new ThreadLocal(); //对比实现，直接保存到对象里 public Student stu = new Student(); public void run() &#123; accessStudent(); &#125; public void accessStudent() &#123; //获取当前线程的名字 String currentThreadName = Thread.currentThread().getName(); System.out.println(currentThreadName + \" is running!\"); //产生一个随机数并打印 Random random = new Random(); int age = random.nextInt(100); System.out.println(\"thread \" + currentThreadName + \" set age to:\" + age); //获取一个Student对象，并将随机数年龄插入到对象属性中 Student student = getStudent();//getThreadLocalStudent student.setAge(age); System.out.println(\"thread \" + currentThreadName + \" first read age is:\" + student.getAge()); System.out.println(\"thread \" + currentThreadName + \" second read age is:\" + student.getAge()); &#125; protected Student getThreadLocalStudent() &#123; //获取本地线程变量并强制转换为Student类型 Student student = (Student) studentLocal.get(); //线程首次执行此方法的时候，studentLocal.get()肯定为null if (student == null) &#123; //创建一个Student对象，并保存到本地线程变量studentLocal中 student = new Student(); studentLocal.set(student); &#125; return student; &#125; protected Student getStudent() &#123; return stu; &#125; protected synchronized Student getStudentSynchronized() &#123; return stu; &#125;&#125; 3. 来测试一下吧同时运行两个 ThreadLocalDemo 线程。 1234567public static void main(String[] agrs) &#123; ThreadLocalDemo td = new ThreadLocalDemo(); Thread t1 = new Thread(td, \"a\"); Thread t2 = new Thread(td, \"b\"); t1.start(); t2.start();&#125; （1）首先试一下直接存在 Student 对象里，直接调用 getStudent 方法 12345678b is running!a is running!thread b set age to:64thread a set age to:63thread b first read age is:64thread a first read age is:63thread a second read age is:63thread b second read age is:63 可以看到直接使用 stu 变量的话，线程 b 第二次读取的时候其实是读取到了线程 a 设置之后的值。 （2）再看看放在 ThreadLocal 里面，换成调用 getThreadLocalStudent 方法 12345678a is running!b is running!thread a set age to:13thread b set age to:90thread b first read age is:90thread a first read age is:13thread b second read age is:90thread a second read age is:13 a，b 两个线程两次都只是各自读取自己的局部变量。 课外思考，顺便来实现一下使用 synchronized 实现线程 ab 数据共享 12345public void run() &#123; synchronized(stu) &#123; accessStudent(); &#125;&#125; 只要修改一下 run 方法里面，就可以了。这样打印出来的是： 12345678a is running!thread a set age to:35thread a first read age is:35thread a second read age is:35b is running!thread b set age to:94thread b first read age is:94thread b second read age is:94 此处我测试了一下 synchronized(stu) 只能加在 accessStudent 方法外部，在 accessStudent 方法里面加同步是不生效的。 二、ThreadLocal 的实现原理上面看了 ThreadLocal 如何使用，下面干脆一起来看看它内部是如何实现的吧。 1. ThreadLocal 的 set 方法12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 首先可以看到这里有个 ThreadLocalMap 类，它是 ThreadLocal 的一个内部类， ThreadLocalMap一听这名字，就感觉是用来保存 ThreadLocal 的一个东西，它的内部呢又有一个 Entry 类，这是一个(key,value)形式的弱引用，为什么要把key作为弱引用呢？是为了让 ThreadLocalMap 尽可能的小，在 key 不被引用的时候就回收： 1234567static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 再回到上面的 set 方法，首先是通过 getMap(t) 方法拿到当前线程的 ThreadLocalMap 对象，Thread 类里面就有一个名为 threadLocals 的 ThreadLocalMap 对象。 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; （1）如果为空，则去创建: 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 把新的 ThreadLocalMap 对象赋值给线程t的 threadLocals 对象。 看看 ThreadLocalMap 的构造函数： 1234567ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; 这里的 table 就是一个 Entry 数组 。按照上面的 Entry(ThreadLocal&lt;?&gt; k, Object v) 构造函数，初始化 ThreadLocalMap 对象的时候就会把 ThreadLocal 对象作为key，把value放到一个 Entry 对象中，并且保存到 table 数组中。 （2）如果这个对象不为空，则直接调用 ThreadLocalMap 的 set方法 ： 123456789101112131415161718192021222324private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 遍历 table 数组，如果当前的 ThreadLocal 对象和其中已经保存的某个 Entry 的 key 相等，则把这个 Entry 的value设置为传进来的值。如果发现key为空（是的，会出现k是null的情况），所以会接着在replaceStaleEntry重新循环寻找相同的key，找到之后再赋值。所以说我们通过 ThreadLocal 传进来的值，其实都保存在了 ThreadLocalMap 的 Entry对象里了。 2. ThreadLocal 的 get 方法12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 就是在Entry中通过当前 ThreadLocal 对象索引到它对应的值。 getMap 方法上面已经看过了。看看 ThreadLocalMap 的 getEntry 方法： 12345678private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125; 很简单，还是遍历 table 数组。 THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[{"name":"MultiThread","slug":"MultiThread","permalink":"http://ai.wisim.me/tags/MultiThread/"}]},{"title":"Java多线程-static synchronized 和 synchronized 修饰的方法的区别","slug":"2016-10-22-JavaStaticSynchronized","date":"2016-10-21T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/10/22/2016-10-22-JavaStaticSynchronized/","link":"","permalink":"http://ai.wisim.me/2016/10/22/2016-10-22-JavaStaticSynchronized/","excerpt":"一晃眼居然两个多月没写博客了，那这两个月究竟忙什么了呢。仔细想想好像也没干啥。大概是忙着灌药了吧。唉，以后还是多写点博客吧，不然感觉虚度光阴了。🙏","text":"一晃眼居然两个多月没写博客了，那这两个月究竟忙什么了呢。仔细想想好像也没干啥。大概是忙着灌药了吧。唉，以后还是多写点博客吧，不然感觉虚度光阴了。🙏 我们都知道 staitc 修饰的方法是静态方法，是属于类的，可以通过类名直接调用。那么题中所述的区别就显而易见了：static synchronized 关键字修饰的方法是为类加锁，只要是这个类的对象，调用到这个方法都要加锁。而 synchronized 修饰的方法则是对象级别的，只有同一个对象在多个线程访问这个方法才会加锁。下面通过一个简单的例子来说明一下两种修饰的方法在多线程中会对别的方法产生什么影响。 1.来吧，首先是一个用来测试 synchronized 方法的类 SynchronizedRun ：它有两个方法：方法a和方法b。并且在它的 run 方法中会随机调用a和b中的一个方法。 1234567891011121314151617181920212223242526272829303132public static class SynchronizedRun implements Runnable &#123; public void run () &#123; int ran = new Random().nextInt(2); if(ran == 0) &#123; a(); &#125; if(ran == 1) &#123; b(); &#125; &#125; public synchronized void a() &#123; System.out.println(\"A\"); try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; &#125; &#125; public synchronized void b()&#123; System.out.println(\"B\"); try &#123; Thread.sleep(2000); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 2.再来一个，测试 static synchronized 方法的类 StaticSynchronizedRun它有两个方法：c 和 d。并且在它的run方法中会随机调用c 和 d中的一个方法。 12345678910111213141516171819202122232425262728293031public static class StaticSynchronizedRun implements Runnable &#123; public void run () &#123; int ran = new Random().nextInt(2); if(ran == 0) &#123; c(); &#125; if(ran == 1) &#123; d(); &#125; &#125; public static synchronized void c()&#123; System.out.println(\"C\"); try &#123; Thread.sleep(2000); &#125; catch (Exception e) &#123; &#125; &#125; public static synchronized void d() &#123; System.out.println(\"D\"); try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 3.来写一段测试代码吧123456789101112131415161718192021222324252627282930public class StaticSynchronized &#123; public static void main(String[] args) &#123; System.out.println(\"*********** 一个对象的 synchronized 方法 ***********\"); SynchronizedRun synchronizedRun = new SynchronizedRun(); for (int i = 0 ; i &lt; 4 ; i++) &#123; new Thread(synchronizedRun).start(); &#125; /* System.out.println(\"*********** 多个对象的 synchronized 方法 ***********\"); for (int i = 0 ; i &lt; 4 ; i++) &#123; new Thread(new SynchronizedRun()).start(); &#125; System.out.println(\"*********** 一个对象的 static synchronized 方法 ***********\"); StaticSynchronizedRun staticSynchronizedRun = new StaticSynchronizedRun(); for (int i = 0 ; i &lt; 4 ; i++) &#123; new Thread(staticSynchronizedRun).start(); &#125; System.out.println(\"*********** 多个对象的 static synchronized 方法***********\"); for (int i = 0 ; i &lt; 4 ; i++) &#123; new Thread(new StaticSynchronizedRun()).start(); &#125; */ &#125;&#125; 测试1: 一个对象在不同线程调用它的两个 synchronized 方法。 可以看到这里a和b两个方法显然是加锁了的。因为 synchronized 修饰的方法是对象级的，这里只有一个对象，访问ab方法时肯定需要等待了。 测试2: 不同的对象在多个线程中调用他们的 synchronized 方法。 2这里和上面1的现象对比一下，很明显，几个方法是同时执行的。因为是多个对象各自执行他们的 synchronized 方法。并不需要加锁等待。 测试3: 一个对象在不同线程中调用它的两个 static synchronized 方法。 3这里的现象和测试一中几乎是一样的。 测试4: 不同对象在多个线程中调用他们的 static synchronized 方法。 而4这里的现象和3中也是一样的。这就证明了文章开头所说的static synchronized 方法是类级别的，不管你有多少对象，到我这就要加锁等待。 THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[{"name":"MultiThread","slug":"MultiThread","permalink":"http://ai.wisim.me/tags/MultiThread/"}]},{"title":"Android Hook getDeviceId方法篡改设备id","slug":"2016-08-30-AndroidHookDeviceId","date":"2016-08-29T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/30/2016-08-30-AndroidHookDeviceId/","link":"","permalink":"http://ai.wisim.me/2016/08/30/2016-08-30-AndroidHookDeviceId/","excerpt":"学习一下如何使用动态代理来Hook Android中Java层的方法，这里拿TelephoneManager的getDeviceId方法来做练手，先来看看如何使用TelephoneManager获取deviceId: 12TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);tm.getDeviceId()","text":"学习一下如何使用动态代理来Hook Android中Java层的方法，这里拿TelephoneManager的getDeviceId方法来做练手，先来看看如何使用TelephoneManager获取deviceId: 12TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);tm.getDeviceId() 一、首先来看看 TelephoneManager.getDeviceId()方法的实现：123456789public String getDeviceId() &#123; try &#123; return getSubscriberInfo().getDeviceId(); &#125; catch (RemoteException ex) &#123; return null; &#125; catch (NullPointerException ex) &#123; return null; &#125;&#125; 那么这个getSubscriberInfo()方法里面又是什么呢： 123private IPhoneSubInfo getSubscriberInfo() &#123; return IPhoneSubInfo.Stub.asInterface(ServiceManager.getService(\"iphonesubinfo\"));&#125; IPhoneSubInfo是一个AIDL接口，它定义的方法其中一个就是getDeviceId，而 PhoneSubInfo 则 继承了IPhoneSubInfo.Stub 并实现了getDeviceId接口。那就顺便看看PhoneSubInfo类吧， 12345@Overridepublic String getDeviceId() &#123; mContext.enforceCallingOrSelfPermission(READ_PHONE_STATE, \"Requires READ_PHONE_STATE\"); return mPhone.getDeviceId();&#125; 可以看到这里又返回了PhoneSubInfo的成员变量mPhone.getDeviceId()。其实这里如果要使用反射把自己构造的Phone对象替换掉mPhone成员变量还是比较麻烦的，CDMAPhone和GSMPhone都是实现了Phone接口的类，而他们的构造函数还要引入其他的类，这样就为hook增加了难度。所以我们暂且没有必要看PhoneSubInfo类了。 二、我们可以向前看，来分析一下getSubscriberInfo方法。1.首先是通过ServiceManager.getService(&quot;iphonesubinfo&quot;)得到一个BinderProxy对象。 看看ServiceManager的getService方法，是如何获取”iphonesubinfo”系统服务的，注意这里也是获取系统服务的通用方法： 12345678910111213public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in getService\", e); &#125; return null;&#125; 在ServiceManager中，所有的系统服务对象都存放在 sCache 这个Map对象里。每次获取服务都是先从sCachae中去获取。 2.再来看看IPhoneSubInfo.Stub这个类是个啥东西 IPhoneSubInfo本身是个AIDL接口，这样系统编译时会自动为它生成一个IPhoneSubInfo.java文件，这个IPhoneSubInfo类实现了android.os.IInterface接口，并且它自己本身也是一个Interface。在IPhoneSubInfo.java里面定义了一个Stub内部类，Stub类继承自android.os.Binder，并且实现了IPhoneSubInfo接口。 在使用系统服务的时候，如果客户端和服务端在同一个进程，调用方法时不会进行跨进程的transact 操作，直接调用接口方法实现。而当两者位于不同进程的时候，方法调用会走transact过程，这个逻辑又是由Stub的内部类Proxy来实现的。 Proxy这个类同样也实现了也实现了IPhoneSubInfo接口，而Proxy对象则是运行在客户端中的。 3.接着再把Binder对象传入IPhoneSubInfo.Stub.asInterface方法 客户端最终就通过asInterface得到一个IPhoneSubInfo 的代理对象IPhoneSubInfo$Stub$Proxy。以后就可以通过这个代理对象在客户端来执行远程方法了。 12345678910public static com.android.internal.telephony.IPhoneSubInfo asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); // Hook点 if (((iin != null) &amp;&amp; (iin instanceof com.android.internal.telephony.IPhoneSubInfo))) &#123; return ((com.android.internal.telephony.IPhoneSubInfo) iin); &#125; return new com.android.internal.telephony.IPhoneSubInfo.Stub.Proxy(obj);&#125; 三、开始实现Hook由上面可以知道，所有的系统服务对象都存在sCache中，因此我们可以将我们自己构造PhoneSubInfo代理服务对象再放到sCache中，这样ServiceManager每次调用getService(“iphonesubinfo”)时获取到的都是我们放进去的PhoneSubInfo对象。 1.由于asInterface中要传入一个IBinder对象，先要拿到一个原始的IBinder对象 直接根据ServiceManager.getService(“iphonesubinfo”)来通过反射得到原始的IBinder对象。 1234final String TELEPHONE_SERVICE = \"iphonesubinfo\";Class sm = Class.forName(\"android.os.ServiceManager\");Method getServiceMethod = sm.getDeclaredMethod(\"getService\", String.class);IBinder binder = (IBinder) getServiceMethod.invoke(null, TELEPHONE_SERVICE); 注意此时由于是在客户端，所以得到的IBinder对象是一个代理对象BinderProxy。 2.再根据上面拿到的BinderProxy对象手动实现一个代理对象 1IBinder hookedBinder = (IBinder) Proxy.newProxyInstance(sm.getClassLoader(), new Class&lt;?&gt;[]&#123;IBinder.class&#125;, new TelephoneProxyHookDiHandler(binder)); 来看看TelephoneProxyHookDiHandler类： 123456789101112131415161718192021public class TelephoneProxyHookDiHandler implements InvocationHandler &#123; IBinder base; Class&lt;?&gt; stubClass; Class&lt;?&gt; iinterface; public TelephoneProxyHookDiHandler(IBinder base) &#123; this.base = base; try &#123; this.iinterface = Class.forName(\"com.android.internal.telephony.IPhoneSubInfo\"); this.stubClass = Class.forName(\"com.android.internal.telephony.IPhoneSubInfo$Stub\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (\"queryLocalInterface\".equals(method.getName())) &#123; return Proxy.newProxyInstance(proxy.getClass().getClassLoader(),new Class[]&#123;this.iinterface&#125;,new TelephoneHookDiHandler(base, stub)); &#125; return method.invoke(base, args); &#125;&#125; 首先在构造函数中实例化一个IPhoneSubInfo对象和一个IPhoneSubInfo$Stub对象,然后在invoke方法中，让queryLocalInterface方法每次都返回我们将要构造的Proxy对象， 这里我们看到Proxy.newProxyInstance方法的第二个参数传递进去的是一个IPhoneSubInfo对象，表明我们获取的代理对象同意可以执行IPhoneSubInfo里面定义的所有方法。 3.看看TelephoneHookDiHandler类 在构造函数中将上面得到的IBinder代理对象BinderProxy以及Stub对象IPhoneSubInfo$Stub传入TelephoneHookDiHandler类。通过反射调用IPhoneSubInfo$Stub.asInterface得到一个IPhoneSubInfo$Stub$Proxy代理对象，然后在invoke方法中对getDeviceId做处理。 123456789101112131415161718public class TelephoneHookDiHandler implements InvocationHandler &#123; Object base; public TelephoneHookDiHandler(IBinder base, Class&lt;?&gt; stubClass) &#123; try &#123; Method asInterfaceMethod = stubClass.getDeclaredMethod(\"asInterface\", IBinder.class); this.base = asInterfaceMethod.invoke(null, base); &#125; catch (Exception e) &#123; throw new RuntimeException(\"hooked failed!\"); &#125; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (\"getDeviceId\".equals(method.getName())) &#123; return \"1234567890\"; &#125; return method.invoke(base, args); &#125;&#125; 4.处理完上面的事情我们就可以把第二步得到的hookedBinder对象放入sCache中了： 1234Field field = sm.getDeclaredField(&quot;sCache&quot;);field.setAccessible(true);Map&lt;String, IBinder&gt; map = (Map&lt;String, IBinder&gt;) field.get(null);map.put(TELEPHONE_SERVICE, hookedBinder); 大功告成，以后在程序里调用TelephoneManager.getDeviceId()得到的都是”1234567890” THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Java并发-读写锁ReadWriteLock","slug":"2016-08-24-JavaReadWriteLock","date":"2016-08-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/24/2016-08-24-JavaReadWriteLock/","link":"","permalink":"http://ai.wisim.me/2016/08/24/2016-08-24-JavaReadWriteLock/","excerpt":"读写锁是为了帮助解决多线程中读操作和写操作分离而设计的。想象一下，如果在系统中，读操作远远大于写操作，而每一次写操作进行时，别的写操作也要等待，这样对系统的性能会有很大的影响。ReadWriteLock是JDK5开始提供的读写分离锁。","text":"读写锁是为了帮助解决多线程中读操作和写操作分离而设计的。想象一下，如果在系统中，读操作远远大于写操作，而每一次写操作进行时，别的写操作也要等待，这样对系统的性能会有很大的影响。ReadWriteLock是JDK5开始提供的读写分离锁。 读写锁允许多个线程同时读，是的读线程可以真正的并行。但是考虑到数据的完整性，读操作和写操作是一定要互斥的。看一下读写锁的访问约束情况： Read Write Read UnBlock Block Write Block Block 来看一下具体的使用例子 1. 获取读写锁通过ReentrantReadWriteLock这个类的readLock()方法和writeLock()方法分别拿到读锁和写锁 1234private static Lock lock = new ReentrantLock(); //普通的可重入锁private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();//读写分离锁private static Lock readLock = readWriteLock.readLock();private static Lock writeLock = readWriteLock.writeLock(); 2. 为读操作和写操作加锁123456789101112131415161718192021public Object handleRead(Lock lock) throws InterruptedException &#123; try &#123; lock.lock(); Thread.sleep(1000); System.out.println(\"ReadThread : \"+Thread.currentThread().getId() + \" | value = \"+value); return value; &#125; finally &#123; lock.unlock(); &#125;&#125;public void handleWrite(Lock lock,int value) throws InterruptedException &#123; try &#123; lock.lock(); Thread.sleep(1000); System.out.println(\"WriteThread : \"+Thread.currentThread().getId() + \" | value = \"+value); this.value = value; &#125; finally &#123; lock.unlock(); &#125;&#125; 3. 测试代码123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; final ReadWriteLockTest test = new ReadWriteLockTest(); Runnable readRunnable = new Runnable()&#123; public void run() &#123; try&#123; test.handleRead(readLock); //对比使用一般的锁 //test.handleRead(lock); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;; Runnable writeRunnable = new Runnable()&#123; public void run() &#123; try&#123; test.handleWrite(writeLock,new Random().nextInt()); //对比使用一般的锁 //test.handleWrite(lock,new Random().nextInt()); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;; new Thread(writeRunnable).start(); for(int i = 0 ; i &lt; 10 ; i++) &#123; new Thread(readRunnable).start(); &#125; new Thread(writeRunnable).start();&#125; 运行代码之后发现使用读写锁的时候，会有多个读操作并发执行，然后等待一秒执行写操作。而使用普通的可重入锁，则不管读操作还是写操作，都要等待一秒才能继续执行。 THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[{"name":"MultiThread","slug":"MultiThread","permalink":"http://ai.wisim.me/tags/MultiThread/"},{"name":"Lock","slug":"Lock","permalink":"http://ai.wisim.me/tags/Lock/"}]},{"title":"Java并发-CyclicBarrier","slug":"2016-08-24-JavaCyclicBarrier","date":"2016-08-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/24/2016-08-24-JavaCyclicBarrier/","link":"","permalink":"http://ai.wisim.me/2016/08/24/2016-08-24-JavaCyclicBarrier/","excerpt":"CyclicBarrier是一种多线程并发控制实用工具。可以实现线程间的计数等待。CyclicBarrier翻译过来就是循环栅栏，可以用来阻止线程继续执行，要求线程在栅栏处等待。","text":"CyclicBarrier是一种多线程并发控制实用工具。可以实现线程间的计数等待。CyclicBarrier翻译过来就是循环栅栏，可以用来阻止线程继续执行，要求线程在栅栏处等待。 比如我们这里实现一个场景，有十个士兵要先集合再去执行任务。首先是士兵报道，所有人到齐之后才能去执行任务，然后每个人完成任务也要报告，所有人完成任务之后才能表示这个任务结束。 1.看看如何创建一个CyclicBarrier123456789101112131415161718192021222324import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; final int COUNT = 10; Thread[] soliders = new Thread[COUNT]; boolean flag = false; CyclicBarrier cb = new CyclicBarrier(COUNT,new BarrierWork(flag,COUNT)); System.out.println(\"start\"); ExecutorService exec = Executors.newFixedThreadPool(COUNT); for(int i = 0 ; i &lt; COUNT ; i++) &#123; try &#123; Thread.sleep(300); &#125; catch (Exception e) &#123; &#125; System.out.println(i + \" : hasArrive\"); exec.submit(new Solider(cb,i)); &#125; exec.shutdown(); &#125;&#125; 这里定义COUNT为10，实例化CyclicBarrier的时候传入COUNT作为参数，还有对应的任务线程BarrierWork，BarrierWork就是在设置了栅栏之后，每次执行工作完线程到达了栅栏之后所要执行的操作。 然后通过线程池启动十个士兵工作线程，我们这里用Thread.sleep(300);来模拟每个士兵到达的时间不同，每个士兵到达都会执行 System.out.println(i + &quot; : hasArrive&quot;);。 2.再看看BarrierWork这个Runnable1234567891011121314151617181920public static class BarrierWork implements Runnable &#123; //总数 public int count; //报道和任务flag public boolean workFlag; public BarrierWork(boolean workFlag,int count) &#123; this.count = count; this.workFlag = workFlag; &#125; public void run() &#123; if (workFlag) &#123; System.out.println(count + \" : allFinishWork\"); &#125; else &#123; System.out.println(count + \" : allArrive\"); workFlag = true; &#125; &#125;&#125; 当workFlag为false时表示士兵刚来报道，还没执行任务。由于CyclicBarrier已经设置了计数器为10，每个士兵报道的时候，CyclicBarrier内部都会更新计数器，直到10个士兵全都报道完毕的时候都会执行System.out.println(count + &quot; : allArrive&quot;);， 然后把workFlag更新为true，表示报道之后就要等待完成工作了。等待10个士兵完成任务的原理也和报道是一样的。 3.还有Solider这个Runnable12345678910111213141516171819202122232425262728public static class Solider implements Runnable &#123; public int name; public CyclicBarrier cb; public Solider(CyclicBarrier cb,int name) &#123; this.name = name; this.cb = cb; &#125; public void run() &#123; try &#123; cb.await(); doWork(); cb.await(); &#125; catch(Exception e) &#123; &#125; &#125; public void doWork() &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; &#125; System.out.println(name + \" : hasFinish\"); &#125;&#125; 看看run方法里面， CyclicBarrier 的await()方法就是用来设置计数的，第一次执行cb.await()是设置栅栏，让士兵报道之后等待，直到CyclicBarrier的计数器达到10，再去执行BarrierWork，此时BarrierWork里面肯定是打印allArrive的，然后士兵们再执行doWork()。第二次执行cb.await()是设置栅栏，让每个士兵完成任务后等待，直到计数器达到10，再去执行BarrierWork，此时就变成打印allFinished了。 看看最终的运行结果： 123456789101112131415161718192021222324λ javac CyclicBarrierTeststart0 : hasArrive1 : hasArrive2 : hasArrive3 : hasArrive4 : hasArrive5 : hasArrive6 : hasArrive7 : hasArrive8 : hasArrive9 : hasArrive10 : allArrive1 : hasFinish9 : hasFinish5 : hasFinish7 : hasFinish8 : hasFinish3 : hasFinish4 : hasFinish6 : hasFinish0 : hasFinish2 : hasFinish10 : allFinishWork THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[{"name":"MultiThread","slug":"MultiThread","permalink":"http://ai.wisim.me/tags/MultiThread/"}]},{"title":"LeetCode:70. Climbing Stairs","slug":"2016-08-21-LeetCodeClimbingStairs","date":"2016-08-20T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/21/2016-08-21-LeetCodeClimbingStairs/","link":"","permalink":"http://ai.wisim.me/2016/08/21/2016-08-21-LeetCodeClimbingStairs/","excerpt":"LeetCode:70. Climbing Stairs12You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?","text":"LeetCode:70. Climbing Stairs12You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 题目的意思就是让你爬n阶提子，但是每次只能爬一个阶梯或者两个阶梯。让你求出所有的可能性。 想想看，由于只能爬1或者2，所以我们爬一个阶梯只有一种可能性，但是爬两个阶梯就有两种可能，也就是两个1或者一个2。 这样举个例子，思考一下，因为只能爬1或者2个阶梯，所以爬到4只有两个可能，就是从3爬一步爬到4或者从2爬两步爬到4。因此爬到4的可能性也就确定了，也就是从0爬到3的可能性以及从0爬到2的可能性之和。再往前看，爬到3有几种可能：从1爬两步爬到3，以及从2爬一步爬到3。爬到2的可能性：从1爬一步到2或者从0爬两步到2。这样就可以算到从0爬到4的可能性了。来看一下Java代码实现 ： 123456789101112131415161718192021222324252627public class Solution &#123; public int climbStairs(int n) &#123; //将1，2两种步伐抽象成一个数组，这样下面的代码对其他的步伐也适用 int[] arr = new int[]&#123;1,2&#125;; //每个阶梯的可能的情况都放在res数组对应的位置 int[] res = new int[n+1]; if(n &lt; arr[0]) &#123; return 0; &#125; for(int i = 1 ; i &lt; n+1 ; i++) &#123; //循环每种步伐 for(int j = 0 ; j &lt; arr.length;j++) &#123; if(i == arr[j]) &#123; //如果等于步伐中的某一步，则该位置的结果增加自身这一种可能性 res[i]+=1; &#125; else if(i &gt; arr[j])&#123; //如果大于步伐，则减去该步伐所得位置的可能性要加在当前位置的可能性里面。 res[i]+=res[i-arr[j]]; &#125; else &#123; break; &#125; &#125; //System.out.println(i+ \" : \" +res[i]); &#125; return res[n]; &#125;&#125; THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://ai.wisim.me/tags/Leetcode/"}]},{"title":"LeetCode:377. Combination Sum IV","slug":"2016-08-20-LeetCodeCombinationSumIV","date":"2016-08-19T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/20/2016-08-20-LeetCodeCombinationSumIV/","link":"","permalink":"http://ai.wisim.me/2016/08/20/2016-08-20-LeetCodeCombinationSumIV/","excerpt":"LeetCode:377. Combination Sum IV12345678910111213141516171819Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.Example:nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7.","text":"LeetCode:377. Combination Sum IV12345678910111213141516171819Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.Example:nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. 题目的意思就是给你一个正整数数组，里面的元素不重复（未排序）。再给你一个目标数值，要你用数组里面的数组合起来的和是目标数值，求出有多少种可能。 这道题目有点像那个爬梯子的题目。同时也可以看看这篇文章ClimbingStairs。 两道题目有异曲同工之妙，我们来思考一下这道题目。如果我要求和为4的所有可能性，首先要求(4-1),(4-2),(4-3)的可能性，它们的和就是4的可能性。来看一下Java代码实现： 123456789101112131415161718public class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; Arrays.sort(nums); int[] res = new int[target+1]; for (int i = 1 ; i &lt; target+1;i++) &#123; for(int num : nums) &#123; if(i == num) &#123; res[i]+=1; &#125; else if(i &gt; num) &#123; res[i]+= res[i-num]; &#125; else &#123; break; &#125; &#125; &#125; return res[target]; &#125;&#125; THE END","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://ai.wisim.me/tags/Leetcode/"}]},{"title":"LeetCode:385. Mini Parser","slug":"2016-08-18-LeetCodeMinParser","date":"2016-08-17T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/18/2016-08-18-LeetCodeMinParser/","link":"","permalink":"http://ai.wisim.me/2016/08/18/2016-08-18-LeetCodeMinParser/","excerpt":"LeetCode:385. Mini Parser123456789Given a nested list of integers represented as a string, implement a parser to deserialize it.Each element is either an integer, or a list -- whose elements may also be integers or other lists.Note: You may assume that the string is well-formed:String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,, ].","text":"LeetCode:385. Mini Parser123456789Given a nested list of integers represented as a string, implement a parser to deserialize it.Each element is either an integer, or a list -- whose elements may also be integers or other lists.Note: You may assume that the string is well-formed:String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,, ]. 题目的意思就是给你一个由好多int值嵌套在一起的字符串。让你写一个解析器，把里面的元素解析出来。每个元素呢，要么是一个int值，要么是一个列表，而这个列表的元素又可以是int或者其他列表，如此嵌套而成。几个注意点：给定的字符创不为空且不含空格，只包含0-9以及[]还有,和-。 讲讲思路先 遇到’[‘字符肯定是要产生一个新的 NestedInteger 对象的。 遇到’]’字符则表明上一个元素可以结束了，此时要处理这里面的整型字符串，将其解析成int值再传给当前的NestedInteger对象。并且呢，由于当前元素已经结束解析，还需要将它传给它的父NestedInteger。 遇到’,’字符要分情况了，如果它的前一个字符是’]’则表明在步骤2种已经做了处理了，否则的话说明之前的整型字符串还没有解析。 如果遇到了0到9还有－，则暂时不作处理，将其拼接到一个StringBuilder里面。 看看Java代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public NestedInteger deserialize(String s) &#123; if (s.isEmpty()) return null; if (s.charAt(0) != '[') // ERROR: special case return new NestedInteger(Integer.valueOf(s)); //stack 用于保存上一个 NI 对象 Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;(); //curNi用于保存当前 NI 对象 NestedInteger curNi = null; StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; s.length() ; i++ ) &#123; char c = s.charAt(i); if(c == '[') &#123; //如果当前 curNi 不为空，则 curNi 临时push进 stack if(curNi != null) &#123; stack.push(curNi); &#125; //并且遇到'['之后要实例化新的 curNi curNi = new NestedInteger(); &#125; else if (c == ']') &#123; //遇到']'之后，就要把之前的字符串解析成int了 if(sb.length() &gt;0) &#123; curNi.add(new NestedInteger(Integer.parseInt(sb.toString()))); sb.setLength(0); &#125; //如果 stack 不为空则把 curNi 添加到 stack的顶层NI 中。 if(!stack.empty()) &#123; NestedInteger popNi = stack.pop(); popNi.add(curNi); curNi = popNi; &#125; &#125; else if (c == ',')&#123; //如果前一个元素是]，则已经处理；如果不是，则要把前面的元素解析成int if(s.charAt(i-1) != ']') &#123; curNi.add(new NestedInteger(Integer.parseInt(sb.toString()))); sb.setLength(0); &#125; &#125; else &#123; sb.append(c); &#125; &#125; return curNi; &#125;&#125; 我们这里再来拿一个字符串来讨论看看，对于字符串”[-1,[123],[[3]]]” 首先遇到’[‘产生一个NestedInteger，对应着最外层的NestedInteger， 记作NI1，并赋值给curNi(NI1)； 接着向后遍历，直到遇到了第一个’,’，此时要为前面的整型值’-1’实例化一个NestedInteger对象，并插入到最外层的curNi(NI1)； 继续向后遍历，遇到第二个’[‘，先将curNi(NI1)压入stack中，再实例化一个新的NestedInteger对象，记作NI2，且令赋值给curNi(NI2)； 向后遍历，遇到第二个’[‘所对应的’]’，为前面的整型值’123’实例化一个NestedInteger对象，add进curNI(NI2)中。再弹出stack中的NI1对象，将curNI(NI2)add到NI中，再令curNi ＝ NI1，注意此时stack中已空； 继续，遇到第二个’,’但是发现它的前一个字符是’]’，不作处理； 继续遍历，遇到第三个’[‘，先将curNI(NI1)压入stack中。再实例化一个新的NestedInteger对象，记作NI3，令curNI = NI3； 继续遍历，遇到第四个’[‘，先将curNI(NI3)压入stack中。再实例化一个新的NestedInteger对象，记作NI4，令curNI = NI4； 继续遍历，遇到第四个’[‘所对应的’]’，为’3’实例化一个NestedInteger对象，插入到curNI(NI4)中。从stack中弹出NI3，将curNI(NI4)插入到NI3中，且令curNI = NI3； 继续遍历，遇到第三个’[‘所对应的’]’，前面没有未处理的整型字符串。此时stack里面还有一个NI1，弹出NI1，将curNI(NI3)add给NI1，且令curNI = NI1； 到了最后一个’]’，也对应了第一个’]’，此时stack为空，且没有未处理的字符串了。此时，curNI就对应了最外层的那个NestedInteger，是不是很神奇。结束。 THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://ai.wisim.me/tags/Leetcode/"}]},{"title":"ReactNative从网络获取数据并显示","slug":"2016-08-14-ReactNativeFetchData","date":"2016-08-13T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/14/2016-08-14-ReactNativeFetchData/","link":"","permalink":"http://ai.wisim.me/2016/08/14/2016-08-14-ReactNativeFetchData/","excerpt":"这里我们来实现一个极其简单的天气预报的小例子。获取网络接口天气预报的json数据，再显示在Text上。同时有个输入框，可以输入城市信息，再按确认，则会更新数据。同时还可以以列表形式展示未来几天的天气预报。","text":"这里我们来实现一个极其简单的天气预报的小例子。获取网络接口天气预报的json数据，再显示在Text上。同时有个输入框，可以输入城市信息，再按确认，则会更新数据。同时还可以以列表形式展示未来几天的天气预报。 一、首先是单个元素，来布个局吧这里我们用到了聚合API的天气预报接口 ：http://v.juhe.cn/weather/index?format=2&amp;cityname=%E4%B8%8A%E6%B5%B7&amp;key=71efbb690b9bc9a389ad90502306c8cd 12345678910111213141516171819202122232425class FetchData extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;weather: &apos;天气&apos;&#125;; &#125; componentDidMount() &#123; this.fetchWeatherData(&quot;上海&quot;); &#125; render() &#123; return( &lt;View style=&#123;styles.containerStyle&#125;&gt; &lt;TextInput style=&#123;styles.textInputStyle&#125; onChangeText=&#123;(text) =&gt; this.handleTextChange(text)&#125; &gt; &lt;/TextInput&gt; &lt;TouchableHighlight style=&#123;styles.confirmStyle&#125; onPress=&#123;() =&gt; this.fetchWeatherData(this.state.address)&#125; &gt; &lt;Text &gt;确认&lt;/Text&gt; &lt;/TouchableHighlight&gt; &lt;Text&gt;&#123;this.state.weather&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125;｝ 这里的构造函数值得注意一下。一开始我还犯二，用的是ES5的格式写的，一直报错。后来网上查了一下ES5和ES6的差别。 componentDidMount() 表示组件加载好了第一次请求数据。 （1）最上面是一个 TextInput ，用来输入地名。这里为了能够让下面的确认按钮拿到TextInput里面的内容，要为它添加一个onChangeText监听函数handleTextChange: 12345handleTextChange(addressText) &#123; this.setState(&#123; address:addressText &#125;);&#125; 这样每次TextInput的内容改变了都会更新到 address 属性中去。 （2）中间是一个确认按钮，这里要复习一下 TouchableHighlight 只能作为一个容器，里面放Text来实现按钮。TouchableHighlight的点击时间就是onPress函数了，为onPress绑定 fetchWeatherData 函数，这样每次点击确认按钮都会重新去请求天气数据： 1234567891011fetchWeatherData(address) &#123; var url = &quot;http://v.juhe.cn/weather/index?format=2&amp;cityname=&quot;+address+&quot;&amp;key=71efbb690b9bc9a389ad90502306c8cd&quot;; fetch(url) .then((response) =&gt; response.json()) .then((responseData) =&gt; &#123; this.setState(&#123; weather: !responseData.result ? &quot;&quot; : responseData.result.sk &#125;); &#125;) .done();&#125; 每次获取到json数据之后都会将sk字段更新到 weather 状态。 （3）最下面就是用来显示天气预报的 Text 了。直接显示 this.state.weather 即可。 看看效果图: 二、下面顺理成章就是加载列表数据了，也来布个局吧1234567891011121314151617181920212223242526272829303132333435class WxpListView extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; preWeather: &quot;&quot;, fecthedData: false &#125;; &#125; componentDidMount() &#123; this.fetchWeatherData(&quot;上海&quot;); &#125; renderListRow(rowData) &#123; return( &lt;Text&gt;&#123;rowData.week&#125;:&#123;rowData.weather&#125;&lt;/Text&gt; ); &#125; render() &#123; if(this.state.fecthedData) &#123; return( &lt;View style = &#123;styles.containerStyle&#125;&gt; &lt;ListView dataSource=&#123;this.state.preWeather&#125; renderRow=&#123;this.renderListRow.bind(this)&#125; &gt;ListView&lt;/ListView&gt; &lt;/View&gt; ) &#125; return(&lt;View style = &#123;styles.containerStyle&#125;&gt; &lt;Text&gt;ListView&lt;/Text&gt; &lt;/View&gt;) &#125;&#125; （1）这里的fecthedData判断语句是用来保证未加载好数据时，页面不会展示ListView，因为如果ListView的 dataSource 属性为空的话是会报render函数错误滴。同时renderRow函数是用来绑定每个Item的布局的，也就是上面的renderListRow函数。 （2）来看一下比较重要的fetchWeatherData函数里面返回Json数据的代码。 123456789101112131415fetchWeatherData(address) &#123; var url = &quot;http://v.juhe.cn/weather/index?format=2&amp;cityname=&quot;+address+&quot;&amp;key=71efbb690b9bc9a389ad90502306c8cd&quot;; fetch(url) .then((response) =&gt; response.json()) .then((responseData) =&gt; &#123; var dataSource = new ListView.DataSource( &#123;rowHasChanged: (r1, r2) =&gt; r1.date !== r2.date&#125;); this.setState(&#123; preWeather: !responseData.result ? &quot;&quot; : dataSource.cloneWithRows(responseData.result.future), fecthedData: true &#125;); console.log(responseData.result.future) &#125;) .done();&#125; 注意这里直接返回Json数据之后是要把Json转换成 ListView.DataSource 类型的对象的。否则的话ListView会报一个不能接受其他类型的数据的错误。解析完数据之后，将 fecthedData 置为true，ListView就可以展示数据了。如图： THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://ai.wisim.me/tags/ReactNative/"}]},{"title":"LeetCode:378. Kth Smallest Element in a Sorted Matrix","slug":"2016-08-13-LeetCodeKthSmallest","date":"2016-08-12T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/13/2016-08-13-LeetCodeKthSmallest/","link":"","permalink":"http://ai.wisim.me/2016/08/13/2016-08-13-LeetCodeKthSmallest/","excerpt":"LeetCode:378. Kth Smallest Element in a Sorted Matrix12345678910111213Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.Note that it is the kth smallest element in the sorted order, not the kth distinct element.Example:matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13.Note:You may assume k is always valid, 1 ≤ k ≤ n2.","text":"LeetCode:378. Kth Smallest Element in a Sorted Matrix12345678910111213Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.Note that it is the kth smallest element in the sorted order, not the kth distinct element.Example:matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13.Note:You may assume k is always valid, 1 ≤ k ≤ n2. 题目的意思呢就是给你一个n x n的矩阵，而这个矩阵的每一行以及每一列的元素大小都是递增（也可以相等）。让你找到第k小的那个元素。值得注意的是第k小的意思并不是绝对第k小。怎么讲呢，比如上面的example中的两个13，它们分别是第7小和第8小。也就是想等的元素也各自算一个k。 拿到手第一个想到的动态规划，不过后来发现题目理解错了，那就快排呗，不过这也达不到hard的level啊。构造一个搜索二叉树？嗯也是可以的，不过代价还是有点大。看了讨论之后发现居然直接可以使用 PriorityQueue 来解决。我真是越来越不懂这套路了。 优先队列PriorityQueue的本质是最小堆，每次插入和删除时都会动态更新堆中元素的位置。这就给我们提供了方便的解法了。 后来转念一想，干嘛不直接放到List里面，然后一顿排序。岂不快哉。 看一下Java代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class KthSmallest &#123; public int kthSmallest(int[][] matrix, int k) &#123; Comparator&lt;Integer&gt; comparator = new IntegerLengthComparator(); PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(10, comparator); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; queue.add(matrix[i][j]); &#125; &#125; int pos=0; while (queue.size() &gt; 0) &#123; pos++; if (pos == k) &#123; return queue.poll(); &#125; queue.poll(); &#125; return -1; &#125; public int kthSmallestList(int[][] matrix, int k) &#123; Comparator&lt;Integer&gt; comparator = new IntegerLengthComparator(); List&lt;Integer&gt; queue = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; queue.add(matrix[i][j]); &#125; &#125; Collections.sort(queue,comparator); return queue.get(k-1); &#125; public static class IntegerLengthComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer x, Integer y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0; &#125; &#125;&#125; THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://ai.wisim.me/tags/Leetcode/"}]},{"title":"LeetCode:381. Insert Delete GetRandom O(1)","slug":"2016-08-12-LeetCodeInsertDeleteGetRandom","date":"2016-08-11T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/12/2016-08-12-LeetCodeInsertDeleteGetRandom/","link":"","permalink":"http://ai.wisim.me/2016/08/12/2016-08-12-LeetCodeInsertDeleteGetRandom/","excerpt":"LeetCode:381. Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time.Note: Duplicate elements are allowed.insert(val): Inserts an item val to the collection.remove(val): Removes an item val from the collection if present.getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.","text":"LeetCode:381. Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time.Note: Duplicate elements are allowed.insert(val): Inserts an item val to the collection.remove(val): Removes an item val from the collection if present.getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains. 题目的意思是要你设计一个数据结构，使得它的插入和删除时间复杂度都是O(1)，并且能够随机返回一个元素，而返回这个元素的概率也是和这个元素的个数是线性相关的。允许插入相同的元素。 说实话一看到这个题目我是没有思路的。我想这总不至于让你设计一个和HashMap一样的数据结构吧。看了一下别人的解法，确实不至于。要说的是这个数据结构内部可以使用HashMap，而不必自己从0开始写一个。 来说一下大概的思路吧，这个数据结构暂且就叫 RandomizedCollection ，它有一个 Map","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://ai.wisim.me/tags/Leetcode/"}]},{"title":"LeetCode:384. Shuffle an Array","slug":"2016-08-12-LeetCodeShuffleArray","date":"2016-08-11T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/12/2016-08-12-LeetCodeShuffleArray/","link":"","permalink":"http://ai.wisim.me/2016/08/12/2016-08-12-LeetCodeShuffleArray/","excerpt":"LeetCode:384. Shuffle an Array Shuffle a set of numbers without duplicates.","text":"LeetCode:384. Shuffle an Array Shuffle a set of numbers without duplicates. 洗牌算法，题目的意思就是交换数组元素的位置，并且保证每种情况出现的概率是一样大。 一开始的思路呢，就是生成一个随机数(0到数组长度之间)，把这个随机数对应位置元素插入到一个等长的新数组中，如果生成的随机数已经出现过，则继续生成。直到新的数组放满。 后来呢，发现重复生成随机数会导致Time Limit Exceeded。值得再考虑考虑了。怎样才能保证生成的随机数即使重复了也有效呢。 首先在数组末尾设置一个标兵。每次生成的随机数（0到标兵位置之间）,把对应位置的元素和数组的标兵元素交换，标兵再向前移动一位。 这样就保证了即使随机数重复，对应位置的元素由于之前已经交换过，所以实际位置的元素并不会重复。而标兵位置之后的元素都是已经出现过的不会再出现了。看一下Java代码实现： 12345678910111213141516171819202122232425262728293031import java.util.Random;public class Solution &#123; private int[] mNums; public Solution(int[] nums) &#123; mNums = nums; &#125; public int[] reset() &#123; return mNums; &#125; public int[] shuffle() &#123; int len = mNums.length; int pos = len-1; int[] arr = new int[len]; for(int i = 0 ; i &lt; len;i++) &#123; arr[i] = mNums[i]; &#125; Random random = new Random(); while(pos &gt; 0) &#123; int ranNum = random.nextInt(pos+1); int temp = arr[pos]; arr[pos] = arr[ranNum]; arr[ranNum] = temp; pos--; &#125; return arr; &#125;&#125; THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://ai.wisim.me/tags/Leetcode/"}]},{"title":"LeetCode:383. Ransom Note","slug":"2016-08-11-LeetCodeRansomNote","date":"2016-08-10T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/11/2016-08-11-LeetCodeRansomNote/","link":"","permalink":"http://ai.wisim.me/2016/08/11/2016-08-11-LeetCodeRansomNote/","excerpt":"eetCode:383. Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines,write a function that will return true if the ransom note can be constructed from the magazines ;otherwise,it will return false.Each letter in the magazine string can only be used once in your ransom note.Note:You may assume that both strings contain only lowercase letters.","text":"eetCode:383. Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines,write a function that will return true if the ransom note can be constructed from the magazines ;otherwise,it will return false.Each letter in the magazine string can only be used once in your ransom note.Note:You may assume that both strings contain only lowercase letters. 题目的意思就是给你两个字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，第二个字符里的每个字符只能使用一次。（假设只包含小写字母） 那么首先想到的就是穷举法了，两层遍历即可，也就是下面的 canConstruct 方法了。 再思考一下，有个小技巧。这里只要判断两个字符串中每个字母出现的次数即可解决问题。对于某个字母来说，如果第ransom字符串中出现的次数比magazines中出现的次数要多，很显然就直接返回false了。 看一下 canConstructBetter 方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.List;import java.util.ArrayList;public class Solution &#123; public boolean canConstructBetter(String ransomNote, String magazine) &#123; if (ransomNote.equals(magazine) || \"\".equals(ransomNote)) &#123; return true; &#125; if (\"\".equals(magazine) &amp;&amp; !\"\".equals(ransomNote)) &#123; return false; &#125; int[] ransomNoteCharCount = new int[26]; int[] magazineCharCount = new int[26]; for(int i = 0 ; i &lt; ransomNote.length() ; i++) &#123; ransomNoteCharCount[ransomNote.charAt(i)-'a']++; &#125; for(int i = 0 ; i &lt; magazine.length() ; i++) &#123; magazineCharCount[magazine.charAt(i)-'a']++; &#125; for(int i = 0 ; i &lt; 26 ; i++) &#123; if(ransomNoteCharCount[i] &gt; magazineCharCount[i] ) &#123; return false; &#125; &#125; return true; &#125; public boolean canConstruct(String ransomNote, String magazine) &#123; if (ransomNote.equals(magazine)) &#123; return true; &#125; if (\"\".equals(ransomNote)) &#123; return true; &#125; List&lt;Character&gt; ransomNodeChars = new ArrayList&lt;&gt;(); List&lt;Character&gt; magazineChars = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; ransomNote.length() ; i++) &#123; ransomNodeChars.add(ransomNote.charAt(i)); &#125; this.printList(ransomNodeChars); for(int j = 0 ; j &lt; magazine.length() ; j++) &#123; magazineChars.add(magazine.charAt(j)); &#125; boolean flag = false; Character c = null; for(int m = 0 ; m &lt; ransomNote.length() ; m++) &#123; c = ransomNodeChars.get(m); flag = false; for(int n = 0 ; n &lt; magazineChars.size() ; n++) &#123; if(magazineChars.get(n) == c) &#123; flag = true; magazineChars.remove(n); break; &#125; &#125; if (flag == false) &#123; break; &#125; &#125; return flag; &#125;&#125; THE END","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://ai.wisim.me/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://ai.wisim.me/tags/String/"}]},{"title":"LeetCode:382. Linked List Random Node","slug":"2016-08-10-LeetCodeLinkedListRandomNode","date":"2016-08-09T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/10/2016-08-10-LeetCodeLinkedListRandomNode/","link":"","permalink":"http://ai.wisim.me/2016/08/10/2016-08-10-LeetCodeLinkedListRandomNode/","excerpt":"LeetCode:382. Linked List Random Node Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?","text":"LeetCode:382. Linked List Random Node Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? 题目的意思就是给你一个链表，要你从链表中取出一个值，并且保证取到每个元素的概率都是相等的。还要思考如果链表长度极其大，咋办。能不能不使用额外的空间就能达到目的。 一开始我的想法就是直接遍历一次拿到链表的长度，再生成一个随机值，拿到这个值对应位置的元素即可。但是我觉得这种解法完全达不到Medium的难度啊。看了讨论学又到一个新词：蓄水池抽样算法。 蓄水池抽样算法的结论就是：在N（N不确定）个元素中取出K个元素的概率就是 K/N。这里我们令K等于1，就可以用来解上面的这道题目了。Java代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Random;public class Solution &#123; private Random mRandom; private ListNode head; public Solution(ListNode head) &#123; this.head=head; &#125; /** *蓄水池抽样算法 */ public int getRandom() &#123; mRandom=new Random(); int pos = 1; ListNode node = head; ListNode res = head; while(node != null) &#123; //一直取最末尾的一个数 if (mRandom.nextInt(pos) == (pos-1)) &#123; res = node;//此处不可直接return。取第一个值的时候概率是百分之百，直接返回。 &#125; pos = pos+1; node = node.next; &#125; return res == null ? head.val : res.val; &#125; /** *先获取长度再取随机值的方法 */ public int getRandomXX() &#123; int randomVaule = mRandom.nextInt(this.getLength()); int pos = 0; ListNode res = head; while(res != null) &#123; if(pos == randomVaule) &#123; return res.val; &#125; res = res.next; pos++; &#125; return res.val; &#125; public int getLength() &#123; int len = 0; ListNode node = head; while(node != null) &#123; len++; node = node.next; &#125; return len; &#125;&#125; 那么为什么蓄水池抽样算法会保证每个元素被取到的概率是一样的呢？让我们一步一步来验证一下。 我们这里来考察选择最后一个元素的概率。 首先如果只有一个元素的时候，概率是1； 如果有两个元素，取到第二个元素的概率是1/2； 如果有三个元素，要保证每个元素取到的概率都是一样，有两种情况，第一种就是取第三个元素，取到的概率是1/3。但是如果不是取到第三个元素，而是取到第二个呢？那就是下面这种情况 ： 取不到第三个元素的概率 x 取到第二个元素的概率 = (2/3) x (1/2) = 1/3 可以用数学归纳法来证明一下： 假设已经读取n个数，现在保留的数是An，取到An的概率为(1/n)。 123456789101112131415对于第n+1个数An+1，以1/(n+1)的概率取An+1，否则仍然取An。依次类推，可以保证取到数据的随机性。数学归纳法证明如下： 当n=1时，显然，取A1。取A1的概率为1/1。 假设当n=Max时，取到的数据AMax。取AMax的概率为1/Max。 当n=Max+1时，以1/(Max+1)的概率取AMax+1，否则仍然取AMax。 (1)如果取AMax+1，则概率为1/(Max+1)； (2)如果不取AMax+1而仍然取AMax，则概率为(1/Max)*(Max/(Max+1))=1/(Max+1)所以，对于之后的第n+1个数An+1，以1/(n+1)的概率取An+1，否则仍然取An。依次类推，可以保证取到数据的随机性。 THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://ai.wisim.me/tags/Leetcode/"},{"name":"List","slug":"List","permalink":"http://ai.wisim.me/tags/List/"}]},{"title":"直接在终端对Java代码进行Debug","slug":"2016-08-08-JavaJDBDebug","date":"2016-08-07T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/08/08/2016-08-08-JavaJDBDebug/","link":"","permalink":"http://ai.wisim.me/2016/08/08/2016-08-08-JavaJDBDebug/","excerpt":"有时候写个小算法或者Demo时不想用IDE，直接打开Atom就可以写了。但是如果遇到bug，就只能在命令行终端调试了。下面看看如何在终端使用jdb调试Java代码。","text":"有时候写个小算法或者Demo时不想用IDE，直接打开Atom就可以写了。但是如果遇到bug，就只能在命令行终端调试了。下面看看如何在终端使用jdb调试Java代码。 1. 编译准备使用 -g 参数编译Java代码： 1javac -g Test.java 2. jdb初始化执行命令： 1jdb Test 此时会显示： Sort wxp$ jdb Test正在初始化jdb… 3. 设置断点1stop at Quick:22 表示在Quick类的22行设置一个断点。此时终端会提示： stop at Quick:22正在延迟断点Quick:22。将在加载类后设置。 接着就可以执行程序了，在终端输入： 1run 4. 单步运行通过 next 命令可以让程序执行到下一行，如果想查看变量的值可以调用 print 命令。如果要显示当前堆栈帧中的所有本地变量可以使用 locals 。 5. 跳转断点如果要查看已经设置的所有断点，可以使用 clear 命令。要跳转到下一个断点可以执行 cont 命令，如果下面没有断点了则直接执行到程序结束。此外 step 可以跳转进方法内部继续执行。 THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[]},{"title":"由主线程更新UI所想到的Window和RootViewImpl的创建过程","slug":"2016-03-18-FrameworksLaunchActivity","date":"2016-03-17T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2016/03/18/2016-03-18-FrameworksLaunchActivity/","link":"","permalink":"http://ai.wisim.me/2016/03/18/2016-03-18-FrameworksLaunchActivity/","excerpt":"之前在项目里写了一段错误的代码，是使用异步线程下载图片之后直接更新UI，导致应用崩溃。报错信息是 Only the original thread that created a view hierarchy can touch its views. ，意思就是只有主线程可以更新UI。大家肯定都遇到这个错误过，也符合我们的认识：子线程不能更新UI。但是实际上这个崩溃并不是必现的，不管是用户反馈还是我后来自己重现，都只有第一次进入界面的时候才会引起崩溃，后面都可以正常显示图片，所以带着疑问来一起看看这里面的具体分析吧。","text":"之前在项目里写了一段错误的代码，是使用异步线程下载图片之后直接更新UI，导致应用崩溃。报错信息是 Only the original thread that created a view hierarchy can touch its views. ，意思就是只有主线程可以更新UI。大家肯定都遇到这个错误过，也符合我们的认识：子线程不能更新UI。但是实际上这个崩溃并不是必现的，不管是用户反馈还是我后来自己重现，都只有第一次进入界面的时候才会引起崩溃，后面都可以正常显示图片，所以带着疑问来一起看看这里面的具体分析吧。 报错信息如下： 12345678910111213android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6556) at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:942) at android.view.ViewGroup.invalidateChild(ViewGroup.java:5081) at android.view.View.invalidateInternal(View.java:12717) at android.view.View.invalidate(View.java:12681) at android.view.View.invalidate(View.java:12665) at android.widget.TextView.checkForRelayout(TextView.java:7159) at android.widget.TextView.setText(TextView.java:4342) at android.widget.TextView.setText(TextView.java:4199) at android.widget.TextView.setText(TextView.java:4174) at com.wxp.uioperation.OpActivity$2.run(OpActivity.java:60) at java.lang.Thread.run(Thread.java:818) 一、先来分析一下上面的堆栈信息里面所显示出来的代码看看TextView的setText()方法中的line:4342 123456789private void setText(CharSequence text, BufferType type , boolean notifyBefore, int oldlen) &#123; ...... if (mLayout != null) &#123; checkForRelayout(); &#125; ......&#125; checkForRelayout方法中里面又调用了invalidate()方法，接着又调用了ViewRootImpl中的invalidateChildInParent()方法： 1234567@Overridepublic ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); ......&#125; 可以看到invalidateChildInParent()方法的第一行就是checkThread()方法，也就是说我们每次setText()的时候都会检查当前线程是不是mThread这个线程： 123456void checkThread() &#123; if (mThread != Thread. currentThread()) &#123; throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\" ); &#125;&#125; 而mThread变量是在ViewRootImpl的构造函数中初始化的。所以上面的checkThread()方法实际判断的是实例化ViewRootImpl对象所在的线程和当前操作UI，也就是执行setText()的线程是不是同一个线程。 123456789101112public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; mBasePackageName = context.getBasePackageName(); mDisplayAdjustments = display.getDisplayAdjustments(); mThread = Thread.currentThread(); ......&#125; 从上面的代码中也可以看出在ViewRootImpl中更新UI的时候会checkThread()检查线程。那ViewRootImpl是不是主线程呢？那就要分析一下RootViewImpl是怎么创建出来的了。先看看Activity的布局创建的过程。 二、Activity的布局加载过程以及Window的创建过程1.先来看看在Activity是怎么设置布局文件的Activity.setContentView()里面的代码: 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; getWindow()实际得到的是一个Window ，所以Activity的setContentView实际是交给了mWindow的setContentView处理。 123public Window getWindow() &#123; return mWindow;&#125; 那么Window和Activity还有Activity的布局有什么关系呢？来看看下面这张图： Activity还有Dialog,Toast以及PopupWindow都对应着一个Window。而它们的视图是不能单独存在的，必须依附在Window上。也就是说Activity的布局会被添加到它对应的Window里面。 2.再来看看Window是怎么创建出来的在Activity的启动过程中会通过ActivityThread这个类的handleLaunchActivity方法来启动Activity： 1234567891011121314151617181920212223private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; handleConfigurationChanged(null, null); WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed); ...... &#125; else &#123; ...... &#125;&#125; 其中performLaunchActivity()这个方法比较重要，完成了Activity对象的创建，并且调用了Activity的attach()方法，为它关联了上下文Context。handleResumeActivity()会在下面说到。来看看performLaunchActivity： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ...... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ...... &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ...... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... &#125; &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ...... &#125; return activity;&#125; 可以看到这里使用类加载器创建了一个Activity对象，并通过调用createBaseContextForActivity() 方法创建了一个上下文。注意到后面的mInstrumentation.callActivityOnCreate()方法，其实它是在Activity创建完成之后调用了Activity的onCreate()方法。 再看看attach()方法: 1234567891011121314151617181920212223242526final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; ......&#125; 在attach方法中也可以看到Activity的成员变量mWindow其实是一个PhoneWindow对象。到这里PhoneWindow已经有了。那我们是如何将自己的布局添加到Window中的？其实在Activity创建的时候会为它的Window添加一个DecorView作为Activity的根布局。DecorView是一个“装饰（Decoration）过的View”，比如说它还包含标题栏以及最重要的内容区域，而我们的布局文件则会添加到这个DecorView的内容区域里面。 3.DecorView的创建先来看看Window的setContentView()的具体实现： 12345678910111213141516171819202122@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; 首先就是通过installDecor()方法来生成Window的根布局DecorView： 1234567891011121314private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); ...... &#125;&#125; mDecor作为PhoneWindow的一个成员变量，如果mDecor为空，则调用generateDecor()直接返回一个DecorView对象： 123protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125; 那这个mContentParent是什么呢？看看generateLayout()方法： 1234567891011protected ViewGroup generateLayout(DecorView decor) &#123; ...... View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ...... return contentParent;&#125; 这里的layoutResource是上文（省略）根据Window的属性从系统中选择出的一个布局文件，而这些布局文件有一个共同的特征：都含有一个id为android.R.id.content的FrameLayout。然后把这个布局文件添加到DecorView中，并且找到android.R.id.content这个FrameLayout赋值给contentParent。 而上面Window中的setContentView()方法中有这段代码： mLayoutInflater.inflate(layoutResID, mContentParent); 很明显，是将我们设置的布局添加到mContentPartent中。 到这里我们已经知道了Window是如何产生的，还有我们的布局是如何添加到DecorView中的。那么DecorView又是如何添加到Window中的呢？那就通过下面要说的ViewRootImpl来实现了。 三、ViewRootImpl的创建上文在Activity的初始化过程中的performLaunchActivity()方法中已经把Window和DecorView创建好了，但是并没有看到ViewRootImpl的身影。我们往下看，在ActivityThread的handleResumeActivity()方法中直接获取到Activity中的Window所包含的DecorView: r.window.getDecorView(); 接着通过ViewManager的addView方法将DecorView添加到Window中，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; ...... if (r != null) &#123; final Activity a = r.activity; ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; &#125; else if (!willBeVisible) &#123; r.hideForNow = true; &#125; ...... if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; ...... if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; ...... &#125; else &#123; ...... &#125;&#125; ViewManager是一个接口。它定义了Window对View几个基本的操作： 123public void addView(View view, ViewGroup.LayoutParams params);public void updateViewLayout(View view, ViewGroup.LayoutParams params);public void removeView(View view); WindowManager也是一个接口，它继承自ViewManager接口。而WindowManagerImpl则是WindowManager的具体实现。看到WindowManagerImpl的addView方法中，直接调用了mGlobal.addView()。 12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow);&#125; mGlobal是一个WindowManagerGlobal对象，重点来了，看看它的addView()方法： 1234567891011121314151617181920212223242526public void addView(View view, ViewGroup.LayoutParams params , Display display , Window parentWindow) &#123; ...... ViewRootImpl root; View panelParentView = null; synchronized ( mLock) &#123; ...... root = new ViewRootImpl(view.getContext() , display); view.setLayoutParams(wparams) ; mViews .add(view); mRoots .add(root); mParams .add(wparams) ; &#125; // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView) ; &#125; catch (RuntimeException e) &#123; ...... &#125;&#125; 在WindowManagerGlobal的addView方法中会实例化ViewRootImpl对象。然后将这个对象添加到mRoots这个集合中去。 123mView存储的是所有Window对应的ViewmRoots存储的是所有Window对应的ViewRootImplmParams存储的是所有Window对应的布局参数 也就是说WindowManagerGlobal作为一个单例会把应用程序中的所有Window保存起来统一管理。 接着看到最后的root.setView方法，就是将DecorView传递给RootViewImpl，看到这里我们可以知道RootViewImpl实际上是作为一个媒介来替Window管理的它的布局。所以在上面的报错信息里，更新布局的时候才会执行到ViewRootImpl.invalidateChildInParent()方法 从上面的分析可以看到ViewRootImpl所在的线程其实就是ActivityThread所在的线程，也就是主线程。所以上面说的checkThread()方法是判断ViewRootImpl对象所在的线程和操作UI的线程是不是同一个线程，确实就是每次操作UI的时候都要检查是否处在UI线程。 那在ViewRootImpl创建之前我们去更新UI呢？其实可以在任意线程更新UI，这也就是我一开始说的，为什么只有第一次进入界面才会报错，是因为从网络下载图片需要一定的时间，而下载完成之后RootViewImpl已经创建完成，这个时候再去更新UI必然会报错。而第二次进入界面的时候，由于本地已由图片缓存，在RootViewImpl创建之前直接加载图片更新UI，就没有报错了。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"ScrollView嵌套ListView处理事件冲突","slug":"2015-10-23-TouchEventListViewInScrollView","date":"2015-10-22T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/10/23/2015-10-23-TouchEventListViewInScrollView/","link":"","permalink":"http://ai.wisim.me/2015/10/23/2015-10-23-TouchEventListViewInScrollView/","excerpt":"当ListView嵌套在ScrollView中时会有两个问题 列表内容显示不全 滑动事件冲突 第一个问题可以参考ScrollView与ListView嵌套仿微博个人主页中的解决方法。 第二个问题就是下面要讲的废话了。","text":"当ListView嵌套在ScrollView中时会有两个问题 列表内容显示不全 滑动事件冲突 第一个问题可以参考ScrollView与ListView嵌套仿微博个人主页中的解决方法。 第二个问题就是下面要讲的废话了。 一、首先要实现的效果是 手指在ListView中滑动时，滑动事件要交给ListView来处理，也就是说手指在ListView的内容区域中可以上下滑动。 ListView中的内容滑动到顶部后如果手指还是继续向下滑（自己模拟一下），此时的滑动事件应该交给ScrollView来处理，也就是说ScrollView可以继续滑动。 ListView中的内容滑动到底部后如果手指还是继续向上滑（自己模拟一下），此时的滑动事件应该交给ScrollView来处理，也就是说ScrollView可以继续滑动。 下面就来一个一个的实现上面所列出的效果 二、手指在ListView中滑动时，滑动事件要交给ListView来处理1.首先如果不做任何处理，ListView嵌套在ScrollView中时，默认滑动事件是被ScrollView处理掉的，效果是这样的： 我们都知道ViewGroup默认是不拦截事件的，看一下ViewGroup的源码就知道： 123public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false;&#125; 而ScrollView是继承自FrameLayout的，那为什么ScrollView会自己处理掉滑动事件呢，到ScrollView的源码里一搜，在onInterceptTouchEvent方法中居然有这么触目惊心的一段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; final int action = ev.getAction(); if ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123; return true; &#125; if (getScrollY() == 0 &amp;&amp; !canScrollVertically(1)) &#123; return false; &#125; switch (action &amp; MotionEvent.ACTION_MASK) &#123; case MotionEvent.ACTION_MOVE: &#123; final int activePointerId = mActivePointerId; if (activePointerId == INVALID_POINTER) &#123; // If we don't have a valid id, the touch down wasn't on content. break; &#125; final int pointerIndex = ev.findPointerIndex(activePointerId); if (pointerIndex == -1) &#123; Log.e(TAG, \"Invalid pointerId=\" + activePointerId+ \" in onInterceptTouchEvent\"); break; &#125; final int y = (int) ev.getY(pointerIndex); final int yDiff = Math.abs(y - mLastMotionY); if (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == 0) &#123; mIsBeingDragged = true; mLastMotionY = y; initVelocityTrackerIfNotExists(); mVelocityTracker.addMovement(ev); mNestedYOffset = 0; if (mScrollStrictSpan == null) &#123; mScrollStrictSpan = StrictMode.enterCriticalSpan(\"ScrollView-scroll\"); &#125; final ViewParent parent = getParent(); if (parent != null) &#123; parent.requestDisallowInterceptTouchEvent(true); &#125; &#125; break; &#125; case MotionEvent.ACTION_DOWN: &#123; final int y = (int) ev.getY(); if (!inChild((int) ev.getX(), (int) y)) &#123; mIsBeingDragged = false; recycleVelocityTracker(); break; &#125; /* * Remember location of down touch. * ACTION_DOWN always refers to pointer index 0. */ mLastMotionY = y; mActivePointerId = ev.getPointerId(0); initOrResetVelocityTracker(); mVelocityTracker.addMovement(ev); mIsBeingDragged = !mScroller.isFinished(); if (mIsBeingDragged &amp;&amp; mScrollStrictSpan == null) &#123; mScrollStrictSpan = StrictMode.enterCriticalSpan(\"ScrollView-scroll\"); &#125; startNestedScroll(SCROLL_AXIS_VERTICAL); break; &#125; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: /* Release the drag */ mIsBeingDragged = false; mActivePointerId = INVALID_POINTER; recycleVelocityTracker(); if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) &#123; postInvalidateOnAnimation(); &#125; stopNestedScroll(); break; case MotionEvent.ACTION_POINTER_UP: onSecondaryPointerUp(ev); break; &#125; return mIsBeingDragged;&#125; (1). 首先看到的是如果ScrollView接收到MOVE事件，并且这个mIsBeingDragged为true，它的onInterceptTouchEvent方法直接就返回true了，也就是拦截了滑动事件，交给它自己处理了。 (2). 接着看switch里面case MotionEvent.ACTION_DOWN，如果按下的时候手指落在了子控件里面mIsBeingDragged置为false。 里面还有这么一句mIsBeingDragged = !mScroller.isFinished();，mIsBeingDragged就表示当前ScrollView是否在滑动 这mIsBeingDragged有啥卵用呢？联系上面1中所说，假如ScrollView还在滑动的时候，你想去触摸嵌在里面的ListView，没门，ScrollView滑动还没结束呢，继续直接return true。 另外要说的是，不管咋样ScrollView并不会把ListView的点击事件给拦截掉。 (3). 再来看看switch里面case MotionEvent.ACTION_MOVE，如果y轴方向上的滑动距离大于最小滑动距离，则将mIsBeingDragged设置为true。结合上面第二点所说，啥情况呢？也就是说虽然我手指落在了子View里面，但是如果我要滑动的话，谁也拦不住老纸（Parent）！！ 从上面几点来看，ScrollView确实默认会自己处理掉滑动事件。我们想想事件分发的流程，如果父控件拦截了事件，子控件就没办法接收到事件了。那如何才能让ListView来处理滑动事件呢，接着说。 2.想要让ListView来处理滑动事件，首先要重写它的dispatchTouchEvent方法我们继承ListView实现自己的一个MyListView,重写它的dispatchTouchEvent方法 1234567891011121314@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(TAG, TAG + \"dispatchTouchEvent\"); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG, TAG + \"dispatchTouchEvent -&gt; MotionEvent.ACTION_DOWN\"); downY = ev.getRawY(); y = downY; getParent().requestDisallowInterceptTouchEvent(true); break; ...... &#125;&#125; 在它的 MotionEvent.ACTION_DOWN 事件中调用: getParent().requestDisallowInterceptTouchEvent(true); 这个’requestDisallowInterceptTouchEvent’真绕口，就是说 我[ListView]的父亲啊[getParent()]请求您[request]行行好别让[Disallow]您的onInterceptTouchEvent方法再拦截我的事件了啊[true] 因此如果你在ListView中调用了这个方法之后，父控件（ScrollView）就不会拦截ListView的滑动事件了。ListView的内容也就可以正常滑动了。 三、ListView中的内容滑动到顶部后以及滑动到底部后，事件应该交给ScrollView来处理在MyListView中实现这两个方法： 12345678910111213141516171819202122public boolean scrollToBottom() &#123; int first = getFirstVisiblePosition(); int last = getLastVisiblePosition(); int visibleCoutn = getChildCount(); int count = getCount(); if ((first + visibleCoutn) == count) &#123; return true; &#125; return false;&#125;public boolean scrollToTop() &#123; int first = getFirstVisiblePosition(); int last = getLastVisiblePosition(); int visibleCoutn = getChildCount(); int count = getCount(); if (first == 0) &#123; return true; &#125; return false;&#125; 一个用于判断ListView是否滑动到底部，一个用于判断ListView是否滑动到顶部。 接着继续重写dispatchTouchEvent方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(TAG, TAG + \"dispatchTouchEvent\"); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: downY = ev.getRawY(); y = downY; getParent().requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: y = ev.getRawY(); if (scrollToTop()) &#123; if (y - downY &gt; mTouchSlop) &#123; /** * Point 1 : 如果滑动到顶部，并且手指还想向下滑动，则事件交还给父控件，要求父控件可以拦截事件 */ getParent().requestDisallowInterceptTouchEvent(false); return false; &#125; else if (y - downY &lt; -mTouchSlop) &#123; /** * Point 2 : 如果滑动到顶部，并且手指正常向上滑动，则事件由自己处理，要求父控件不许拦截事件 */ getParent().requestDisallowInterceptTouchEvent(true); &#125; &#125; if (scrollToBottom()) &#123; if (y - downY &lt; -mTouchSlop) &#123; /** * Point 3 : 如果滑动到底部，并且手指还想向上滑动，则事件交还给父控件，要求父控件可以拦截事件 */ getParent().requestDisallowInterceptTouchEvent(false); return false; &#125; else if (y - downY &gt; mTouchSlop) &#123; /** * Point 4 : 如果滑动到底部，并且手指正常向下滑动，则事件由自己处理，要求父控件不许拦截事件 */ getParent().requestDisallowInterceptTouchEvent(true); &#125; &#125; break; case MotionEvent.ACTION_UP: break; default: break; &#125; return super.dispatchTouchEvent(ev);&#125; 很简单，看注释，实现的效果： THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Ant 构建Android工程","slug":"2015-10-22-AndroidAnt","date":"2015-10-21T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/10/22/2015-10-22-AndroidAnt/","link":"","permalink":"http://ai.wisim.me/2015/10/22/2015-10-22-AndroidAnt/","excerpt":"前言：Eclipse时代的Android构建工具Ant，原本是用于跨平台构建Java工程的，虽然现在AndroidSrudio已经默认使用Gradle了，不过还是有学习的地方的。 1.下载选择 apache-ant-1.9.6-bin.zip版本","text":"前言：Eclipse时代的Android构建工具Ant，原本是用于跨平台构建Java工程的，虽然现在AndroidSrudio已经默认使用Gradle了，不过还是有学习的地方的。 1.下载选择 apache-ant-1.9.6-bin.zip版本 2.配置环境变量2.1.新建 ANT_HOME 环境变量 2.2.添加到path 2.3.命令行检测 ： ant -version 3. 直接创建ant模板工程终端执行 ： android create project -k com.wxp.ant.test -a MainActivity -p ./AntTest -t 11 也可以使用 update命令来更新一个已有的工程 ： android update project -k com.wxp.ant.test -a MainActivity -p ./AntTest -t 11 参数详情： 12345-n 项目名称-k 新建工程的包名-a 入口Activity-p 路径-t 目标平台 （可以使用 android list targets 查看可用平台） 此外还有直接创建gradle项目模板的命令 android create project -k com.wxp.ant.test -a MainActivity -p ./GradleTest -t 11 -n GradleTest -g -v 1.2.3 对比一下两个工程的目录结构 4.编译命令123456ant debug : 生成一个debug包ant release : 生成一个release包ant isntalldant installr : 直接安装apkant uninstall : 直接卸载apkant clean : 清理工程 Android SDK中已经有了一个比较完整的build.xml文件了 ： sdk\\tools\\ant\\build.xml ant release 实际执行的是 : 1234567&lt;!-- This runs -package-release and -release-nosign first and then runs only if release-sign is true (set in -release-check, called by -release-no-sign)--&gt;&lt;target name=\"release\" depends=\"-set-release-mode, -release-obfuscation-check, -package, -post-package, -release-prompt-for-password, -release-nosign, -release-sign, -post-build\" description=\"Builds the application in release mode.\"&gt;&lt;/target&gt; ant debug 实际执行的是 : 12345&lt;!-- Builds debug output package --&gt;&lt;target name=\"debug\" depends=\"-set-debug-files, -do-debug, -post-build\" description=\"Builds the application and signs it with a debug key.\"&gt;&lt;/target&gt; 5.编译、打包的步骤：12345678910111213141516171819205.1第一步 生成R.java类文件：ant和命令行使用android SDK提供的aapt.exe程序生成R.java。5.2第二步 将.aidl文件生成.java类文件：ant和命令行使用android SDK提供的aidl.exe生成.java文件。5.3第三步 编译.java类文件生成class文件：ant和命令行使用jdk的javac编译java类文件生成class文件。5.4第四步 将class文件打包生成classes.dex文件：ant和命令行使用android SDK提供的dx.bat命令行脚本生成classes.dex文件。5.5第五步 打包资源文件（包括res、assets、androidmanifest.xml等）：ant和命令行使用Android SDK提供的aapt.exe生成资源包文件。5.6第六步 生成未签名的apk安装文件：ant和命令行使用android SDK提供的apkbuilder.bat命令脚本生成未签名的apk安装文件。5.7第七步 对未签名的apk进行签名生成签名后的android文件：ant和命令行使用jdk的jarsigner对未签名的包进行apk签名。 6.使用自定义的签名在项目根目录下添加ant.properties（或者local.properties）文件,配置密钥的路径和别名 1234key.store=F:\\\\wxp.keystorekey.store.password=mimakey.alias=wxpkey.alias.password=mima 7.使用外部jar包或者libraryjar包可以直接放到libs目录下面，打包的时候会自动打包进去 重点是使用已有的工程作为libiary (1)首先将libiary拷贝到工程根目录，以slidingmenulibrary为例，进入slidingmenulibrary目录执行 ： android update lib-project -t 11 -p ./ 或者直接在根目录下执行 ：android update project -n AntTest -t 11 -p ./ --subprojects 这样中方法会为目录下的每一个子工程生成构建ant所需要的文件 (2)添加相应的配置 在slidingmenulibrary目录下的project.properties文件加入 ： android.library=true 在AntTest目录下的project.properties文件中加入要使用的libiary的名称 ： android.library.reference.1=./slidingmenulibrary (3)编译 ant debug install 使用slidingmenulibrary的效果图： 8.多渠道包打包下载 多渠道所需的jar包 ： ant-contrib-1.0b3.jar，放到ant的lib目录下 (1)在AndroidManifest.xml中配置默认的渠道 (2)在\\AntTest\\ant.properties中配置多个渠道 (3)在AntTest目录下新建 一个 custom_rules.xml 文件,内容如下 : 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project name=\"custom_rules\" &gt; &lt;taskdef resource=\"net/sf/antcontrib/antcontrib.properties\" &gt; &lt;classpath&gt; &lt;pathelement location=\"lib/ant-contrib-1.0b3.jar\" /&gt; &lt;/classpath&gt; &lt;/taskdef&gt; &lt;target name=\"deploy\" &gt; &lt;foreach delimiter=\",\" list=\"$&#123;market_channels&#125;\" param=\"channel\" target=\"modify_manifest\" &gt; &lt;/foreach&gt; &lt;/target&gt; &lt;target name=\"modify_manifest\" &gt; &lt;echo message=\"=============BEGIN $&#123;channel&#125; ==============\" /&gt; &lt;replaceregexp flags=\"g\" byline=\"false\"&gt; &lt;!--正则匹配JD_CHANNEL字段 --&gt; &lt;regexp pattern=\"android:name=&amp;quot;JD_CHANNEL&amp;quot; android:value=&amp;quot;(.*)&amp;quot;\" /&gt; &lt;!--将匹配到的JD_CHANNEL字段的值替换成自定义的渠道 $&#123;channel&#125; --&gt; &lt;substitution expression=\"android:name=&amp;quot;JD_CHANNEL&amp;quot; android:value=&amp;quot;$&#123;channel&#125;&amp;quot;\" /&gt; &lt;fileset dir=\"\" includes=\"AndroidManifest.xml\" /&gt; &lt;/replaceregexp&gt; &lt;!--指定apk输出的位置 --&gt; &lt;mkdir dir=\"$&#123;channel&#125;\" /&gt; &lt;property name=\"out.final.file\" location=\"$&#123;channel&#125;/$&#123;ant.project.name&#125;_$&#123;channel&#125;.apk\" /&gt; &lt;!-- antcall是修改之后需要继续执行的任务target。这里调用的是clean和debug. --&gt; &lt;antcall target=\"clean\" /&gt; &lt;antcall target=\"debug\" /&gt; &lt;echo message=\"=============END $&#123;channel&#125; ==============\" /&gt; &lt;/target&gt;&lt;/project&gt; (4)直接用aapt查看AndroidManifest.xml文件的内容，看看有没有打包成功 aapt l -a AntTest_JD.apk aapt l -a AntTest_Xiaomi.apk 参考文章： http://blog.csdn.net/xxdddail/article/details/21384995?utm_source=tuicool&amp;utm_medium=referral http://my.oschina.net/oppo4545/blog/346778#OSC_h6_5 http://blog.csdn.net/sky_monkey/article/details/11882411 说了这么多，其实然并卵 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android依赖注入框架 Dagger1 深入了解","slug":"2015-10-13-AndroidDagger1Deep","date":"2015-10-12T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/10/13/2015-10-13-AndroidDagger1Deep/","link":"","permalink":"http://ai.wisim.me/2015/10/13/2015-10-13-AndroidDagger1Deep/","excerpt":"一、前言之前已经介绍了Dagger的简单使用 接下来看看Dagger中还有一些别的常用的注解如何使用","text":"一、前言之前已经介绍了Dagger的简单使用 接下来看看Dagger中还有一些别的常用的注解如何使用 二、@Provides注解1.对构造方法进行注解是很好用的实现依赖的途径，然而它并不适用于所有情况。 接口（Interface）是没有构造方法的 第三方库提供的类，它们的构造方法不能被注解 有些类需要灵活选择初始化的配置，而不是使用一个单一的构造方法 所以除了直接@Inject构造函数，也可以通过@Provides注解来获取到对象。Dagger要求所有的@Provides必须属于一个Module。 1234567@Module(injects = MainActivity.class)public class MsgMoudle &#123; @Provides DraftsBox provideDraftsBox() &#123; return new DraftsBox(); &#125;&#125; 而Module仅仅是一个使用了@Module注解的类。 Module的作用是提供信息，让ObjectGraph知道应该怎样注入所有的依赖。例如，上面这段代码中声明了可注入对象的信息：MainActivity.class 2.限定符注解 @Qualifier有些时候，单纯类型（指这些基本的@Inject….等等）是不能够满足指定依赖的需求的。 在这种情况下，我们可以添加限定符注释来自定义一个注解， 这种注释本身有一个@Qualifier注释 123456789@Module(injects = MainActivity.class,library = true)public class MsgMoudle &#123; @Provides @MyInt(1) public int providesMyInt() &#123; return 1; &#125;&#125; 使用的时候在@Inject下面加上@MsgMoudle.MyInt(1)即可 123@Inject@MsgMoudle.MyInt(1)int mLength; 3.有些情况下， 你需要多个对象实例， 而不是仅仅注入一个对象实例。这时你可以利用Provider实现， 每次调用Provider的get()函数将返回新的的对象实例。 12345678910public class DraftsBox&#123; @Inject Provider&lt;NewMsg&gt; providerNewMsg; public void edit()&#123; providerNewMsg.get(); //得到对象1 providerNewMsg.get(); //得到对象2 //对象1 和 对象2 是两个不同的对象. &#125;&#125; 二、Dagger中其他一些注解的使用1.当我们希望不管多少个地方注入DraftsBox这个类，我们只希望拥有一份“DraftsBox”的实例对象（单例）。那么我们可以用到注解@Singleton 加在 @Provides注解的后面即可 123@Provides @Singleton DraftsBox provideDraftsBox()&#123; return new DraftsBox();&#125; @Singleton 注释对Dagger有效， 也只在一个ObjectGraph中生效。 若是有多个ObjectGraph， 则有多个相应的@Singleton对象。 2.延迟注入 Lazy :(即：懒加载, 等到调用的时候才注入)1234567public class Account&#123; @Inject Lazy&lt;DraftsBox&gt; lazyDraftsBox; public void save()&#123; lazyDraftsBox.get();//这样就能得到一个DraftsBox对象 &#125;&#125; 三、@Module的一些说明 在@Module中加入一个参数 complete=false， 标记说明该Module为不完整的Module。因为不完整的Module允许缺少对象实例。 2.如果在@Module中已经加入参数injects (即所谓的：注入对象列表绑定),若是这个Module提供的对象绑定， 可能被injects列表中以外的类使用， 可以将改Module标记为library, 以避免出错。 如： 123456789101112@Module(injects = DraftsBox.class,library = true)public class DraftsBoxModule&#123; @Provides NewMsg provideNewMsg()&#123; return new NewMsg(); &#125; @Provides Others provideOthers()&#123; return new Others; &#125;&#125; 分析：由于DraftsBox只用到了一个NewMsg的类，而injects列表中也只写了DraftsBox.class。这样的话，NewMsg这个类提供的其他方法有可能被除了DraftsBox之外的类所用，那么避免报错就要在@Module加上参数library=true THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android依赖注入框架 Dagger1","slug":"2015-10-08-AndroidDagger1Demo","date":"2015-10-07T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/10/08/2015-10-08-AndroidDagger1Demo/","link":"","permalink":"http://ai.wisim.me/2015/10/08/2015-10-08-AndroidDagger1Demo/","excerpt":"一、前言1. 依赖如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。 12345678public class Human &#123; ... Father father; ... public Human() &#123; father = new Father(); &#125;&#125;","text":"一、前言1. 依赖如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。 12345678public class Human &#123; ... Father father; ... public Human() &#123; father = new Father(); &#125;&#125; 仔细看这段代码我们会发现存在一些问题： (1). 如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码； (2). 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中； (3). 如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。 2. 依赖注入上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下： 12345678public class Human &#123; ... Father father; ... public Human(Father father) &#123; this.father = father; &#125;&#125; 上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处： (1). 解耦，将依赖之间解耦。 (2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。 在代码中，许多对象在使用前都需要初始化，如果都是手写依赖注入的代码有时候会比较麻烦。 Dagger 的用途就是：让你不需要手动初始化对象，完全自动注入对象。 换句话说，任何对象声明完了就能直接用。 Dagger是通过ObjectGraph(对象图表)来管理或者组织依赖关系的。所以要记得创建ObjectGraph类并执行inject()方法并将当前所在的类作为参数传入 二、Dagger的基本使用1.初始化对象通过在NewMsg的构造函数之前添加一个 @Inject 注解。Dagger就会在需要的时候找到这个标记的构造函数，并获取它的对象。 123456789101112131415public class NewMsg &#123; public String title; public String content; @Inject public NewMsg()&#123; &#125; public String toJson() &#123; StringBuilder sb = new StringBuilder(); sb.append(\"&#123;\").append(\"\\\"title\\\":\\\"\").append(title).append(\"\\\",\").append(\"\\\"content\\\":\\\"\").append(content).append(\"\\\"&#125;\"); return sb.toString(); &#125;&#125; (1). 如果你@Inject fields却没有@Inject构造函数，Dagger就会使用一个存在的无参构造函数，若没有@Inject构造函数，就会出错。 (2). 需要注意的是，如果构造函数含有参数，Dagger会在构造对象的时候先去获取这些参数，所以你要保证这些参数的构造方法也有@Inject标记，或者能够通过@Provides注解来获取到。 2.@Inject 注入将一个 NewMsg 对象注入到MainActivity 1234567891011public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener &#123; ObjectGraph objectGraph; @Inject NewMsg newMsg; @Inject DraftsBox mDraftsBox; ......&#125; 3.ObjectGraph初始化创建ObjectGraph类并执行inject()方法并将当前MainActivity作为参数传入， NewMsg 的对象就被注入到了MainActivity中。 12345678910111213141516171819......@InjectNewMsg newMsg;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); if (objectGraph == null) &#123; objectGraph = ObjectGraph.create(new MsgMoudle()); objectGraph.inject(this); &#125;&#125;...... 这样，就成功使用Dagger将一个NewMsg对象注入到MainActivity中并可正常使用了。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Java泛型小结","slug":"2015-09-20-JavaGenericType","date":"2015-09-19T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/09/20/2015-09-20-JavaGenericType/","link":"","permalink":"http://ai.wisim.me/2015/09/20/2015-09-20-JavaGenericType/","excerpt":"一、普通的泛型比如我们经常使用的List data = new ArrayList;这里我们直接指定List中存储的是String类型的数据，避免在get的时候还要强制转换。 1.来定义一个简单的泛型： 123456789101112public class MessageQueue&lt;T&gt; &#123; private T mMsg = null; public T getMsg() &#123; return mMsg; &#125; public void addMsg(T msg) &#123; this.mMsg = msg; &#125; public void printMsg() &#123; System.out.println(this.mMsg); &#125;&#125;","text":"一、普通的泛型比如我们经常使用的List data = new ArrayList;这里我们直接指定List中存储的是String类型的数据，避免在get的时候还要强制转换。 1.来定义一个简单的泛型： 123456789101112public class MessageQueue&lt;T&gt; &#123; private T mMsg = null; public T getMsg() &#123; return mMsg; &#125; public void addMsg(T msg) &#123; this.mMsg = msg; &#125; public void printMsg() &#123; System.out.println(this.mMsg); &#125;&#125; 2.测试代码： 12345678910111213public class TypeTest &#123; public static void main(String[] args) &#123; System.out.println(\"= = = = = = = = MessageQueue | 基本泛型 = = = = = = = = = \"); MessageQueue&lt;String&gt; mq= new MessageQueue&lt;String&gt;(); mq.addMsg(\"MQ\"); System.out.println(mq.getMsg()); mq.printMsg(); MessageQueue&lt;Integer&gt; mqInt= new MessageQueue&lt;Integer&gt;(); mqInt.addMsg(1); System.out.println(mqInt.getMsg()); mqInt.printMsg(); &#125;&#125; 3.可以看到运行的结果是： 12345= = = = = = = = MessageQueue | 基本泛型 = = = = = = = = =MQMQ11 二、两个或者多个泛型参数1.还是来定义含有两个参数的泛型类 1234567891011121314151617181920public class UserInfo&lt;K,V&gt; &#123; private K key; private V value; public void put(K key,V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; public String toString() &#123; return this.key.toString() + \" | \" + value.toString(); &#125;&#125; 2.测试代码： 12345678public class TypeTest &#123; public static void main(String[] args) &#123; System.out.println(\"= = = = = = = = UserInfo | 两个泛型参数 = = = = = = = = = \"); UserInfo&lt;Integer,String&gt; userInfo = new UserInfo&lt;Integer,String&gt;(); userInfo.put(2,\"wxp\"); System.out.println(userInfo.toString()); &#125;&#125; 3.看一下运行的结果： 12= = = = = = = = UserInfo | 两个泛型参数 = = = = = = = = =2 | wxp 第一个参数就是key，第二个参数就是value 三、泛型通配符1.定义一个简单的泛型，或者直接使用上面的MessageQueue类，都是可以的 12345678910111213public class MsgModel&lt;T&gt; &#123; private T mMsg = null; public T getMsg() &#123; return mMsg; &#125; public void addMsg(T msg) &#123; this.mMsg = msg; &#125; @Override public String toString() &#123; return this.mMsg.toString(); &#125;&#125; 2.接着定义一个printStringMsgModel方法，这个方法的参数时一个MsgModel类型，但是它的泛型参数只能只能接收String或Object（String的父类）类型的泛型，这个是受限通配符，用&lt;? extends String&gt;表示。 1234//受限通配符，限制泛型参数只能接收String或Object类型的泛型public static void printStringMsgModel(MsgModel&lt;? extends String&gt; model) &#123; System.out.println(\"model = \"+model.toString());&#125; 3.测试代码： 12345678public class TypeTest &#123; public static void main(String[] args) &#123; System.out.println(\"= = = = = = = = MsgModel | 通配符 = = = = = = = = = \"); MsgModel&lt;String&gt; msgModel = new MsgModel&lt;String&gt;(); msgModel.addMsg(\"www\"); printStringMsgModel(msgModel); &#125;&#125; 4.运行的结果是： 12= = = = = = = = MsgModel | 通配符 = = = = = = = = =model = www &lt;? extends UserInfo&gt; 表示上边界通配符，参数类型只能是UserInfo或者其子类 &lt;? super UserInfo&gt; 表示下边界通配符，参数类型只能是UserInfo或者其父类 5.或者也可以这样定义一个printUserInfoMsgModel方法，表示只能接受UserInfo或者其子类的泛型参数 1234//受限通配符，限制泛型参数只能接收UserInfo或子类类型的泛型public static void printUserInfoMsgModel(MsgModel&lt;? extends UserInfo&gt; model) &#123; System.out.println(\"model = \"+model.getMsg().toString());&#125; 测试一下： 123456789public class TypeTest &#123; public static void main(String[] args) &#123; UserInfo&lt;Integer,String&gt; userInfo1 = new UserInfo&lt;Integer,String&gt;(); userInfo1.put(3,\"wxp\"); MsgModel&lt;UserInfo&gt; msgModelUserInfo = new MsgModel&lt;UserInfo&gt;(); msgModelUserInfo.addMsg(userInfo1); printUserInfoMsgModel(msgModelUserInfo); &#125;&#125; 运行的结果： 1model = 3 | wxp 6.如果是非受限通配符的话直接使用MsgModel&lt;? &gt;这样就可以了 四.泛型接口1.定义一个泛型接口 123public interface IUploadMsg&lt;T&gt; &#123; public void upload(T msg);&#125; 2.定义一个UploadAction类，并实现IUploadMsg接口 12345678910111213//泛型接口public static class UploadAction&lt;T&gt; implements IUploadMsg&lt;T&gt; &#123; private T mMsg; public void addMsg(T msg) &#123; this.mMsg = msg; upload(msg); &#125; @Override public void upload(T msg) &#123; System.out.println(\"uploading msg...\"+msg.toString()); &#125;&#125; 3.测试代码： 12345678910public class TypeTest &#123; public static void main(String[] args) &#123; System.out.println(\"= = = = = = = = IUploadMsg | 泛型接口 = = = = = = = = = \"); UploadAction&lt;String&gt; uploadAction = new UploadAction&lt;String&gt;(); uploadAction.addMsg(\"xxx\"); UploadIntAction uploadIntAction = new UploadIntAction(); uploadIntAction.addMsg(4); &#125;&#125; 4.看一下运行结果： 123= = = = = = = = IUploadMsg | 泛型接口 = = = = = = = = =uploading msg...xxxuploading msg...4 五、泛型方法1.定义一个DownloadMsg类，它有一个download方法，可以传入一个泛型参数msg 12345public class DownloadMsg &#123; public static &lt;T&gt; void download(T msg) &#123; System.out.println(\"Downloading msg...\"+msg.toString()); &#125;&#125; 2.测试代码： 1234567public class TypeTest &#123; public static void main(String[] args) &#123; System.out.println(\"= = = = = = = = DownloadMsg | 泛型方法 = = = = = = = = = \"); DownloadMsg.download(\"ppp\"); DownloadMsg.download(5.0); &#125;&#125; 3.看一下运行结果： 123= = = = = = = = DownloadMsg | 泛型方法 = = = = = = = = =Downloading msg...pppDownloading msg...5.0 六、泛型方法返回泛型实例1.定义一个普通的泛型类 12345678910111213public class GenerateInfo&lt;T&gt; &#123; private T mInfo; public void setInfo(T info) &#123; mInfo = info; &#125; public T getInfo() &#123; return mInfo; &#125; public String toString() &#123; System.out.println(this.mInfo.toString()); return mInfo.toString(); &#125;&#125; 2.定义一个方法，传入泛型参数，返回一个泛型实例 12345public static &lt;T&gt; GenerateInfo&lt;T&gt; genInfo(T info) &#123; GenerateInfo&lt;T&gt; temp = new GenerateInfo&lt;T&gt;(); temp.setInfo(info); return temp;&#125; 3.测试代码： 12345678910public class TypeTest &#123; public static void main(String[] args) &#123; System.out.println(\"= = = = = = = = GenerateInfo | 泛型方法返回泛型实例 = = = = = = = = = \"); GenerateInfo&lt;String&gt; info = genInfo(\"wwwxxxppp\"); info.toString(); UserInfo&lt;String,Integer&gt; userInfo2 = genUserInfo(\"wxp\",5); System.out.println(userInfo2.toString()); &#125;&#125; 4.运行结果： 123= = = = = = = = GenerateInfo | 泛型方法返回泛型实例 = = = = = = = = =wwwxxxpppwxp | 5 THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[]},{"title":"自定义ViewGroup实现竖向引导界面 Part2","slug":"2015-09-07-AndroidVerticalSplash2","date":"2015-09-06T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/09/07/2015-09-07-AndroidVerticalSplash2/","link":"","permalink":"http://ai.wisim.me/2015/09/07/2015-09-07-AndroidVerticalSplash2/","excerpt":"最终的目标是实现上下滑动切换页面，同时可以根据手指初始化速度来实现自行滚动。前面已经控制控件可以随着手指滑动上下滚动 第二步通过Scroller这个类来实现滑动超过一定距离之后松开手指，可以自动滚动到上一屏或者下一屏 原理就是在松开手指后，调用Scroller.startScroll方法来实现自动滚动","text":"最终的目标是实现上下滑动切换页面，同时可以根据手指初始化速度来实现自行滚动。前面已经控制控件可以随着手指滑动上下滚动 第二步通过Scroller这个类来实现滑动超过一定距离之后松开手指，可以自动滚动到上一屏或者下一屏 原理就是在松开手指后，调用Scroller.startScroll方法来实现自动滚动 一、在构造函数中实例化一个Scroller对象1mScroller = new Scroller(context); 因为布局无需变化，所以onMeasure()方法以及onLayout()方法中的内容不变。 二、在手指抬起时，判断是否需要自动滚动，重写onTouchEvent()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; /** * Point5 ：如果正在滚动则直接返回父类的onTouchEvent方法 */ if (mIsScrolling) &#123; return super.onTouchEvent(event); &#125; /** * Point6 ： 获取当前手指位置的Y坐标,这个值在滑动时是不断更新的 */ int y = (int) event.getY(); switch (event.getAction()) &#123; ...... case MotionEvent.ACTION_UP: mScrollEndY = getScrollY(); /** * Point11 ： 计算抬起时和按下时的差值 */ int dScrollY = mScrollEndY - mScrollStartY; if (wantScrollNext()) &#123; if (ableScroll()) &#123; /** * Point12 ： 判断用户想要滑到下一屏并且已经滑动的距离超过屏幕高度的1/2，则松开手指后控件自动继续向上滚动，从而滑动到下一屏 */ mScroller.startScroll(0, mScrollEndY, 0, mScreenHeight - dScrollY); &#125; else &#123; /** * Point13 ：否则，则松开手指后控件自动滚会原来的位置 */ mScroller.startScroll(0, mScrollEndY, 0, -dScrollY); &#125; &#125; if (wantScrollPre()) &#123; if (ableScroll()) &#123; mScroller.startScroll(0, mScrollEndY, 0, -mScreenHeight - dScrollY); &#125; else &#123; mScroller.startScroll(0, mScrollEndY, 0, -dScrollY); &#125; &#125; /** * 下面这一行很重要，表示抬起后，继续滑动。 * 如果没有这一行，松开手指后，自动滑动过程中点击控件会停止滑动 */ mIsScrolling = true; postInvalidate(); break; &#125; return true;&#125; 三、此外，上面调用的mScroller.startScroll方法并不会实际产生滚动效果，还需要重写View的computeScroll方法12345678910111213@Overridepublic void computeScroll() &#123; super.computeScroll(); /** * Point16 ： 判断是否滚动结束 */ if (mScroller.computeScrollOffset()) &#123; scrollTo(0, mScroller.getCurrY()); postInvalidate(); &#125; else &#123; mIsScrolling = false; &#125;&#125; 四、Part2 最终效果 参考网址：http://blog.csdn.net/lmj623565791/article/details/23692439 源码github ：https://github.com/whisper92/CustomViewDays/blob/master/app/src/main/java/views/Day11View.java THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"自定义ViewGroup实现竖向引导界面 Part3","slug":"2015-09-07-AndroidVerticalSplash3","date":"2015-09-06T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/09/07/2015-09-07-AndroidVerticalSplash3/","link":"","permalink":"http://ai.wisim.me/2015/09/07/2015-09-07-AndroidVerticalSplash3/","excerpt":"最终的目标是实现上下滑动切换页面，同时可以根据手指初始化速度来实现自行滚动。前面已经控制控件可以随着手指滑动上下滚动,并且滑动超过一定距离之后松开手指，可以自动滚动到上一屏或者下一屏 还有一些工作需要完善，比如加速度检测以及边界检测","text":"最终的目标是实现上下滑动切换页面，同时可以根据手指初始化速度来实现自行滚动。前面已经控制控件可以随着手指滑动上下滚动,并且滑动超过一定距离之后松开手指，可以自动滚动到上一屏或者下一屏 还有一些工作需要完善，比如加速度检测以及边界检测 一、首先来实现边界检测也就是滑动到顶部之后不能再继续向下滑动，滑动到底部之后也不能继续向上滑动 在onTouchEvent中作判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; if (mIsScrolling) &#123; return super.onTouchEvent(event); &#125; int y = (int) event.getY(); obtainVelocity(event); switch (event.getAction()) &#123; ...... case MotionEvent.ACTION_MOVE: if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; int dy = mLastY - y; /** * Point1 ： * (getScrollY() + dy) &lt; 0表示已经到达控件顶部 * dy &lt; 0表示还想要向下滑动 */ if ((getScrollY() + dy) &lt; 0 &amp;&amp; dy &lt; 0) &#123; return super.onTouchEvent(event); &#125; /** * Point2 ： * (getScrollY() + dy) &gt; (getHeight() - mScreenHeight)表示已经滑动到达控件底部了（控件的总的高度减去最后一个子View的高度则是最后一个控件的顶部位置） * dy &gt; 0表示还想要向上滑动 */ if ((getScrollY() + dy) &gt; (getHeight() - mScreenHeight) &amp;&amp; dy &gt; 0) &#123; return super.onTouchEvent(event); &#125; scrollBy(0, dy); mLastY = y; break; ...... &#125; return true;&#125; 这样不管滑动到顶部还是底部都不能再滑过边界了 二、实现加速度检测定义如下几个方法分别用于获取加速度检测器以及释放资源，还有获取Y轴的加速度 1234567891011121314151617181920212223242526272829303132333435/** * Point3 ：初始化加速度检测器 * * @param event */public void obtainVelocity(MotionEvent event) &#123; if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(event);&#125;/** * Point4 ：释放加速度检测器 */public void recycleVelocity() &#123; if (mVelocityTracker != null) &#123; mVelocityTracker.recycle(); mVelocityTracker = null; &#125;&#125;/** * Point5 ：获取Y轴方向加速度 * * @return */public int getYVelocity() &#123; mVelocityTracker.computeCurrentVelocity(1000); return (int) mVelocityTracker.getYVelocity();&#125; 三、然后在onTouchEvent中调用obtainVelocity方法以初始化加速度检测器12345678910@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; ...... obtainVelocity(event); ......&#125; 四、每次抬起手指后，都要释放加速度检测器资源12345678910111213141516@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; ...... switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: ...... recycleVelocity(); break; &#125; ......&#125; 五、在判断能否自动滚动的方法中加上加速度判断12345678/** * Point6 ： 当加速度大于600时，也判定可以滚动 * * @return */public boolean ableScroll() &#123; return Math.abs(mScrollEndY - mScrollStartY) &gt; mScreenHeight / 2 || Math.abs(getYVelocity()) &gt; 600;&#125; 六、Part3 最终效果 参考网址：http://blog.csdn.net/lmj623565791/article/details/23692439 源码github ：https://github.com/whisper92/CustomViewDays/blob/master/app/src/main/java/views/Day12View.java THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"自定义ViewGroup实现竖向引导界面 Part1","slug":"2015-09-06-AndroidVerticalSplash1","date":"2015-09-05T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/09/06/2015-09-06-AndroidVerticalSplash1/","link":"","permalink":"http://ai.wisim.me/2015/09/06/2015-09-06-AndroidVerticalSplash1/","excerpt":"最终的目标是实现上下滑动切换页面，同时可以根据手指初始化速度来实现自行滚动。第一步来实现控制控件可以随着手指滑动上下滚动 原理就是通过在手指滑动时，在onTouchEvent中调用scrollBy(0, dy)方法实现滚动效果。","text":"最终的目标是实现上下滑动切换页面，同时可以根据手指初始化速度来实现自行滚动。第一步来实现控制控件可以随着手指滑动上下滚动 原理就是通过在手指滑动时，在onTouchEvent中调用scrollBy(0, dy)方法实现滚动效果。 一、继承ViewGroup实现该控件在构造方法中获取屏幕高度 12345678910111213public class Day10View extends ViewGroup &#123; public Day10View(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); /** * Point1 ：获取屏幕高度 */ WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); DisplayMetrics metrics = new DisplayMetrics(); windowManager.getDefaultDisplay().getMetrics(metrics); mScreenHeight = metrics.heightPixels; &#125; ......&#125; 二、重写onMeasure方法123456789101112@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int childCount = getChildCount(); /** * Point2 ： 根据高度计算每个子View布局 */ for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); measureChild(childView, widthMeasureSpec, mScreenHeight); &#125;&#125; 三、重写onLayout方法，确定控件以及子View的布局123456789101112131415161718@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); /** * Point3 ： 设置控件的高度为 屏幕的高度*子View的个数 */ MarginLayoutParams marginLayoutParams = (MarginLayoutParams) getLayoutParams(); marginLayoutParams.height = mScreenHeight * childCount; setLayoutParams(marginLayoutParams); /** *Point4 ： 确定每个子View的位置 */ for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); childView.layout(l, i * mScreenHeight, r, (i + 1) * mScreenHeight); &#125;&#125; 四、重写onTouchEvent方法，处理滑动事件123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 移动时不断更新的Y值 */int mLastY = 0;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; /** * Point5：获取当前手指位置的Y坐标 */ int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: /** *Point6 ：手指按下时获取Y轴滚动的距离。 * getScrollY()是View的方法，如果为正表示内容向上滑动 */ mLastY = y; break; case MotionEvent.ACTION_MOVE: /** * Point7 : 计算Y轴滚动的差值 */ int dy = mLastY - y; /** * Point8 : 关键代码!!!调用scrollBy执行滚动 */ scrollBy(0, dy); /** * Point9 ： 这一步很重要，在手指尚未抬起时，要将y赋值给mLastY，接着继续执行Point7计算差值 */ mLastY = y; break; case MotionEvent.ACTION_UP: /*暂时这里还不需要进行操作*/ break; &#125; return true;&#125; 五、Part1 最终效果： 参考网址：http://blog.csdn.net/lmj623565791/article/details/23692439 源码github ：https://github.com/whisper92/CustomViewDays/blob/master/app/src/main/java/views/Day10View.java THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"JAVA设计模式-适配器模式","slug":"2015-08-28-DesignPatternAdapter","date":"2015-08-27T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/08/28/2015-08-28-DesignPatternAdapter/","link":"","permalink":"http://ai.wisim.me/2015/08/28/2015-08-28-DesignPatternAdapter/","excerpt":"适配器模式一、参与者 被适配的对象，就是源对象 适配后的对象，也就是目标对象 适配器","text":"适配器模式一、参与者 被适配的对象，就是源对象 适配后的对象，也就是目标对象 适配器 二、实现 定义一个目标接口，包含源对象的行为方法，以及需要适配的新的方法。 适配器类继承源对象，实现目标对象接口。 重写目标接口中新的行为方法，在方法内部实现新的行为。 三、效果客户端通过实例化一个适配器，便可获得一个目标对象，这个目标对象既可以实现源对象的方法，也可以实现适配后新的方法 四、实例现在已经有了一个可以画方形的类，现在客户端要通过这个画方形的类实现画圆的行为。 1.已有的画方形的类123456public class Square&#123; public void drawSquare(int width)&#123; System.out.println(\"drawSquare...width is : \"+width); &#125;&#125; 2.目标接口，包含画圆的方法。注意要定义一个和源对象同样的接口方法。12345public interface DrawBitmap&#123; public void drawSquare(int width); public void drawCircle(int radius);&#125; 3.基于方形画圆形的适配器123456789101112/** * 继承Square类，实现DrawBitmap接口 */public class DrawCircleAdapter extends Square implements DrawBitmap&#123; /*重载DrawBitmap接口的drawCircle方法,此时画出来的是一个圆*/ @Override public void drawCircle(int radius)&#123; System.out.println(\"drawCircle...radius is : \"+radius); &#125;&#125; 4.最后来测试一下123456789public class AdapterClient&#123; public static void main(String[] args) &#123; DrawBitmap draw=new DrawCircleAdapter(); draw.drawSquare(4); draw.drawCircle(2); &#125;&#125; 在终端执行： 12javac AdapterClient.javajava AdapterClient 看一下运行结果： 12drawSquare...width is : 4drawCircle...radius is : 2 可以看到经过DrawCircleAdapter适配器转换后的DrawBitmap对象，可以画出圆形了。 五、应用场景 业务的接口与工作的类不兼容，（比如：类中缺少实现接口的某些方法）但又需要两者一起工作 在现有接口和类的基础上为新的业务需求提供接口 实例源码：https://github.com/whisper92/wxpdesignpattern/tree/master/src/java/adapter/AdapterExample THE END.","categories":[{"name":"SE","slug":"SE","permalink":"http://ai.wisim.me/categories/SE/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://ai.wisim.me/tags/DesignPattern/"},{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/tags/JAVA/"}]},{"title":"Android 使用aidl实现进程间通信-传递自定义的类","slug":"2015-08-24-AndroidAidlImportClass","date":"2015-08-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/08/24/2015-08-24-AndroidAidlImportClass/","link":"","permalink":"http://ai.wisim.me/2015/08/24/2015-08-24-AndroidAidlImportClass/","excerpt":"之前使用aidl传递的都是基本的数据类型比如int 、boolean之类的还有就是String类型的参数，并没有传递自己定义的class。最近在开发的过程中重构代码时遇到了这个问题，网上也有文章提供了解决的办法，不过不太全面。我东拼西凑才把问题给解决了。这里记录一下。","text":"之前使用aidl传递的都是基本的数据类型比如int 、boolean之类的还有就是String类型的参数，并没有传递自己定义的class。最近在开发的过程中重构代码时遇到了这个问题，网上也有文章提供了解决的办法，不过不太全面。我东拼西凑才把问题给解决了。这里记录一下。 一、直接在aidl中的方法参数传递一个自定义类参数。看一下我们的aidl文件 1234567891011// IJDMAService.aidlpackage com.jingdong.jdlogsys;import com.jingdong.jdlogsys.model.CommonParamInfo;interface IJDFileLogService &#123; void setCommonParamInfo(CommonParamInfo info); void changeUser(String uid,String uuid,String pin);&#125; 这里的setCommonParamInfo方法的参数就是一个我们自己定义的类CommonParamInfo，虽然上面import了这个类，但是编译项目时会报如下的错误信息（使用Android Studio）。 1234Error:Execution failed for task &apos;:JDLogSys:compileReleaseAidl&apos;.&gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;D:\\Android\\sdk\\build-tools\\19.1.0\\aidl.exe&apos;&apos; finished with non-zero exit value 1Error:(5) couldn&apos;t find import for class com.jingdong.jdlogsys.model.CommonParamInfoF:\\JD_GIT\\JDLogSys\\JDLogSys\\res\\com\\jingdong\\jdlogsys\\IJDFileLogService.aidl 看到这么一行信息Error:(5) couldn&#39;t find import for class com.jingdong.jdlogsys.model.CommonParamInfo。意思就是找不到这个类。 二、网上提供了一个解决这个问题的方法首先新建一个CommonParamInfo.aidl文件，文件的内容如下： 123package com.jingdong.jdlogsys.model;parcelable CommonParamInfo; 要注意的是这里的package要和原本定义的类的包名一样，其次是下面的parcelable CommonParamInfo;这行代码。 当然最重要的一点是你自己定义的类要实现Parcelable接口并按照规范重写一系列方法。这里我就不做介绍了。 接着重新编译，是的不再报上面那个错误信息，但是报了另外一个错误： 1234:JDLogSys:compileReleaseAidlF:\\JD_GIT\\JDLogSys\\JDLogSys\\res\\com\\jingdong\\jdlogsys\\IJDFileLogService.aidl:14 parameter 1: &apos;CommonParamInfo info&apos; can be an out parameter, so you must declare it as in, out or inout.Error:Execution failed for task &apos;:JDLogSys:compileReleaseAidl&apos;.&gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;D:\\Android\\sdk\\build-tools\\19.1.0\\aidl.exe&apos;&apos; finished with non-zero exit value 1 看到这么一行信息IJDFileLogService.aidl:14 parameter 1: &#39;CommonParamInfo info&#39; can be an out parameter, so you must declare it as in, out or inout. 意思就是我们需要把这个参数声明成in或者inout类型的， 三、于是我们修改一下aidl中的setCommonParamInfo方法，一开始我是设置的inout：1void setCommonParamInfo(inout CommonParamInfo info); 于是，不出意外接着报错： 123456789Error:(144, 5) 错误: 找不到符号符号: 方法 readFromParcel(Parcel)位置: 类型为 CommonParamInfo 的变量 info注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。Error:Execution failed for task &apos;:JDLogSys:compileReleaseJava&apos;.&gt; Compilation failed; see the compiler error output for details.1 个错误注: 某些输入文件使用或覆盖了已过时的 API。F:\\JD_GIT\\JDLogSys\\JDLogSys\\build\\generated\\source\\aidl\\release\\com\\jingdong\\jdlogsys\\IJDFileLogService.java 啥状况呢，就是说找不到readFromParcel方法。我看了一下CommonParamInfo类，确实没有这个方法，但是之前该重写的方法都重写了啊，之前一直也是这么做的。于是我又接着搜索，找到了解决这个问题的方法，就是在CommonParamInfo类中自己添加一个readFromParcel方法 四、修改CommonParamInfo类，添加readFromParcel方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.jingdong.jdlogsys.model;import android.os.Parcel;import android.os.Parcelable;/** * Created by zhengqing on 2014/12/18. */public class CommonParamInfo implements Parcelable &#123; public static final Parcelable.Creator&lt;CommonParamInfo&gt; CREATOR = new Creator&lt;CommonParamInfo&gt;() &#123; @Override public CommonParamInfo[] newArray(int size) &#123; return new CommonParamInfo[size]; &#125; @Override public CommonParamInfo createFromParcel(Parcel in) &#123; return new CommonParamInfo(in); &#125; &#125;; public String strUid; //用户id public String strUuid; //用户唯一标识，根据设备串号等唯一编码 public CommonParamInfo() &#123; // TODO Auto-generated constructor stub &#125; @SuppressWarnings(\"unchecked\") public CommonParamInfo(Parcel in) &#123; // TODO Auto-generated constructor stub strUid = in.readString(); strUuid = in.readString(); &#125; public void readFromParcel(Parcel in)&#123; strUid = in.readString(); strUuid = in.readString(); &#125; public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(strUid) .append(strUuid); return sb.toString(); &#125; public String getStrUid() &#123; return strUid; &#125; public void setStrUid(String strUid) &#123; this.strUid = strUid; &#125; public String getStrUuid() &#123; return strUuid; &#125; public void setStrUuid(String strUuid) &#123; this.strUuid = strUuid; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel out, int flags) &#123; out.writeString(strUid); out.writeString(strUuid); &#125;&#125; 其实readFromParcel方法的实现和构造函数中的内容是一样的。这样我们再次编译运行，发现没有任何问题了。 五、接着我又把第三步中的inout修改成了in发现并没有报找不到readFromParcel方法的错误。 参考文章： http://blog.csdn.net/jackyu613/article/details/6011606 http://blog.csdn.net/flowingflying/article/details/22276821 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"RecyclerView Preview","slug":"2015-08-11-AndroidRecyclerViewPre","date":"2015-08-11T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/08/12/2015-08-11-AndroidRecyclerViewPre/","link":"","permalink":"http://ai.wisim.me/2015/08/12/2015-08-11-AndroidRecyclerViewPre/","excerpt":"RecyclerView的配置与基本使用1.添加依赖 12345dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:22.2.0&apos; compile &apos;com.android.support:recyclerview-v7:21.0.+&apos;&#125;","text":"RecyclerView的配置与基本使用1.添加依赖 12345dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:22.2.0&apos; compile &apos;com.android.support:recyclerview-v7:21.0.+&apos;&#125; 2.定义每个item的布局 1234567891011121314151617181920&lt;? xml version=\"1.0\" encoding= \"utf-8\"?&gt;&lt;LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns: tools=\"http://schemas.android.com/tools\" android :layout_width=\"match_parent\" android :layout_height=\"48dp\" android :background=\"#ffff7299\" android :gravity=\"center_vertical\" android :orientation=\"vertical\" android :padding=\"6dp\" tools :context=\".MyActivity\"&gt; &lt;TextView android :id=\"@+id/id_item_name\" android :layout_width=\"wrap_content\" android :layout_height=\"match_parent\" android :background=\"#303339\" android :padding=\"6dp\" android :text=\"Horizontal\" android :textSize=\"18sp\" /&gt;&lt;/LinearLayout&gt; 3.定义一个MyApapter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MainAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;MainAdapter.MainViewHolder&gt; &#123; private List&lt;T&gt; mData = null; public MainAdapter(List&lt; T&gt; data) &#123; mData = data; &#125; @Override public MainViewHolder onCreateViewHolder(ViewGroup parent , int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout. main_recydemo_item , null); MainViewHolder mainViewHolder = new MainViewHolder(view); return mainViewHolder ; &#125; @Override public void onBindViewHolder(MainViewHolder holder, final int position) &#123; holder.mDemoNameTv .setText(mData.get(position).toString()) ; holder. mDemoNameTv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mOnRecyclerItemClickListener.onClick(v, mData.get(position )); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return mData.size(); &#125; public static class MainViewHolder extends RecyclerView.ViewHolder &#123; public TextView mDemoNameTv; public MainViewHolder(View itemView) &#123; super (itemView); mDemoNameTv = (TextView) itemView.findViewById(R.id. id_item_name); &#125; &#125; private OnRecyclerItemClickListener&lt; T&gt; mOnRecyclerItemClickListener = null; public void setOnRecyclerItemClickListener (OnRecyclerItemClickListener listener) &#123; this .mOnRecyclerItemClickListener = listener; &#125; public interface OnRecyclerItemClickListener&lt; T&gt; &#123; void onClick(View view , T item); &#125;&#125; 4.在Activity中使用 123456789101112131415161718192021RecyclerView recyclerView = (RecyclerView) findViewById(R.id. id_main_recy);// 创建一个线性布局管理器LinearLayoutManager layoutManager = new LinearLayoutManager(this );layoutManager.setOrientation(LinearLayoutManager. HORIZONTAL);// 设置布局管理器recyclerView.setLayoutManager(layoutManager) ;List&lt;String&gt; data = new ArrayList&lt;&gt;();for (String it : mRecyDemos) &#123; data.add(it);&#125;MainAdapter&lt;String&gt; mainAdapter = new MainAdapter&lt;&gt;(data) ;// 设置AdapterrecyclerView.setAdapter(mainAdapter) ;mainAdapter.setOnRecyclerItemClickListener( new MainAdapter.OnRecyclerItemClickListener&lt;String&gt;() &#123; @Override public void onClick(View view, String item) &#123; Toast.makeText(MainActivity. this,\"Click : \"+item ,Toast.LENGTH_SHORT).show() ; &#125;&#125;); 5.点击事件是通过定义一个回调接口来实现的 1234567private OnRecyclerItemClickListener&lt; T &gt; mOnRecyclerItemClickListener = null;public void setOnRecyclerItemClickListener (OnRecyclerItemClickListener listener) &#123; this . mOnRecyclerItemClickListener = listener;&#125;public interface OnRecyclerItemClickListener&lt; T &gt; &#123; void onClick (View view , T item);&#125; THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Java使用wait()以及notifyAll()实现生产者消费者模型","slug":"2015-08-10-JavaThreadProducerConsumer","date":"2015-08-09T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/08/10/2015-08-10-JavaThreadProducerConsumer/","link":"","permalink":"http://ai.wisim.me/2015/08/10/2015-08-10-JavaThreadProducerConsumer/","excerpt":"之前已经简单介绍过wait()以及notifyAll()的使用，下面通过它们来实现进程间通信，从而解决生产者消费者问题。","text":"之前已经简单介绍过wait()以及notifyAll()的使用，下面通过它们来实现进程间通信，从而解决生产者消费者问题。 一、首先定义一个生产者线程生产者负责生产商品，每次生产一个商品之后都会通知消费者可以来取商品了，如果保存商品的队列满了则停止生产，等待消费者来取走商品。 123456789101112131415161718192021222324252627282930313233343536373839404142class MyProducer&lt;T&gt; extends Thread &#123; private Queue&lt;T&gt; mQueue; private int MAX = 0; private String mName = null; private T mGoods = null; public MyProducer(Queue&lt;T&gt; queue, int max,String name) &#123; super(name); this.mQueue = queue; this.MAX = max; this.mName = name; &#125; public void setGoods(T goods) &#123; this.mGoods = goods; &#125; public void run() &#123; while(true) &#123; synchronized(mQueue) &#123; while(mQueue.size() == MAX) &#123; try &#123; mQueue.wait(); &#125; catch (Exception e) &#123; &#125; &#125; int time = (int)System.currentTimeMillis(); System.out.println(time+ \" | \"+mName+\" --&gt; queue.size() : \" + mQueue.size() + \" | Add : \"+mGoods); mQueue.add(mGoods); try &#123; sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; mQueue.notify(); &#125; &#125; &#125;&#125; run()方法中使用一个while(true)循环让生产者一直运行。如果队列满了则执行mQueue.wait();，否则执行mQueue.add(mGoods);。 二、接着定义一个消费者线程消费者负责消费商品，每次消费一个商品之后都会通知生产者，如果保存商品的队列空了，则等待生产者生产商品。 12345678910111213141516171819202122232425262728293031323334class MyConsumer &lt;T&gt; extends Thread &#123; private Queue&lt;T&gt; mQueue; private int MAX = 0; private String mName = null; public MyConsumer(Queue&lt;T&gt; queue , int max,String name) &#123; super(name); this.mQueue = queue; this.MAX = max; this.mName = name; &#125; public void run() &#123; while(true) &#123; synchronized(mQueue) &#123; if(mQueue.isEmpty()) &#123; try &#123; mQueue.wait(); &#125; catch (Exception e) &#123; &#125; &#125; int time = (int)System.currentTimeMillis(); System.out.println(time+\" | \"+mName+\" --&gt; queue.size() : \" + mQueue.size()+\" | mQueue.remove() : \"+mQueue.remove()); try &#123; sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; mQueue.notify(); &#125; &#125; &#125;&#125; run()方法中使用一个while(true)循环让消费者一直运行。如果队列空了则执行mQueue.wait();，否则执行mQueue.remove();。 三、最后来测试一下1234567891011121314151617import java.util.Queue;import java.util.LinkedList;public class MyProducerConsumer &#123; public static void main(String[] args) &#123; int max = 20; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); MyProducer&lt;String&gt; p = new MyProducer&lt;String&gt;(queue,max,\"Producer\"); p.setGoods(\"hello world\"); MyConsumer&lt;String&gt; c1 = new MyConsumer&lt;String&gt;(queue,max,\"Consumer1\"); //MyConsumer&lt;String&gt; c2 = new MyConsumer&lt;String&gt;(queue,max,\"Consumer2\"); p.start(); c1.start(); //c2.start(); &#125;&#125; 每次都向商品队列中添加”hello world”字符串。也可以同时启动两个消费者线程。 看一下运行结果 12345678910111213141516171819202122232425262728293031323334353637$ java MyProducerConsumer397223348 | Producer --&gt; queue.size() : 0 | Add : hello world397223448 | Producer --&gt; queue.size() : 1 | Add : hello world397223548 | Producer --&gt; queue.size() : 2 | Add : hello world397223648 | Producer --&gt; queue.size() : 3 | Add : hello world397223748 | Producer --&gt; queue.size() : 4 | Add : hello world397223848 | Producer --&gt; queue.size() : 5 | Add : hello world397223948 | Consumer1 --&gt; queue.size() : 6 | mQueue.remove() : hello world397224048 | Producer --&gt; queue.size() : 5 | Add : hello world397224148 | Producer --&gt; queue.size() : 6 | Add : hello world397224248 | Producer --&gt; queue.size() : 7 | Add : hello world397224348 | Producer --&gt; queue.size() : 8 | Add : hello world397224448 | Producer --&gt; queue.size() : 9 | Add : hello world397224548 | Producer --&gt; queue.size() : 10 | Add : hello world397224648 | Producer --&gt; queue.size() : 11 | Add : hello world397224748 | Producer --&gt; queue.size() : 12 | Add : hello world397224848 | Producer --&gt; queue.size() : 13 | Add : hello world397224948 | Producer --&gt; queue.size() : 14 | Add : hello world397225048 | Producer --&gt; queue.size() : 15 | Add : hello world397225148 | Producer --&gt; queue.size() : 16 | Add : hello world397225248 | Producer --&gt; queue.size() : 17 | Add : hello world397225348 | Producer --&gt; queue.size() : 18 | Add : hello world397225448 | Producer --&gt; queue.size() : 19 | Add : hello world397225548 | Consumer1 --&gt; queue.size() : 20 | mQueue.remove() : hello world397225648 | Consumer1 --&gt; queue.size() : 19 | mQueue.remove() : hello world397225748 | Consumer1 --&gt; queue.size() : 18 | mQueue.remove() : hello world397225848 | Consumer1 --&gt; queue.size() : 17 | mQueue.remove() : hello world397225948 | Consumer1 --&gt; queue.size() : 16 | mQueue.remove() : hello world397226048 | Producer --&gt; queue.size() : 15 | Add : hello world397226148 | Producer --&gt; queue.size() : 16 | Add : hello world397226248 | Producer --&gt; queue.size() : 17 | Add : hello world397226348 | Producer --&gt; queue.size() : 18 | Add : hello world397226448 | Producer --&gt; queue.size() : 19 | Add : hello world397226548 | Consumer1 --&gt; queue.size() : 20 | mQueue.remove() : hello world397226648 | Consumer1 --&gt; queue.size() : 19 | mQueue.remove() : hello world397226748 | Consumer1 --&gt; queue.size() : 18 | mQueue.remove() : hello world...... THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[{"name":"MultiThread","slug":"MultiThread","permalink":"http://ai.wisim.me/tags/MultiThread/"}]},{"title":"ReactNative中的布局样式","slug":"2015-08-10-ReactNativeCSS","date":"2015-08-09T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/08/10/2015-08-10-ReactNativeCSS/","link":"","permalink":"http://ai.wisim.me/2015/08/10/2015-08-10-ReactNativeCSS/","excerpt":"一、布局样式的声明与使用有如下几种方式 首先用StyleSheet.create的方法来声明styles样式，然后引用styles对象即可。例如： 12345678910//声明样式var styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, &#125;,&#125;);//使用样式&lt;View style=&#123;styles.container&#125; /&gt;","text":"一、布局样式的声明与使用有如下几种方式 首先用StyleSheet.create的方法来声明styles样式，然后引用styles对象即可。例如： 12345678910//声明样式var styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, &#125;,&#125;);//使用样式&lt;View style=&#123;styles.container&#125; /&gt; 也可以通过数组形式引用。例如： 123456789101112131415161718//声明样式var styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, &#125;, tvcontainer: &#123; margin: 2, width: 50, padding: 10, backgroundColor: &apos;#303339&apos;, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, &#125;,&#125;);//使用样式&lt;View style=&#123;[styles.container,styles.tvcontainer]&#125; /&gt; 或者可以在style属性中直接使用CSS样式。例如： 1&lt;View style=&#123;[styles.container,&#123;marginTop: 80&#125;]&#125; /&gt; 二、实现宽高的百分比设置ReactNative的布局样式并不支持百分比，但是可以通过别的方式来实现同样的效果。 首先我们要引入Dimensions模块 1var Dimensions = require(&apos;Dimensions&apos;); 然后通过Dimensions.get(‘window’)来获取设备的宽高，这里我们将一个View的宽高分别设置为设备宽高的1/2，来看看效果 123456789101112class DimensionsView extends Component &#123; render() &#123; var &#123;width,height&#125; = Dimensions.get(&apos;window&apos;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.description&#125;&gt;window.width = &#123;width&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.description&#125;&gt;window.height = &#123;height&#125;&lt;/Text&gt; &lt;View style=&#123;[styles.tvcontainer,&#123;width: width/2 ,height: height/2&#125;]&#125;&gt;&lt;Text style=&#123;styles.content&#125;&gt;Item&lt;/Text&gt;&lt;/View&gt; &lt;/View&gt; ); &#125;&#125;; 三、关于绝对定位和相对定位position属性有两个可选值：’absolute’和’relative’。absolute表示绝对定位，relative表示相对定位。来看一下具体的实例： 这里我们在每个容器里面左上角都有一个50*50的方形，然后还有一个红色圆形。 首先看一下两个小球在设置position属性之前的布局。两个球和方形的位置都是这样的 接着第一个圆形使用绝对定位，第二个圆形使用相对定位。每个圆形的left都设为70，top设为20。 1234&lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;[&#123;width: 200 ,height: 200,backgroundColor: &apos;#6a6a6a&apos;,marginBottom:10&#125;]&#125;&gt;&lt;View style=&#123;[&#123;width: 50 ,height: 50,backgroundColor: &apos;#a6a6a6&apos;&#125;]&#125; /&gt;&lt;View style=&#123;[styles.circle,&#123;position:&apos;absolute&apos;,left:70,top:20&#125;]&#125;&gt;&lt;/View&gt;&lt;/View&gt; &lt;View style=&#123;[&#123;width: 200 ,height: 200,backgroundColor: &apos;#a6a6a6&apos;&#125;]&#125;&gt;&lt;View style=&#123;[&#123;width: 50 ,height: 50,backgroundColor: &apos;#6a6a6a&apos;&#125;]&#125; /&gt;&lt;View style=&#123;[styles.circle,&#123;position:&apos;relative&apos;,left:70,top:20&#125;]&#125;&gt;&lt;/View&gt;&lt;/View&gt;&lt;/View&gt; 可以看到使用绝对定位时，圆形的位置与方形的位置无关。而使用相对定位时圆形的top位置是相对于方形的。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://ai.wisim.me/tags/ReactNative/"}]},{"title":"ReactNative之Flexbox布局","slug":"2015-08-01-ReactNativeFlex","date":"2015-07-31T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/08/01/2015-08-01-ReactNativeFlex/","link":"","permalink":"http://ai.wisim.me/2015/08/01/2015-08-01-ReactNativeFlex/","excerpt":"Flexbox是CSS3中引入的布局模型－弹性盒子模型，旨在通过弹性的方式来对齐和分布容器中内容的空间，使其能够适应不同屏幕的宽度。 Flexbox并不是作为一个单一的属性，而是作为一系列属性的集合。ReactNative中的Flexbox是这个规范的一个子集。","text":"Flexbox是CSS3中引入的布局模型－弹性盒子模型，旨在通过弹性的方式来对齐和分布容器中内容的空间，使其能够适应不同屏幕的宽度。 Flexbox并不是作为一个单一的属性，而是作为一系列属性的集合。ReactNative中的Flexbox是这个规范的一个子集。 Flexbox属性对于Flexbox，会有一个Flex container作为容器，里面包含了一些了Flex元素Flex item。Flexbox中的有些属性是针对于Flex container，而另外有些属性是针对于Flex item的。 一、针对Flex container的属性 flexDirection:有两个可选值，’column’（默认值）和’row’。 row 表示主轴的方向是水平的。可以看一下两种不同的排列方式： flexWrap:有两个可选值，’nowrap’（默认值）和’wrap’。默认情况下，ReactNative中Flexbox会将所有元素排列在一行，如果想要元素达到容器边缘之后换行则要设置为wrap。看一下两种不同的包裹方式： 如果设置了 flexWrap 属性为’wrap’，要使其生效，需要设置容器的宽度为固定值 alignItems:有四个可选值，’flex-start’,’flex-end’,’center’和’stretch’。具体排列方式依次如图： 如果设置了 alignItems 属性为’stretch’，要使其生效就不能设置item的高度为固定值 justifyContent:有五个可选值，’flex-start’,’flex-end’,’center’,’space-between’和’space-around’。具体排列方式如图： 若要使的 justifyContent 属性生效，需要设置容器的宽度为固定值 值得注意的是alignItems属性是针对于纵轴方向上的排布，而justifyContent则是针对于横轴方向上的排布，同时将两个属性设置为’center’即可实现内容的水平垂直居中显示二、针对Flex item的属性 flex:表示flex元素在布局中所占的比重。我们这里先将第一个容器内五个元素的flex属性值依次设置为1，2，3，2，1。接着将第二个容器内的五个元素的flex属性值依次设置为2，2，2，2，2。来看一下最后的效果： alignSelf:有五个可选值，’auto’,’flex-start’,’flex-end’,’center’和’stretch’。用来控制单个flex元素在Flex container中的位置。我们来看一下他们各自的效果 值得注意的是justifyContent属性控制的是整个容器中的元素相对于容器本身的位置，alignSelf属性控制的是单个元素本身相对于它的父容器的位置。 通过使用Flexbox可以很方便的解决如下几个问题： 浮动布局 不同宽度屏幕的适配 宽度自动分配 水平垂直居中 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://ai.wisim.me/tags/ReactNative/"}]},{"title":"ReactNative中常用的基本控件","slug":"2015-07-29-ReactNativeBaseWidget","date":"2015-07-28T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/07/29/2015-07-29-ReactNativeBaseWidget/","link":"","permalink":"http://ai.wisim.me/2015/07/29/2015-07-29-ReactNativeBaseWidget/","excerpt":"React Native 极客学院中文文档 ： http://wiki.jikexueyuan.com/project/react-native/tutorial.html 最常用的几种控件如下： 文本 ： Text （类似于Android中的 TextView ） 图像 ： Image （类似于Android中的 ImageView ） 文本输入 ： TextInput （类似于Android中的 EditText ） 高亮触摸 ： TouchableHighlight （类似于Android中的 Button ）","text":"React Native 极客学院中文文档 ： http://wiki.jikexueyuan.com/project/react-native/tutorial.html 最常用的几种控件如下： 文本 ： Text （类似于Android中的 TextView ） 图像 ： Image （类似于Android中的 ImageView ） 文本输入 ： TextInput （类似于Android中的 EditText ） 高亮触摸 ： TouchableHighlight （类似于Android中的 Button ） 一、文本 ： 二、图像 ： 三、文本输入 ： 四、高亮触摸 ： style创建方式使用 StyleSheet.create创建样式表 style属性来引用样式 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://ai.wisim.me/tags/ReactNative/"}]},{"title":"使用MAT工具定位Android应用内存泄漏","slug":"2015-07-29-AndroidMAT","date":"2015-07-28T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/07/29/2015-07-29-AndroidMAT/","link":"","permalink":"http://ai.wisim.me/2015/07/29/2015-07-29-AndroidMAT/","excerpt":"MAT工具下载地址：https://www.eclipse.org/mat/downloads.php Android发生内存泄漏最普遍的一种情况就是长期持有对Context（特别是Activity）的引用，导致Context无法被销毁。这也就意味着该Context中的所有成员变量都没有办法销毁。主要有如下两种情况会是得Activity无法被销毁： 1.某个static变量保持对Activity的引用 2.线程保持对Activity的引用","text":"MAT工具下载地址：https://www.eclipse.org/mat/downloads.php Android发生内存泄漏最普遍的一种情况就是长期持有对Context（特别是Activity）的引用，导致Context无法被销毁。这也就意味着该Context中的所有成员变量都没有办法销毁。主要有如下两种情况会是得Activity无法被销毁： 1.某个static变量保持对Activity的引用 2.线程保持对Activity的引用 使用MAT分析内存查找内存泄漏的根本思路，就是找到哪个类的对象的引用没有被释放，找到没有被释放的原因，也就可以很容易定位代码中的哪些片段的逻辑有问题了 1.先来写一段会导致内存泄漏的代码，测试代码如下123456789101112131415161718192021222324public class HeapTestActivity extends Activity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.testuploadfile); findViewById(R.id.testupload).setOnClickListener(this); &#125; public void onClick(View v)&#123; new MyThread().start(); &#125; class MyThread extends Thread&#123; public void run()&#123; try &#123; Log.e(\"wxp\", \"wxp-HeapTest-run\"); Thread.sleep(60000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 程序截图： 点击testupload会启动一个新的线程，所以此时如果旋转屏幕的话，并没有做任何销毁操作，由于MyThread线程未被销毁，所以会一直持有原先的Activity。多次旋转屏幕并点击testupload就会导致内存泄漏。 下面来具体操作一下如何定位内存泄漏 2.打开DDMS选中你要调适的应用，点击 Update Heap 按钮，再点击右边 Heap 栏下的 Cause GC 按钮，即可查看当前应用的堆情况 接着点击 Update Threads 按钮，再点击啊右边的 Threads 栏，即可看到当前应用的Thread运行情况 3.导出hprof文件接下来就要对应用进行一系列操作了，点击按钮，旋转屏幕，点击按钮，旋转屏幕。。。重复操作多次之后。点击 Dump HPROF file 按钮，另存为 myheap.sample.hprof 由于我使用的是独立的MAT工具，所以这里要转换一下文件，才能被MAT读取。Android已经自带了转换的工具，前提是配置了环境变量，在终端执行如下命令： 1hprof-conv ~/Desktop/HEAP/myheap.sample.hprof ~/Desktop/HEAP/mymemoryleak.hprof 4.分析mymemoryleak.hprof文件，定位内存泄漏(1) 在MAT工具中打开刚刚转化之后的文件 mymemoryleak.hprof (2) 点击 Actions 中的 Histogram,出现如下界面，这里就是按类名把所有的实例对象组织起来 在第一行的 Class Name 输入框中输入你要定位的类名。我这里就是刚刚新建的 HeapTestActivity,直接输入 Heap,即可自动进行正则匹配，可以看到第一个类就是 HeapTestActivity： (3) 右击HeapTestActivity，选择 List objects-&gt;with incoming references (4) 接着就列出来该类的所有实例，展开某一个实例之后就可以显示对象间的引用关系。 如果想要快速找到某个实例没有被释放的原因，可以右击一个实例，选择 Path To GC Roots-&gt;exclude all phantom/weak/soft etc. references (5) 沿着这个路线就可以找到仍旧引用着这个实例的对象，比如我们这里是一个Thread,也就是上面的一个MyThread对象 用这个方法可以快速找到某个对象的 GC Root,一个存在 GC Root的对象是不会被 GC回收掉的. 附： Square推出的一款内存泄漏检测工具 LeakCanary 也很方便的就可以定位到内存泄漏 1.首先在build.gradle中添加依赖 123456dependencies &#123; ...... debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.3&apos; releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.3&apos; ...... &#125; 2.在Application中注册一下就可以了 1234567public class LeakCanaryApplication extends Application &#123;@Override public void onCreate() &#123; super.onCreate(); LeakCanary.install(this); &#125;&#125; 3.编译安装应用之后，随着应用会在桌面出现另一个图标 4.当前应用发生内存泄漏之后，Leaks会在通知栏提醒，点击查看详情就会看到一步一步的引用流程 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"ReactNative初探","slug":"2015-07-26-ReactNativePreview","date":"2015-07-25T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/07/26/2015-07-26-ReactNativePreview/","link":"","permalink":"http://ai.wisim.me/2015/07/26/2015-07-26-ReactNativePreview/","excerpt":"ReactNative 计划在10月份以后就会支持Android了，它的宗旨是 Learn once, write anywhere，趁着周末来折腾一下。 ReactNative官方文档 ： http://facebook.github.io/react-native/","text":"ReactNative 计划在10月份以后就会支持Android了，它的宗旨是 Learn once, write anywhere，趁着周末来折腾一下。 ReactNative官方文档 ： http://facebook.github.io/react-native/ 一、环境搭建1.首先安装 Homebrew,Homebrew时mac下的一个包管理应用，可以通过它来安装其他所需的软件 1ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 接着通过brew -v这个命令来检查是否已经安装成功 2.安装node，安装node的同时也会安装npm 1brew install node 3.安装watchman，watchman是用来检测文件变化的工具 1brew install watchman 4.安装flow，flow是用来检测jsx语法的工具 1brew install flow 5.接着通过npm安装react-native的命令行工具， －g表示安装到全局模式，这个安装过程我等了好久都没更新，最后还是翻墙之后才安装完成 1npm install -g react-native-cli 二、初始化一个ReactNative项目之前已经安装好react-native的命令行工具，所以直接在终端执行如下命令，即可创建一个新的Xcode工程 1react-native init HelloReactNative 完成之后看一下这个工程的目录结构 三、双击HelloReactNative.xcodeproj在Xcode中打开项目接着就可以在模拟器中直接运行这个应用了。 四、打开项目根目录下的index.ios.js文件，这个文件就是用来显示我们上面看到的那个界面，看一下里面的代码1.下面这行代码是用于开启 Strict Mode 1&apos;use strict&apos;; 2.下面这行代码是将 react-native 模块加载进来，并将它赋值给变量 React 的 React Native 使用同 Node.js 相同的模块加载方式：require，这个概念可以等同于 java 中的 import 的概念。 1var React = require(&apos;react-native&apos;); 3.批量定义组件 123456var &#123; AppRegistry, StyleSheet, Text, View,&#125; = React; 这几行代码等同于: 1234var AppRegistry = React.AppRegistry;var StyleSheet = React.StyleSheet;var Text = React.Text;var View = React.View; 4.定义视图的内容： 123456789101112131415161718var HelloReactNative = React.createClass(&#123; render: function() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; To get started, edit index.ios.js &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; Press Cmd+R to reload,&#123;&apos;\\n&apos;&#125; Cmd+D or shake for dev menu &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;); 上面这段代码用语构建HelloReactNative的入口类，React提供了React.createClass的方法创建一个类。里面的render方法就是渲染视图用的。return返回的是视图的模板代码。其实上面这是JSX的模板语法。 5.除了上面提供的视图内容，还需要视图的样式。StyleSheet.create就是通过JS的自面量表达了css样式。 123456789101112131415161718var styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;#F5FCFF&apos;, &#125;, welcome: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;, instructions: &#123; textAlign: &apos;center&apos;, color: &apos;#333333&apos;, marginBottom: 5, &#125;,&#125;); 那么如何引入css样式呢，可以看到在上面视图内容的代码中，render方法返回的视图模板里已经体现出来了即style={styles.container}.其中style是视图的一个属性，styles是我们定义的样式表，container是样式表中的一个样式。 6.最后，注册应用入口 1AppRegistry.registerComponent(&apos;HelloReactNative&apos;, () =&gt; HelloReactNative); 五、有几个文件是需要注意下的1.在xcode项目代码中AppDelegate.m会标识入口文件，例如： 1jsCodeLocation = [NSURL URLWithString:@&quot;http://localhost:8081/index.ios.bundle&quot;]; 如果是网上下载别人的源码，注意此处的ip和端口是否有被修改。 2.闪屏界面在哪修改？在xcode项目中找到LaunchScreen.xib文件，点击，你会看到界面，这个就是启动界面，手动添加组件或者修改文本即可。 3.文本编辑器打开index.ios.js文件，是js代码的入口文件，所有的代码编写从这开始，可以定义自己的模块和引入第三方模块。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://ai.wisim.me/tags/ReactNative/"}]},{"title":"Java线程中wait()方法以及notify()方法的使用","slug":"2015-07-13-JavaThreadWaitNotify","date":"2015-07-13T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/07/14/2015-07-13-JavaThreadWaitNotify/","link":"","permalink":"http://ai.wisim.me/2015/07/14/2015-07-13-JavaThreadWaitNotify/","excerpt":"wait()以及notify()是Object的两个方法。Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作。 从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。 从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。 相应的notify()就是对对象锁的唤醒操作。 有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。","text":"wait()以及notify()是Object的两个方法。Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作。 从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。 从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。 相应的notify()就是对对象锁的唤醒操作。 有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。 来看一个简单的例子，i线程打印到2之后等待，切换到J线程打印，J线程打印完成之后再通知i线程继续打印。1234567891011121314151617181920212223242526272829303132333435363738394041public class MyNotify &#123; public static void main(String[] args) &#123; MyThread mt1 = new MyThread(); mt1.start(); MyNotifyThread mt2 = new MyNotifyThread(); mt2.start(); &#125; public static Object o = new Object(); static class MyThread extends Thread &#123; public void run() &#123; synchronized(o) &#123; for(int i = 0;i&lt;4;i++) &#123; System.out.println(\"i = \"+i); if(i == 2) &#123; System.out.println(currentThread().getName()+\".wait()\"); try &#123; o.wait(); &#125; catch(Exception e) &#123; &#125; &#125; &#125; &#125; &#125; &#125; static class MyNotifyThread extends Thread &#123; public void run() &#123; synchronized(o) &#123; for(int J = 0;J&lt;6;J++) &#123; System.out.println(\"J = \"+J); if(J == 3) &#123; System.out.println(currentThread().getName()+\".notify()\"); o.notify(); &#125; &#125; &#125; &#125; &#125;&#125; 运行之后的结果： 123456789101112i = 0i = 1i = 2Thread-0.wait()J = 0J = 1J = 2J = 3Thread-1.notify()J = 4J = 5i = 3 可以看到i线程（也就是 Thread-0）打印到2之后便暂停打印，接着J线程（也就是Thread-1）开始打印，当J为3的时候，J进程调用了notify()方法，此时J线程会继续打印知道完成，最终结束之后i线程才又开始打印。也印证了开头所述的：notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束。 再来看一个三线程顺序打印ABC的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyPrintABC &#123; public static void main(String[] args) &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); PrintThread PA = new PrintThread(\"A\",a,c); PrintThread PB = new PrintThread(\"B\",b,a); PrintThread PC = new PrintThread(\"C\",c,b); PA.start(); try &#123; PA.sleep(1); &#125; catch(Exception e) &#123;&#125; PB.start(); try &#123; PB.sleep(1); &#125; catch(Exception e) &#123;&#125; PC.start(); try &#123; PC.sleep(1); &#125; catch(Exception e) &#123;&#125; &#125; static class PrintThread extends Thread &#123; private String mName = null; private Object mSelf = null; private Object mPre = null; public PrintThread(String name,Object self,Object pre) &#123; this.mName = name; this.mSelf = self; this.mPre = pre; &#125; public void run() &#123; int i = 0; while(i &lt; 10) &#123; try &#123; synchronized(mPre) &#123; synchronized(mSelf) &#123; System.out.println(currentThread().getName()+\"--&gt;\"+mName); i++; mSelf.notify(); &#125; mPre.wait(); &#125; &#125; catch(Exception e) &#123;&#125; &#125; &#125; &#125;&#125; 这里一个PrintThread有两个对象锁mSelf和mPre。为了保证打印顺序，一个进程首先要获取mPre对象锁，也就是要等待前一个进程打印完成，释放它对应的自身对象锁。接着再去获取当前线程自己的mSelf对象锁，同时获取之后，再打印当前进程的名（这里用mName属性表示）。打印完成之后，调用mSelf.notify()释放自身对象锁，唤醒下一个等待进程。接着调用mPre.wait()释放mPre对象锁，终止当前线程，等待再次被唤醒。 最终打印出来的效果就是： 123456789101112131415161718192021222324252627282930Thread-0--&gt;AThread-1--&gt;BThread-2--&gt;CThread-0--&gt;AThread-1--&gt;BThread-2--&gt;CThread-0--&gt;AThread-1--&gt;BThread-2--&gt;CThread-0--&gt;AThread-1--&gt;BThread-2--&gt;CThread-0--&gt;AThread-1--&gt;BThread-2--&gt;CThread-0--&gt;AThread-1--&gt;BThread-2--&gt;CThread-0--&gt;AThread-1--&gt;BThread-2--&gt;CThread-0--&gt;AThread-1--&gt;BThread-2--&gt;CThread-0--&gt;AThread-1--&gt;BThread-2--&gt;CThread-0--&gt;AThread-1--&gt;BThread-2--&gt;C THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[{"name":"MultiThread","slug":"MultiThread","permalink":"http://ai.wisim.me/tags/MultiThread/"}]},{"title":"Java线程中yield()方法的使用","slug":"2015-06-24-JavaThreadYield","date":"2015-06-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/06/24/2015-06-24-JavaThreadYield/","link":"","permalink":"http://ai.wisim.me/2015/06/24/2015-06-24-JavaThreadYield/","excerpt":"yield()方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。注意：这里的其他也包含当前线程。","text":"yield()方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。注意：这里的其他也包含当前线程。 1.首先继承Thread实现一个子类YieldTest，在它的run方法中执行yield()方法。12345678910111213class YieldTest extends Thread &#123; public void run() &#123; Thread.currentThread().setPriority(Thread.MIN_PRIORITY); System.out.println(\"YieldTest-run-begin\"); System.out.println(\"YieldTest-1\"); YieldAndSleep.calculate(); yield(); System.out.println(\"YieldTest-2\"); YieldAndSleep.calculate(); System.out.println(\"YieldTest-run-end\"); &#125;&#125; 2.然后继承Thread实现一个子类SleepTest，在它的run方法中执行sleep方法，用来对比yield方法。123456789101112131415class SleepTest extends Thread &#123; public void run() &#123; Thread.currentThread().setPriority(Thread.MAX_PRIORITY); System.out.println(\"SleepTest-run-begin\"); System.out.println(\"SleepTest-1\"); YieldAndSleep.calculate(); try&#123; sleep(1000); &#125; catch (Exception e) &#123;&#125; System.out.println(\"SleepTest-2\"); YieldAndSleep.calculate(); System.out.println(\"SleepTest-run-end\"); &#125; &#125; 3.最后分别启动两个YieldTest线程和两个SleepTest线程，观察它们的运行状况123456789101112131415161718192021public class YieldAndSleep &#123; public static void calculate() &#123; for (int i = 0;i&lt;100000000;i++) &#123; int j = i*i; &#125; &#125; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 2; i++) &#123; System.out.println(\"YieldTest().start()-begin\"); new YieldTest().start(); System.out.println(\"YieldTest().start()-end\"); &#125; for (int i = 1; i &lt;= 2; i++) &#123; System.out.println(\"SleepTest().start()-begin\"); new SleepTest().start(); System.out.println(\"SleepTest().start()-end\"); &#125; &#125; &#125; 4.看一下运行的结果123456789101112131415161718192021222324YieldTest().start()-beginYieldTest().start()-endYieldTest().start()-beginYieldTest-run-beginYieldTest-1YieldTest().start()-endSleepTest().start()-beginYieldTest-run-beginYieldTest-1SleepTest().start()-endSleepTest().start()-beginSleepTest().start()-endSleepTest-run-beginSleepTest-1 SleepTest-run-beginSleepTest-1YieldTest-2YieldTest-run-endYieldTest-2YieldTest-run-endSleepTest-2SleepTest-run-endSleepTest-2SleepTest-run-end 每次的运行结果可能都不太一样，就拿这次的来分析一下。可以看到第14行输出SleepTest-1,它是在YieldTest-1之后打印出来的，就是因为在System.out.println(&quot;YieldTest-1&quot;);之后执行了yield();方法，所以从YieldTest线程转换到了SleepTest线程。当然也有可能还是转换到YieldTest自己这个线程。 THE END.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[{"name":"MultiThread","slug":"MultiThread","permalink":"http://ai.wisim.me/tags/MultiThread/"}]},{"title":"使用Volley获取fir.im服务器端应用的最新版本","slug":"2015-06-01-AndroidVolleyUpdateInfo","date":"2015-05-31T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/06/01/2015-06-01-AndroidVolleyUpdateInfo/","link":"","permalink":"http://ai.wisim.me/2015/06/01/2015-06-01-AndroidVolleyUpdateInfo/","excerpt":"儿童节快乐。 一、首先将应用发布到fir.im上。可以得到他的APP ID，我这里的APP ID为556c487d210234f16a000350在浏览器中输入http://fir.im/api/v2/app/version/556c487d210234f16a000350,可以看到输出的应用信息 1&#123;&quot;name&quot;:&quot;Timo&quot;,&quot;version&quot;:&quot;1&quot;,&quot;changelog&quot;:&quot;beta0.1&quot;,&quot;versionShort&quot;:&quot;1.0&quot;,&quot;installUrl&quot;:&quot;http://fir.im/api/v2/app/install/556c487d210234f16a000350?token=f3b596a0085311e595c0e761ac19d16b4db1b3ff&quot;,&quot;update_url&quot;:&quot;http://fir.im/timo&quot;&#125; 二、在Android Studio中使用GsonFormat自动生成上面json字符串的实体类 GsonFormay的主页： https://github.com/zzz40500/GsonFormat","text":"儿童节快乐。 一、首先将应用发布到fir.im上。可以得到他的APP ID，我这里的APP ID为556c487d210234f16a000350在浏览器中输入http://fir.im/api/v2/app/version/556c487d210234f16a000350,可以看到输出的应用信息 1&#123;&quot;name&quot;:&quot;Timo&quot;,&quot;version&quot;:&quot;1&quot;,&quot;changelog&quot;:&quot;beta0.1&quot;,&quot;versionShort&quot;:&quot;1.0&quot;,&quot;installUrl&quot;:&quot;http://fir.im/api/v2/app/install/556c487d210234f16a000350?token=f3b596a0085311e595c0e761ac19d16b4db1b3ff&quot;,&quot;update_url&quot;:&quot;http://fir.im/timo&quot;&#125; 二、在Android Studio中使用GsonFormat自动生成上面json字符串的实体类 GsonFormay的主页： https://github.com/zzz40500/GsonFormat 最终生成的实体类UpdateInfo如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class UpdateInfo &#123; /** * installUrl : http://fir.im/api/v2/app/install/556c487d210234f16a000350?token=f3b596a0085311e595c0e761ac19d16b4db1b3ff * update_url : http://fir.im/timo * name : Timo * changelog : beta0.1 * versionShort : 1.0 * version : 1 */ private String installUrl; private String update_url; private String name; private String changelog; private String versionShort; private String version; public void setInstallUrl(String installUrl) &#123; this.installUrl = installUrl; &#125; public void setUpdate_url(String update_url) &#123; this.update_url = update_url; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setChangelog(String changelog) &#123; this.changelog = changelog; &#125; public void setVersionShort(String versionShort) &#123; this.versionShort = versionShort; &#125; public void setVersion(String version) &#123; this.version = version; &#125; public String getInstallUrl() &#123; return installUrl; &#125; public String getUpdate_url() &#123; return update_url; &#125; public String getName() &#123; return name; &#125; public String getChangelog() &#123; return changelog; &#125; public String getVersionShort() &#123; return versionShort; &#125; public String getVersion() &#123; return version; &#125;&#125; 三、接着开始编写自定义的GsonRequest GsonRequest继承自Request类，并且同样提供了两个构造函数。 在parseNetworkResponse()方法中，先是将服务器响应的数据解析出来，然后通过调用Gson的fromJson方法将数据组装成对象。 在deliverResponse方法中将最终的数据进行回调。 1234567891011121314151617181920212223242526272829303132public class GsonRequest&lt;T&gt; extends Request&lt;T&gt; &#123; private final Response.Listener&lt;T&gt; mListener; private Gson mGson; private Class&lt;T&gt; mClass; public GsonRequest(int method, String url, Class&lt;T&gt; clazz, Response.Listener&lt;T&gt; listener,Response.ErrorListener errorListener) &#123; super(method, url, errorListener); mGson = new Gson(); mClass = clazz; mListener = listener; &#125; public GsonRequest(String url, Class&lt;T&gt; clazz, Response.Listener&lt;T&gt; listener,Response.ErrorListener errorListener) &#123; this(Method.GET, url, clazz, listener, errorListener); &#125; @Override protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response) &#123; try &#123; String jsonString = new String(response.data,HttpHeaderParser.parseCharset(response.headers)); return Response.success(mGson.fromJson(jsonString, mClass), HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; Log.e(\"wxpinfo\",\"parseNetworkResponse error : \"+error); return Response.error(new ParseError(e)); &#125; &#125; @Override protected void deliverResponse(T response) &#123; mListener.onResponse(response); &#125;&#125; 四、接着就可以使用GsonRequest了 首先要获取本地应用的版本： 12345678910111213public static String getLocalVersionName(Context context) &#123; String versionName = \"\"; try &#123; // 包名改为自己应用的包名即可 versionName = context.getPackageManager().getPackageInfo( \"timo.wxp.com.timoren\", 1).versionName; &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; Log.e(\"wxpinfo\", \"loaclversionName\" + versionName); return versionName;&#125; 接着定义一个volleyGetUpdateInfo方法获将服务器最新应用的版本和本地版本进行对比： 123456789101112131415161718192021222324public static void volleyGetUpdateInfo(final Context context) &#123; String APP_URL = \"http://fir.im/api/v2/app/version/556c487d210234f16a000350\"; RequestQueue mQueue = Volley.newRequestQueue(context); GsonRequest&lt;UpdateInfo&gt; gsonRequest = new GsonRequest&lt;UpdateInfo&gt;( APP_URL, UpdateInfo.class, new Response.Listener&lt;UpdateInfo&gt;() &#123; @Override public void onResponse(UpdateInfo updateInfo) &#123; if (Float.valueOf(getLocalVersionName(context)) &lt; Float.valueOf(updateInfo.versionShort) ) &#123; Toast.makeText(context,\"NEED UPDATE\",Toast.LENGTH_SHORT).show(); &#125; else if (Float.valueOf(getLocalVersionName(context)) &gt; Float.valueOf(updateInfo.versionShort) )&#123; Toast.makeText(context,\"本地大于服务器\",Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context,\"版本相同\",Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(\"wxpinfo\", \"error --&gt; \" + error.getMessage(), error); &#125; &#125;); mQueue.add(gsonRequest);&#125; 如果要判断本地应用和服务器最新应用的版本大小只要调用volleyGetUpdateInfo这个方法即可。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"ScrollView与ListView嵌套仿微博个人主页","slug":"2015-05-28-AndroidWeiboProfile","date":"2015-05-27T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/05/28/2015-05-28-AndroidWeiboProfile/","link":"","permalink":"http://ai.wisim.me/2015/05/28/2015-05-28-AndroidWeiboProfile/","excerpt":"前言之前写过一篇文章是关于浮动标签头的实现方式，但是内容只有一个ScrollView,里面并无ListView 下面要通过ScrollView与ListView嵌套来微博个人主页的效果，实现原理和上面这个还是一样的","text":"前言之前写过一篇文章是关于浮动标签头的实现方式，但是内容只有一个ScrollView,里面并无ListView 下面要通过ScrollView与ListView嵌套来微博个人主页的效果，实现原理和上面这个还是一样的 这是微博里的个人主页的效果图 可以看到顶部有一个head区域，包含头像和姓名之类的信息。中间是一条TabBar，点击不同的tab可以切换显示不同的内容。下面是不同Tab对应的内容。向上滑动时，当TabBar到达屏幕顶部之后便会固定在屏幕顶部，而下拉后则再次随者内容滑动。 代码实现一、继承ScrollView实现它一个子类ObservableScrollView由于Android原生的ScrollView并未提供滑动监听的接口，所以要为ObservableScrollView添加一个滑动监听接口，这样才能判断它的滑动距离。 123456789101112131415161718192021222324252627public class ObservableScrollView extends ScrollView &#123; public ObservableScrollView(Context context) &#123; super(context); &#125; public ObservableScrollView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public ObservableScrollView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; public interface OnScrollChangedListener &#123; public void onScrollChanged(int x, int y, int oldX, int oldY); &#125; private OnScrollChangedListener onScrollChangedListener; public void setOnScrollListener(OnScrollChangedListener onScrollChangedListener) &#123; this.onScrollChangedListener = onScrollChangedListener; &#125; @Override protected void onScrollChanged(int x, int y, int oldX, int oldY) &#123; super.onScrollChanged(x, y, oldX, oldY); if (onScrollChangedListener != null) &#123; onScrollChangedListener.onScrollChanged(x, y, oldX, oldY); &#125; &#125;&#125; 二、由于ListView嵌套在ScrollView中会导致显示内容不全，所以这里也实现一个自定义的ListView1234567891011121314151617181920212223242526/*** * 自定义ListView子类，继承ListView * @author Administrator * */public class FullyListView extends ListView &#123; public FullyListView(Context context) &#123; super(context); &#125; public FullyListView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public FullyListView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; @Override public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec); &#125;&#125; 三、接着在Activity中控制TabBar的隐藏与显示值得注意的是下面的300是Head区域的高度，也就是当ScrollView向上滑动超过300dp后，隐藏的TabBar便会显示，而ScrollView向上滑动不足300dp时则隐藏，这样就形成了一种滑动到顶部便固定的效果 123456789101112mScrollView.setOnScrollListener(new ObservableScrollView.OnScrollChangedListener() &#123; @Override public void onScrollChanged(int x, int y, int oldX, int oldY) &#123; Log.e(\"wxpsc\", \" x = \" +x+\" y = \" +y+\" oldX = \" +oldX+\" oldY = \" +oldY); if (y &gt;= dpToPx(300)) &#123; mTabTop.setVisibility(View.VISIBLE); &#125; else &#123; mTabTop.setVisibility(View.GONE); &#125; &#125;&#125;); 最后看一下这种方式实现的效果图： 实例源码：https://github.com/whisper92/WeiboProfile THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"动态规划-最大子数组和问题","slug":"2015-05-27-DynamicProgrammingMSS","date":"2015-05-26T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/05/27/2015-05-27-DynamicProgrammingMSS/","link":"","permalink":"http://ai.wisim.me/2015/05/27/2015-05-27-DynamicProgrammingMSS/","excerpt":"题目描述 有整型数组int a[]={1,-2,3,10,-4,7,2,-5}，求这个数组的最大子数组和","text":"题目描述 有整型数组int a[]={1,-2,3,10,-4,7,2,-5}，求这个数组的最大子数组和 分析来手写一下求取最大子数组和序列的过程，用M[i]表示第i个数所对应的最大子数组和 1234567891011121314151617181920212223S[0] = 1 ;M[0] = 1 ;S[1] = max&#123;S[0]+a[1],a[1]&#125; = -1 ;M[1] = max&#123;S[1],M[0]&#125; = 1 ; S[2] = max&#123;S[1]+a[2],a[2]&#125; = 3 ;M[2] = max&#123;S[2],M[1]&#125; = 3 ; S[3] = max&#123;S[2]+a[3],a[3]&#125; = 13 ;M[3] = max&#123;S[3],M[2]&#125; = 13 ; S[4] = max&#123;S[3]+a[4],a[4]&#125; = 9 ;M[4] = max&#123;S[4],M[3]&#125; = 13 ; S[5] = max&#123;S[4]+a[5],a[5]&#125; = 16 ;M[5] = max&#123;S[5],M[4]&#125; = 16 ; S[6] = max&#123;S[5]+a[6],a[6]&#125; = 18 ;M[6] = max&#123;S[6],M[5]&#125; = 18 ; S[7] = max&#123;S[6]+a[7],a[7]&#125; = 13 ;M[7] = max&#123;S[7],M[6]&#125; = 18 ; 我们求解的问题也就是求M[7]的值，M[i]就是这个问题的状态，可以得到状态转移方程为：M[i] = max{max{S[i-1]+a[i],a[i]},M[i-1]}。其中M[i]表示当前位置i之前所有数的最大子数组和，S[i]则用于保存最大子数组的起始位置到当前位置之间所有元素的和。 Java代码实现123456789101112131415161718192021222324252627public class MaxSubSum &#123; public static void main(String[] args) &#123; int a[]=&#123;1,-2,3,10,-4,7,2,-5&#125;; maxSubSum(a); &#125; public static void maxSubSum(int[] a) &#123; int M = 1; int S = 1; for (int i = 1; i &lt; a.length ; i++ ) &#123; S = maxOf(S+a[i],a[i]); System.out.printf(\"S[%d] = max&#123;S[%d]+a[%d],a[%d]&#125; = %d ;\\n\",i,i-1,i,i,S); M = maxOf(M,S); System.out.printf(\"M[%d] = max&#123;S[%d],M[%d]&#125; = %d ; \\n\",i,i,i-1,M); System.out.println(\"\"); &#125; System.out.println(\"MAX FINAL : \"+M); &#125; public static int maxOf(int a,int b) &#123; System.out.println(a+\" | \"+b); if(a&gt;b || a==b) return a; else return b; &#125;&#125; THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"http://ai.wisim.me/tags/DynamicProgramming/"}]},{"title":"动态规划-最长非降子序列","slug":"2015-05-22-DynamicProgrammingLIS","date":"2015-05-21T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/05/22/2015-05-22-DynamicProgrammingLIS/","link":"","permalink":"http://ai.wisim.me/2015/05/22/2015-05-22-DynamicProgrammingLIS/","excerpt":"题目描述 有序列5，3，4，8，6，7，求它的最长非降子序列的长度","text":"题目描述 有序列5，3，4，8，6，7，求它的最长非降子序列的长度 分析来手写一下求取最长非降子序列的过程，用MAX[i]表示 第i个数所对应的最长非降子序列的长度 123456MAX[1] = 1;//5是第一个数，所以只有5这一个数,MAX[1]=1MAX[2] = max&#123;1&#125; = 1;//因为3之前的所有数都大于3，所以只有3这一个数MAX[3] = max&#123;1,MAX[2]+1&#125; = 2;//因为4前面有3小于4，所以MAX[3]=2MAX[4] = max&#123;1,MAX[1]+1,MAX[2]+1,MAX[3]+1&#125; = max&#123;1,2,2,3&#125; = 3;//8之前的最长非降序列为&#123;3,4&#125;，所以加上8就是MAX[4]=3MAX[5] = max&#123;1,MAX[1]+1,MAX[2]+1,MAX[3]+1&#125; = max&#123;1,2,2,3&#125; = 3;MAX[6] = max&#123;1,MAX[1]+1,MAX[2]+1,MAX[3]+1,MAX[5]+1&#125; = max&#123;1,2,3,4&#125; = 4; 我们求解的问题也就是求MAX[6]的值，MAX[i]就是这个问题的状态，可以得到状态转移方程为：MAX[i] = max{1,MAX[j]+1}，其中j&lt;i,且a[j]&lt;a[i]，也就是说j这个位置的元素小于i位置的元素 Java代码实现1234567891011121314151617181920212223242526public class LIS &#123; public static void lis(int[] a) &#123; int[] MAX = new int[a.length]; MAX[0] = 1; for (int i = 1;i&lt;a.length;i++) &#123; MAX[i] = 1; for (int j = 0;j&lt;i;j++) &#123; if (a[j]&lt;a[i] &amp;&amp; MAX[j]+1&gt;MAX[i]) &#123; MAX[i] = MAX[j]+1; System.out.println(\"Temp Max[\"+i+\"] = \"+MAX[i]); &#125; &#125; System.out.println(\"Final --&gt; Max[\"+i+\"] = \"+MAX[i]); &#125; &#125; public static void main(String[] args) &#123; int[] a = new int[]&#123;5,3,4,8,6,7&#125;; lis(a); &#125;&#125; THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"http://ai.wisim.me/tags/DynamicProgramming/"}]},{"title":"JAVA设计模式-观察者模式","slug":"2015-05-21-DesignPatternObserver","date":"2015-05-20T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/05/21/2015-05-21-DesignPatternObserver/","link":"","permalink":"http://ai.wisim.me/2015/05/21/2015-05-21-DesignPatternObserver/","excerpt":"观察者模式参与者 抽象观察者 抽象被观察者 具体观察者 具体被观察者","text":"观察者模式参与者 抽象观察者 抽象被观察者 具体观察者 具体被观察者 实现 抽象观察者中定义一个抽象行为方法,观察到变化以后执行这个行为 抽象被观察者要实现一个以观察者为参数的构造方法,并且拥有注册和解除观察者的方法 具体被观察者重写抽象观察者的行为方法,并在这个方法中调用观察者的行为方法. 具体观察者重写抽象观察者的行为方法,并且在这个方法中实现观察到状态变化之后的一些操作. 效果最后只要在客户端调用被观察者的行为方法,观察者也会产生相对应的行为. 实例客户端可以向服务器订阅RSS消息，一旦服务器更新了内容，客户端就可以接受更新的内容了。 假设现在有如下参与者： 抽象被观察者：IRSSServerWatched 接口，定义了添加观察者以及移除观察者的方法还有服务器发布新内容的行为方法。 抽象观察者：IClientWatcher 接口，定义了客户端更新内容的方法。 具体被观察者： ConcretRSSServerWatched.java，这个类实现了IRSSServerWatched接口 具体观察者：ConcretClientWatcher.java，这个类实现了IClientWatcher接口 下面来看一下具体的代码实现 一、抽象被观察者：IRSSServerWatched 接口123456//抽象被观察者：RSS订阅服务器接口public interface IRSSServerWatched &#123; public void addWatcher(IClientWatcher watcher); public void removeWatcher(IClientWatcher watcher); public void publishContent(String content);&#125; 二、抽象观察者：IClientWatcher 接口1234//抽象观察者：客户端订阅程序接口public interface IClientWatcher &#123; public void update(String content);&#125; 三、具体被观察者： ConcretRSSServerWatched12345678910111213141516171819202122232425//具体被观察者角色,也就是RSS服务器import java.util.List;import java.util.ArrayList;public class ConcretRSSServerWatched implements IRSSServerWatched &#123; private List&lt;IClientWatcher&gt; mWatchersList = new ArrayList&lt;IClientWatcher&gt;(); public void addWatcher(IClientWatcher watcher) &#123; //这个方法向服务器添加注册的客户端 mWatchersList.add(watcher); &#125; public void removeWatcher(IClientWatcher watcher) &#123; //这个方法将客户端从服务器移除 mWatchersList.remove(watcher); &#125; public void publishContent(String content) &#123; //这个方法是服务器发布新内容，并通知客户端更新内容 System.out.println(\"服务器更新内容啦～\"); for(IClientWatcher watcher : mWatchersList) &#123; watcher.update(content); &#125; &#125;&#125; 四、具体观察者：ConcretClientWatcher1234567//具体观察者角色：RSS订阅客户端public class ConcretClientWatcher implements IClientWatcher &#123; //一旦服务器端有新内容更新，客户端这边即可作出反应 public void update(String content) &#123; System.out.println(\"客户端更新内容 : \"+content); &#125;&#125; 五、下面来测试一下123456789101112131415public class RSSTest &#123; public static void main(String[] args) &#123; IRSSServerWatched server = new ConcretRSSServerWatched(); IClientWatcher watcherOne = new ConcretClientWatcher(); IClientWatcher watcherTwo = new ConcretClientWatcher(); IClientWatcher watcherThree = new ConcretClientWatcher(); server.addWatcher(watcherOne); server.addWatcher(watcherTwo); server.addWatcher(watcherThree); server.publishContent(\"更新的是天气预报。。。\");//这行代码执行之后，上面这些ConcretClientWatcher的update()也会执行，所以就产生了监听的效果 &#125;&#125; 编译运行之后： 1234服务器更新内容啦～客户端更新内容 : 更新的是天气预报。。。客户端更新内容 : 更新的是天气预报。。。客户端更新内容 : 更新的是天气预报。。。 实例源码：https://github.com/whisper92/wxpdesignpattern/tree/master/src/java/observer/rss THE END.","categories":[{"name":"SE","slug":"SE","permalink":"http://ai.wisim.me/categories/SE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ai.wisim.me/tags/Java/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://ai.wisim.me/tags/DesignPattern/"}]},{"title":"JAVA设计模式-模板方法模式","slug":"2015-05-17-DesignPatternTemplate","date":"2015-05-16T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/05/17/2015-05-17-DesignPatternTemplate/","link":"","permalink":"http://ai.wisim.me/2015/05/17/2015-05-17-DesignPatternTemplate/","excerpt":"模板方法模式概述定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。 参与者 抽象模板 具体模板","text":"模板方法模式概述定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。 参与者 抽象模板 具体模板 实现 抽象模板定义一些了抽象模板方法，而这些方法交由子类去实现 具体模板继承抽象模板，并重写抽象模板的模板方法 效果客户端继承抽象模板，实现一个它的一个子类具体模板，并根据具体需求重写抽象模板的模板方法 实例现在有一个算法框架，定义了排序和搜素元素两个抽象方法，而具体的实现则交由客户端实现继承它的子类再去具体实现，至于子类采用什么样的排序和搜索算法，会由客户端自己决定。 现有如下几个角色： 抽象模板：AbstractAlgorithmTemplate，定义排序方法sortContent和搜索方法findElement，还有一个showResult方法，并且在这个方法内部规定了先排序，后搜索的操作。 具体模板：ConcretAlgorithm,继承父类AbstractAlgorithmTemplate，并实现排序和搜索方法 下面来看一下具体的代码实现 一、抽象模板：AbstractAlgorithmTemplate.java123456789101112public abstract class AbstractAlgorithmTemplate &#123; protected abstract void sortContent(int[] array); protected abstract int findElement(int[] array,int e); public void showResult(int[] array) &#123; System.out.println(\"排序开始 ：\"); sortContent(array); int pos = findElement(array,2); System.out.println(\"搜索元素 ： 2\"+\" ； 位置为 ： \"+pos); &#125;&#125; 二、具体模板：ConcretAlgorithm.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ConcretAlgorithm extends AbstractAlgorithmTemplate &#123; @Override protected void sortContent(int[] a) &#123; //这里采用选择排序 int minIndex=0; int temp=0; if((a==null)||(a.length==0)) return; for (int i=0;i&lt;a.length-1;i++) &#123; minIndex=i;//无序区的最小数据数组下标 for (int j=i+1;j&lt;a.length;j++) &#123; //在无序区中找到最小数据并保存其数组下标 if(a[j]&lt;a[minIndex]) &#123; minIndex=j; &#125; &#125; if(minIndex!=i) &#123; //如果不是无序区的最小值位置不是默认的第一个数据，则交换之。 temp=a[i]; a[i]=a[minIndex]; a[minIndex]=temp; &#125; printArray(a); System.out.println(\"\"); &#125; &#125; protected int findElement(int[] array,int e) &#123; //这里采用二分搜索 int l = 0,h = array.length-1; int m = (l+h)/2; int pos = -1; while (l&lt;h) &#123; m = (l+h)/2; if(array[m]&lt;e) &#123; l = m+1; &#125; else if (array[m]&gt;e) &#123; h = m-1; &#125; else &#123; return m; &#125; &#125; return pos; &#125; private static void printArray(int[] array) &#123; for (int i = 0; i &lt; array.length; i++)&#123; System.out.printf(\"%3s\", array[i]); &#125; &#125;&#125; 三、下面来测试一下123456789101112131415/** * 测试：模版方法模式 * @author wxp * */public class TestTemplate&#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;1,3,2,4,6,7,5&#125;; AbstractAlgorithmTemplate abstractQuadrant = new ConcretAlgorithm(); abstractQuadrant.showResult(array); &#125;&#125; 编译运行结果： 12345678排序开始 ： 1 3 2 4 6 7 5 1 2 3 4 6 7 5 1 2 3 4 6 7 5 1 2 3 4 6 7 5 1 2 3 4 5 7 6 1 2 3 4 5 6 7搜索元素 ： 2 ； 位置为 ： 1 实例源码：https://github.com/whisper92/wxpdesignpattern/tree/master/src/java/template THE END.","categories":[{"name":"SE","slug":"SE","permalink":"http://ai.wisim.me/categories/SE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ai.wisim.me/tags/Java/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://ai.wisim.me/tags/DesignPattern/"}]},{"title":"动态规划-最少硬币问题","slug":"2015-05-13-DynaminProgrammingMinCoins","date":"2015-05-12T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/05/13/2015-05-13-DynaminProgrammingMinCoins/","link":"","permalink":"http://ai.wisim.me/2015/05/13/2015-05-13-DynaminProgrammingMinCoins/","excerpt":"题目描述 如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？","text":"题目描述 如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ 分析来手写一下求取最小个数的过程，用MIN[i]表示要凑得i元所需的最少硬币个数 123456789101112MIN[0] = 0MIN[1] = min&#123;MIN[1-1]+1&#125; = 1MIN[2] = min&#123;MIN[2-1]+1&#125; = 2MIN[3] = min&#123;MIN[3-1]+1,MIN[3-3]+1&#125; = min&#123;3,1&#125; = 1MIN[4] = min&#123;MIN[4-1]+1,MIN[4-3]+1&#125; = min&#123;2,2&#125; = 2MIN[5] = min&#123;MIN[5-1]+1,MIN[5-3]+1,MIN[5-5]+1&#125; = min&#123;3,3,1&#125; = 1MIN[6] = min&#123;MIN[6-1]+1,MIN[6-3]+1,MIN[6-5]+1&#125; = min&#123;2,2,2&#125; = 2MIN[7] = min&#123;MIN[7-1]+1,MIN[7-3]+1,MIN[7-5]+1&#125; = min&#123;3,3,3&#125; = 3MIN[8] = min&#123;MIN[8-1]+1,MIN[8-3]+1,MIN[8-5]+1&#125; = min&#123;4,2,2&#125; = 2MIN[9] = min&#123;MIN[9-1]+1,MIN[9-3]+1,MIN[9-5]+1&#125; = min&#123;3,3,3&#125; = 3MIN[10] = min&#123;MIN[10-1]+1,MIN[10-3]+1,MIN[10-5]+1&#125; = min&#123;4,7,2&#125; = 2MIN[11] = min&#123;MIN[11-1]+1,MIN[11-3]+1,MIN[11-5]+1&#125; = min&#123;3,3,3&#125; = 3 我们求解的问题也就是求MIN[11]的值，MIN[i]就是这个问题的状态，可以得到状态转移方程为：MIN[i] = min{MIN[i-Vj]+1},其中i表示要凑i枚硬币，Vj表示第j枚硬币的面值，在这里Vj分别为1,3,5，且0&lt;=i-Vj&lt;i. Java代码实现1234567891011121314151617181920212223242526272829public class MinCoins &#123; public static void main(String[] args) &#123; int[] a = new int[]&#123;1,3,5&#125;; minCoins(a,11); &#125; public static void minCoins(int[] a,int x) &#123; int[] MIN = new int[x+1]; MIN[0] = 0; for (int i = 0 ; i &lt; MIN.length; i++) &#123; //每次循环首先都要将MIN[i]设值i，也就置为最大值。 MIN[i] = i; for (int j = 0;j&lt;a.length;j++) &#123; //接着要判断这次要凑的硬币是否大于最基本的三枚硬币的面值&#123;1,3,5&#125;，并且去除某个面值之后的硬币个数加1的总个数要小于刚刚设置的最大值 if (i&gt;=a[j] &amp;&amp; (MIN[i-a[j]]+1)&lt;MIN[i]) &#123; //要保存此次得到的最小值 MIN[i] = MIN[i-a[j]]+1; System.out.println(\"Temp --&gt; MIN[\"+i+\"] = \"+MIN[i]); &#125; &#125; System.out.println(\"MIN[\"+i+\"] = \"+MIN[i]); &#125; &#125;&#125; THE END.","categories":[{"name":"ALGORITHM","slug":"ALGORITHM","permalink":"http://ai.wisim.me/categories/ALGORITHM/"}],"tags":[{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"http://ai.wisim.me/tags/DynamicProgramming/"}]},{"title":"Android ORM框架GreenDao使用教程","slug":"2015-04-25-AndroidGreenDao","date":"2015-04-24T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/04/25/2015-04-25-AndroidGreenDao/","link":"","permalink":"http://ai.wisim.me/2015/04/25/2015-04-25-AndroidGreenDao/","excerpt":"一、首先是在AndroidStudio配置GreenDao的使用环境，在build.gradle中添加GreenDao的依赖123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:22.0.0' compile 'de.greenrobot:greendao:1.3.7' compile 'de.greenrobot:greendao-generator:1.3.1'&#125; 可以点击右上角出现的’Sync Now’按钮，亦可直接点击’Sync Project with Gradle Files’按钮","text":"一、首先是在AndroidStudio配置GreenDao的使用环境，在build.gradle中添加GreenDao的依赖123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:22.0.0' compile 'de.greenrobot:greendao:1.3.7' compile 'de.greenrobot:greendao-generator:1.3.1'&#125; 可以点击右上角出现的’Sync Now’按钮，亦可直接点击’Sync Project with Gradle Files’按钮 二、下面是官方文档里面的一个例子，在Android项目中新建一个DaoGenerator，这个类用来生成一系列Dao类文件，我这里把它命名为MyDaoGenerator12345678910111213141516171819public class MyDaoGenerator &#123; public static void main(String[] args) throws Exception &#123; //这里第一个参数是版本号，第二个参数是生成类文件的包名 Schema schema = new Schema(1000, \"timo.wxp.com.greendaodemo.gen\"); addNote(schema); //这里第二个参数是生成类文件的路径 new DaoGenerator().generateAll(schema,\"./greendaodemo/src/main/java/\"); &#125; private static void addNote(Schema schema) &#123; Entity note = schema.addEntity(\"Note\"); note.addIdProperty(); note.addStringProperty(\"text\").notNull(); note.addStringProperty(\"comment\"); note.addDateProperty(\"date\"); &#125;&#125; 接着要直接运行这个文件，才能生成相应的文件。其中有DaoMaster以及DaoSession是两个一定会生成的类。另外这里我们自己新增了一个Note类，与之同时生成的还有一个NoteDao类。 Note实体类不用提，不如我们来看一下NoteDao类，看一看自动生成了什么内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class NoteDao extends AbstractDao&lt;Note, Long&gt; &#123; public static final String TABLENAME = \"NOTE\"; /** * Properties of entity Note.&lt;br/&gt; * Can be used for QueryBuilder and for referencing column names. */ public static class Properties &#123; public final static Property Id = new Property(0, Long.class, \"id\", true, \"_id\"); public final static Property Text = new Property(1, String.class, \"text\", false, \"TEXT\"); public final static Property Comment = new Property(2, String.class, \"comment\", false, \"COMMENT\"); public final static Property Date = new Property(3, java.util.Date.class, \"date\", false, \"DATE\"); &#125;; public NoteDao(DaoConfig config) &#123; super(config); &#125; public NoteDao(DaoConfig config, DaoSession daoSession) &#123; super(config, daoSession); &#125; /** Creates the underlying database table. */ public static void createTable(SQLiteDatabase db, boolean ifNotExists) &#123; String constraint = ifNotExists? \"IF NOT EXISTS \": \"\"; db.execSQL(\"CREATE TABLE \" + constraint + \"'NOTE' (\" + // \"'_id' INTEGER PRIMARY KEY ,\" + // 0: id \"'TEXT' TEXT NOT NULL ,\" + // 1: text \"'COMMENT' TEXT,\" + // 2: comment \"'DATE' INTEGER);\"); // 3: date &#125; /** Drops the underlying database table. */ public static void dropTable(SQLiteDatabase db, boolean ifExists) &#123; String sql = \"DROP TABLE \" + (ifExists ? \"IF EXISTS \" : \"\") + \"'NOTE'\"; db.execSQL(sql); &#125; /** @inheritdoc */ @Override protected void bindValues(SQLiteStatement stmt, Note entity) &#123; stmt.clearBindings(); Long id = entity.getId(); if (id != null) &#123; stmt.bindLong(1, id); &#125; stmt.bindString(2, entity.getText()); String comment = entity.getComment(); if (comment != null) &#123; stmt.bindString(3, comment); &#125; java.util.Date date = entity.getDate(); if (date != null) &#123; stmt.bindLong(4, date.getTime()); &#125; &#125; /** @inheritdoc */ @Override public Long readKey(Cursor cursor, int offset) &#123; return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0); &#125; /** @inheritdoc */ @Override public Note readEntity(Cursor cursor, int offset) &#123; Note entity = new Note( // cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id cursor.getString(offset + 1), // text cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // comment cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)) // date ); return entity; &#125; /** @inheritdoc */ @Override public void readEntity(Cursor cursor, Note entity, int offset) &#123; entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0)); entity.setText(cursor.getString(offset + 1)); entity.setComment(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2)); entity.setDate(cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3))); &#125; /** @inheritdoc */ @Override protected Long updateKeyAfterInsert(Note entity, long rowId) &#123; entity.setId(rowId); return rowId; &#125; /** @inheritdoc */ @Override public Long getKey(Note entity) &#123; if(entity != null) &#123; return entity.getId(); &#125; else &#123; return null; &#125; &#125; /** @inheritdoc */ @Override protected boolean isEntityUpdateable() &#123; return true; &#125;&#125; 三、接着就是要在Android项目中使用这些生成的类来完成对数据库的操作了。首先就是实例化一个DevOpenHelper对象，通过这个对象获取一个SQLiteDatabase实例。 12DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, \"notes-db\", null);db = helper.getWritableDatabase(); 然后再实例化一个DaoMaster对象，再通过daoMaster获取一个DaoSession实例，接着就可以通过这个DaoSession实例获取一个NoteDao实例。 123daoMaster = new DaoMaster(db);daoSession = daoMaster.newSession();noteDao = daoSession.getNoteDao(); 有了这个NoteDao实例，我们就可以做很多事情了。比如，查询数据： 123String textColumn = NoteDao.Properties.Text.columnName;String orderBy = textColumn + \" COLLATE LOCALIZED ASC\";cursor = db.query(noteDao.getTablename(), noteDao.getAllColumns(), null, null, null, null, orderBy); 再比如插入一条记录： 1234private void addNote() &#123; Note note = new Note(null, noteText, comment, new Date()); noteDao.insert(note);&#125; 再比如删除一条记录： 1noteDao.deleteByKey(id); GreenDao一些比较简单的操作就是这些类，更深入的研究可以查看官网http://greendao-orm.com/ 参考资料：http://www.it165.net/pro/html/201401/9026.html THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"MacbookPro(2011 early)安装 Ubuntu12.04之后无线网不能使用","slug":"2015-04-11-UbuntuMacbookWifi","date":"2015-04-10T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/04/11/2015-04-11-UbuntuMacbookWifi/","link":"","permalink":"http://ai.wisim.me/2015/04/11/2015-04-11-UbuntuMacbookWifi/","excerpt":"今天闲着无聊把电脑装类个Ubuntu,装完之后发现无线网用不了，真炫酷。然后想起来前几天在Ubuntu上折腾小米wifi的时候，可以将小米Wifi当外置wifi接收器使用。 见帖http://bbs.xiaomi.cn/thread-10424927-1-1.html 然后就顺利成功上网。","text":"今天闲着无聊把电脑装类个Ubuntu,装完之后发现无线网用不了，真炫酷。然后想起来前几天在Ubuntu上折腾小米wifi的时候，可以将小米Wifi当外置wifi接收器使用。 见帖http://bbs.xiaomi.cn/thread-10424927-1-1.html 然后就顺利成功上网。 但是如何使用电脑自带的无线接收器呢，于是展开一系列大搜索。终于在这里发现了 https://help.ubuntu.com/community/MacBookPro8-2 首先要确保现在的电脑可以上网（真矛盾），幸好刚刚装了小米Wifi，跟着它的步骤走： Step1 :在终端执行如下命令sudo add-apt-repository ppa:mpodroid/mactel sudo apt-get update sudo apt-get install b43-fwcutter firmware-b43-installer Step2 ：For Precise, the Compat module should also be installedsudo apt-get install linux-backports-modules-cw-3.3-precise-generic Step3 :打开文件 /etc/modprobe.d/blacklist.conf ，在末尾添加blacklist ndiswrapper Step4 :创建或者编辑文件 /etc/pm/config.d/modules 修改里面的内容SUSPEND_MODULES=&quot;b43 bcma&quot; 文章里面说重启之后就可以生效类，但是我试了一下还要在 系统设置-附加驱动 里面激活刚刚安装的驱动。然后重启就可以。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://ai.wisim.me/tags/Ubuntu/"}]},{"title":"由BroadcastReceiver所引发的事件处理的一些想法","slug":"2015-04-11-AndroidBroadcastReceiverEvent","date":"2015-04-10T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/04/11/2015-04-11-AndroidBroadcastReceiverEvent/","link":"","permalink":"http://ai.wisim.me/2015/04/11/2015-04-11-AndroidBroadcastReceiverEvent/","excerpt":"有些情况下，一旦接受到广播，需要在Activity或者Fragment中处理相关业务逻辑。将广播接收者作为内部类可以很方便的解决这个问题。但是如果，广播接受者作为一个独立的外部类。如何实现这种需求呢。","text":"有些情况下，一旦接受到广播，需要在Activity或者Fragment中处理相关业务逻辑。将广播接收者作为内部类可以很方便的解决这个问题。但是如果，广播接受者作为一个独立的外部类。如何实现这种需求呢。 简单来说就是在广播接受者里面新建一个回调接口，在Activity中实现这个接口。 一、创建一个广播接受者，并在AndroidManifest.xml中注册1234567891011121314151617181920212223242526public class MyReceiver extends BroadcastReceiver &#123; static ExecuteCallback mCallback; public void setCallback(ExecuteCallback callback) &#123; mCallback = callback; Log.e(\"wxp\",\"setCallback\"); &#125; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(\"myreceiver\")) &#123; String msg = intent.getStringExtra(\"msg\"); if (msg == null) msg = \"HELLO\"; if (mCallback != null) &#123; //一旦接受到广播，就执行这个回调方法 mCallback.execute(msg); &#125; else &#123; Log.e(\"wxp\",\"mCallback = null\"); &#125; &#125; &#125;&#125;interface ExecuteCallback&#123; public void execute(String msg);&#125; 二、在Fragment中实现ExecuteCallback接口，重写它的execute方法123456789public class MyBroadcastReceiverEventFragment extends Fragment implements ExecuteCallback&#123; ...... @Override public void execute(String msg) &#123; mTextview.setText(msg); &#125; ......&#125; 这样一旦接受到广播，Fragment中的mTextView就会更新内容了。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"JAVA设计模式-策略模式","slug":"2015-03-29-DesignPatternStrategyDP","date":"2015-03-28T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/03/29/2015-03-29-DesignPatternStrategyDP/","link":"","permalink":"http://ai.wisim.me/2015/03/29/2015-03-29-DesignPatternStrategyDP/","excerpt":"参与者 抽象策略角色 具体策略角色 策略使用场景 客户端 实现 抽象策略角色通过接口或者抽象类来定义要实现的业务逻辑方法 具体策略角色实现抽象策略角色所定义的方法，不同的具体策略角色，他们实现的内容并不一样 在场景里面的构造方法中传入一个策略角色并作为成员变量。定义一个执行方法，在方法内部调用抽象策略角色的业务逻辑方法 在客户端最终的目的是完成抽象策略所定义的业务逻辑，所以只要通过使用场景来完成业务逻辑即可","text":"参与者 抽象策略角色 具体策略角色 策略使用场景 客户端 实现 抽象策略角色通过接口或者抽象类来定义要实现的业务逻辑方法 具体策略角色实现抽象策略角色所定义的方法，不同的具体策略角色，他们实现的内容并不一样 在场景里面的构造方法中传入一个策略角色并作为成员变量。定义一个执行方法，在方法内部调用抽象策略角色的业务逻辑方法 在客户端最终的目的是完成抽象策略所定义的业务逻辑，所以只要通过使用场景来完成业务逻辑即可 效果对于不同的具体策略，客户端并不关心他们的内部实现，只要根据需求将不同的具体策略应用到场景中都可以实现业务逻辑。 实例现在客户端需要一个搜索算法。能够查找当前数组中的某个元素的位置。由于客户端想要根据不同的需求采用不同的搜索算法。于是我们定义以下几个参与者： 抽象策略角色：FindElement接口，用来定义搜索方法find方法 具体策略角色1：直接查找法，实现FindElement接口，并重写它的find方法 ； 具体策略角色2：二分查找法，同样也要实现FindElement接口，并重写它的find方法 策略使用场景： 提供给客户端，并用场景来执行查找行为 客户端 一、首先定义FindElement接口1234public interface FindElement &#123; //查找元素e在数组t中的位置 public int find(int[] t,int e);&#125; 二、定义具体策略角色1：直接查找法12345678910111213public class FindElementDirectly implements FindElement&#123; @Override public int find(int[] array,int e) &#123; int pos = -1; for (int i = 0; i&lt;array.length;i++) &#123; if (e == array[i]) &#123; pos = i; &#125; &#125; return pos; &#125;&#125; 三、定义具体策略角色2：二分查找法1234567891011121314151617181920212223public class FindElementBinary implements FindElement &#123; @Override public int find(int[] array,int e) &#123; int pos = -1; int length = array.length; int low = 0; int high = length-1; while ( low&lt;=high &amp;&amp; low&lt;=(length-1) &amp;&amp; high&lt;=(length-1)) &#123; int mid = (low+high)/2; if ( e == array[mid]) &#123; pos = mid; return pos; &#125; else if ( e &lt; array[mid]) &#123; high = mid -1; &#125; else &#123; low = mid+1; &#125; &#125; return pos; &#125;&#125; 四、定义算法的使用场景1234567891011public class FindContext &#123; private FindElement findElement; public FindContext(FindElement findElement) &#123; this.findElement = findElement; &#125; public int executeFind(int[] t,int e) &#123; return this.findElement.find(t,e); &#125;&#125; 可以看到FindContext有一个FindElement成员变量，它的执行搜索方法内部其实是调用了这个FindElement的find方法，所以只要给FindContext的构造函数传入不同的FindElement对象，场景就可以执行不同的搜索算法，当然最终结果都是一样的。 五、客户端使用场景来调用搜索算法123456789101112public class Client &#123; public static void main(String[] args) &#123; FindContext contextDirectly = new FindContext(new FindElementDirectly()); FindContext contextBinary = new FindContext(new FindElementBinary()); int[] array = new int[]&#123;1,2,3,4,5,6,7&#125;; int posDirectly = contextDirectly.executeFind(array,7); int posBinary = contextBinary.executeFind(array,7); System.out.println(\"Directly --&gt; Pos :\" + posDirectly); System.out.println(\"Binary --&gt; Pos :\" + posBinary); &#125;&#125; 最后来测试一下 12javac Client.javajava Client 看一下运行结果： 12Directly --&gt; Pos :6Binary --&gt; Pos :6 实例源码：https://github.com/whisper92/wxpdesignpattern/tree/master/src/java/strategy/StrategyExample THE END.","categories":[{"name":"SE","slug":"SE","permalink":"http://ai.wisim.me/categories/SE/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://ai.wisim.me/tags/DesignPattern/"},{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/tags/JAVA/"}]},{"title":"JAVA设计模式-代理模式","slug":"2015-03-20-DesignPatternProxy","date":"2015-03-19T16:00:00.000Z","updated":"2018-09-05T01:06:17.000Z","comments":true,"path":"2015/03/20/2015-03-20-DesignPatternProxy/","link":"","permalink":"http://ai.wisim.me/2015/03/20/2015-03-20-DesignPatternProxy/","excerpt":"参与者 行为接口 目标对象，也就是被代理的对象 代理对象 客户端 实现 代理对象和目标对象均实现一个相同的行为接口; 在各自的类里面重写接口中的行为方法. 在代理对象的无参构造函数中实例化一个被代理者对象; 在代理者的行为方法中调用被代理者的行为方法. 客户端想要调用目标对象的那个行为，只能通过调用代理对象的行为方法来实现。","text":"参与者 行为接口 目标对象，也就是被代理的对象 代理对象 客户端 实现 代理对象和目标对象均实现一个相同的行为接口; 在各自的类里面重写接口中的行为方法. 在代理对象的无参构造函数中实例化一个被代理者对象; 在代理者的行为方法中调用被代理者的行为方法. 客户端想要调用目标对象的那个行为，只能通过调用代理对象的行为方法来实现。 效果客户端需要调用的是目标对象(被代理者)的行为方法;现在通过代理模式用代理对象代理了目标对象并调用他的行为方法,达到了同样的目的.并且还可以在代理者中还可以定义其他的一些方法 实例举个例子，“有时候”不能访问谷歌，所以只能翻墙，Ubuntu环境下，使用GoAgent来实现翻墙还是比较方便的。 于是现在就可以通过代理模式来解决上面这中情形下产生的问题 假设现在有下面几个参与者： 行为接口:Search.java 客户端:Geek.java 代理对象:GoAgent.java 目标对象:GAE.java(Google App Engine) 一、首先定义一个抽象的行为接口googlesearch123public interface Search&#123; public String googlesearch(String keyword);&#125; 二、还有一个客户端,也就是它要使用代理对象123456public class Geek&#123; public static void main(String[] args)&#123; Search staticsearch = new GoAgent(); System.out.println(\"Result is :\"+staticsearch.googlesearch(\"wxp\")); &#125;&#125; 由于用户（客户端）并不能直接访问google，也就是不能实例化一个GAE对象，所以只能通过实例化一个GoAgent代理对象来实现。再想一下，实际访问google的是GAE,所以在GoAgent内部一定会实例化一个GAE对象来达到访问google的目的。 三、让GAE实现Search这个行为接口123456public class GAE implements Search&#123; public void googlesearch()&#123; System.out.println(\"Search result from google...keyword is : \"+kw); return \"pcx : \"+System.currentTimeMillis(); &#125;&#125; 四、因为用户就是要通过代理对象来实现搜索，所以GoAgent也要实现Search接口 根据上面的分析，代理对象有一个目标对象作为它的成员变量，并且在代理对象的无参构造函数中实例化这个目标对象。接着在代理对象的行为方法中调用目标对象的行为方法 12345678910111213public class GoAgent implements Search&#123; Search mSearch; public GoAgent()&#123; mSearch = new GAE(); &#125; public String googlesearch(String kw)&#123; System.out.println(\"Use GoAgent to access google search...\"); String res = mSearch.googlesearch(kw); System.out.println(\"Successfully access google\"); return res; &#125;&#125; 最后来测试一下 12javac Geek.javajava Geek 看一下运行结果： 1234Use GoAgent to access google search...Search result from google...keyword is : wxpSuccessfully access googleResult is :pcx : 1426746484614 五、应用场景:一个客户端不能或者不想直接实例化一个对象。于是通过一个代理对象作为中介来实现与服务端的交流。 授权机制：不同等级的用户对某一个对象有不同的访问权限，通过代理模式来进行访问权限的控制。 客户端暂时无法获取服务器端比较大的对象，可以通过代理模式用一个代理对象暂时代替真正的对象。 动态代理可以发现，上面这种代理方式，必须给每个目标对象类都实现一个代理对象类，如果客户端要使用目标对象，只要创建代理对象再调用代理类的方法即可。 但是，如果现在有许多目标对象类，那就必须要有许多代理类才可以，这样显然不合理。所以我们可以采用动态代理，只用一个动态代理类就可以适用所有的目标对象。 要实现动态代理，一般涉及到一下两个类： 一、java.lang.reflect.InvocationHandlerInvocationHandler（调用处理程序）是一个接口，我们必须新建一个自己的子类DynamicProxyHandler并实现这个接口，然后重写它的invoke方法: 123456789101112131415161718192021public class DynamicProxyHandler implements InvocationHandler &#123;private Object mProxied; public DynamicProxyHandler(Object obj)&#123; this.mProxied = obj; &#125; @Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable&#123; System.out.println(\"invoke : Object.getClass() --&gt; \"+proxy.getClass()); System.out.println(\"invoke : Method --&gt; \"+method); System.out.println(\"invoke : Object[] --&gt; \"+args); if (args != null)&#123; for (Object arg : args) &#123; System.out.println(\"args : \"+args); &#125; &#125; return method.invoke(mProxied,args); &#125;&#125; invoke的第一个参数proxy就是下面会提到的Java内建的代理类Proxy类的一个实例 第二个参数method是被代理的方法，也就是上面的googlesearch方法 第三个参数是googlesearch方法的参数组，如果method方法没有参数，那第三个参数就为null 二、java.lang.reflect.ProxyProxy即为代理类，作用类似于上面的GoAgent类，它有一个 Static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 方法返回代理类的一个实例，返回后的代理类，可以当作被代理类使用，也就是可以使用googlesearch方法。 第一个参数是代理类的类加载器 第二个参数是抽象行为方法数组,可以直接通过search.getClass().getInterfaces()来获取 第三个参数是上面提到的调用处理程序DynamicProxyHandler的一个实例 三、我们在客户端如何使用动态代理对象呢1234567Search gae = new GAE();DynamicProxyHandler dynamicproxyhandler = new DynamicProxyHandler(gae);Search dynamicproxysearch = (Search)Proxy.newProxyInstance( Search.class.getClassLoader(), gae.getClass().getInterfaces(), dynamicproxyhandler);System.out.println(\"Result is :\"+dynamicproxysearch.googlesearch(\"wxp\")); 当我们调用dynamicproxysearch的googlesearch方法时，jvm会将该方法的调用指派给它的调用处理程序 dynamicproxyhandler最终调用的其实是metho.invoke()方法。来看一下运行结果： 123456invoke : Object.getClass() --&gt; class com.sun.proxy.$Proxy0invoke : Method --&gt; public abstract java.lang.String Search.googlesearch(java.lang.String)invoke : Object[] --&gt; [Ljava.lang.Object;@3852fdebargs : [Ljava.lang.Object;@3852fdebSearch result from google...keyword is : wxpResult is :pcx : 1426746484620 Proxy上的任何方法调用都会被传入InvocationHandler类,InvocationHandler控制对目标对象的访问。 可以看到在实例化DynamicProxyHandler对象时，只要传入一个目标对象的实例即可。这样我们就不必为每个目标对象都实现一个代理类了，只要通过动态代理来生成一个代理对象，然后调用它的代理方法即可。 实例源码：https://github.com/whisper92/wxpdesignpattern/tree/master/src/java/proxy/ProxyExample 另外附送通过动态代理实现不同访问权限的用户的例子： https://github.com/whisper92/wxpdesignpattern/tree/master/src/java/proxy/ControlAccess THE END.","categories":[{"name":"SE","slug":"SE","permalink":"http://ai.wisim.me/categories/SE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ai.wisim.me/tags/Java/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://ai.wisim.me/tags/DesignPattern/"}]},{"title":"Django 视图Views和URL配置","slug":"2015-03-14-PythonDjangpViewUrl","date":"2015-03-13T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/03/14/2015-03-14-PythonDjangpViewUrl/","link":"","permalink":"http://ai.wisim.me/2015/03/14/2015-03-14-PythonDjangpViewUrl/","excerpt":"Django 中 views 里面的代码就是一个一个函数逻辑，处理客户端(浏览器)发送的 HTTPRequest，然后返回 HTTPResponse。 编写第一个视图 首先在/DjangoApp/LV/views.py中导入HttpResponse模块，再创建一个函数并返回HTTPResponse。： 123456from django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def hello(request): return HttpResponse(\"Hello World, Django\") 接着在/DjangoApp/DjangoApp/urls.py中设置这个视图对应的url： 1234urlpatterns = patterns('', url(r'^admin/', include(admin.site.urls)), url(r'^$', 'LV.views.hello'),)","text":"Django 中 views 里面的代码就是一个一个函数逻辑，处理客户端(浏览器)发送的 HTTPRequest，然后返回 HTTPResponse。 编写第一个视图 首先在/DjangoApp/LV/views.py中导入HttpResponse模块，再创建一个函数并返回HTTPResponse。： 123456from django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def hello(request): return HttpResponse(\"Hello World, Django\") 接着在/DjangoApp/DjangoApp/urls.py中设置这个视图对应的url： 1234urlpatterns = patterns('', url(r'^admin/', include(admin.site.urls)), url(r'^$', 'LV.views.hello'),) 这里的匹配规则是： ^ ： 表示开始匹配字符串 $ ： 表示结束匹配字符串 也就是字符串为空，所以我们最终匹配的地址应该还是127.0.0.1:8000 然后在浏览器中打开127.0.0.1:8000，即可看页面上到输出Hello World, Django url()函数有四个参数, 两个是必须的:regex和view, 两个可选的:kwargs和name 第一个参数regex也就是正则匹配，Django将浏览器请求的URL从上倒下一次匹配，直到匹配出一个为止，另外即使有多个匹配，也知会匹配第一个符合条件的。 第二个参数view，如果上面的过程完毕之后成功匹配到一个URL，就会调用这个view中指定的函数，比如上面执行了hello函数。 第三个参数kwargs任意关键字参数可传一个字典至目标view 带参数的视图 在/DjangoApp/LV/views.py中创建一个新的带参数的函数： 12def answerme(request,name): return HttpResponse(\"Hello Django, i am %s\"%name) 在/DjangoApp/DjangoApp/urls.py中添加url： 1url(r'^(?P&lt;your_name&gt;\\D+)/$','LV.views.anserme',name='anserme'), ^(?P\\d+)/$这个正则表达式的意思是将传入的非数字字符作为参数传递到views中的answerme作为参数, 其中?P定义名称用于标识匹配的内容 这里的匹配规则是： \\D ： 匹配任意非数字的字符 + ： 表示重复一次或更多次 在浏览器中打开127.0.0.1:8000/your_name，就会显示Hello Django, i am your_name了，这里的your_name可以随便输入一个不为数字的字符串。 当然同样也可以定义另外一个函数，用于接受年龄 在/DjangoApp/LV/views.py中创建一个新的带参数的函数： 12def answerme_age(request,age): return HttpResponse(\"Hello Django, i am %s years old.\"%age) 不过这时候的匹配规则就要变化了，在/DjangoApp/DjangoApp/urls.py中添加url： 1url(r'^(?P&lt;age&gt;\\d+)/$','LV.views.answerme_age',name='answerme_age'), 在浏览器中打开127.0.0.1:8000/24，就会显示Hello Django, i am 24 years old了，这里的24就是我输入的年纪了。 传入参数访问数据库之前已经在管理页面添加了Article的model了，所以我们在管理页面http://127.0.0.1:8000/admin/LV/article/就可以直接操作Article了，Django会自动将我们的操作同步到数据库 这里我们可以直接插入一条记录 同样，在/DjangoApp/LV/views.py中创建一个新的带参数的函数，记得要导入Article： 12345from LV.models import Articledef detail(request, my_args): post = Article.objects.all()[int(my_args)] str = (\"title = %s, category = %s, content = %s\"%(post.title,post.category,post.content)) return HttpResponse(str) 在/DjangoApp/DjangoApp/urls.py中添加url： 1url(r'^(?P&lt;my_args&gt;\\d+)/$', 'LV.views.detail', name='detail'), 在浏览器中打开127.0.0.1:8000/0，就会显示刚刚插入的那条记录的内容了 title = wxp, category = blog, content = Hello Django i am wxp THE END.","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://ai.wisim.me/categories/PYTHON/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://ai.wisim.me/tags/Django/"}]},{"title":"UML类图要点","slug":"2015-03-10-OtherUMLClassPoints","date":"2015-03-09T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/03/10/2015-03-10-OtherUMLClassPoints/","link":"","permalink":"http://ai.wisim.me/2015/03/10/2015-03-10-OtherUMLClassPoints/","excerpt":"1.泛化 泛化是之类与父类的继承关系，也就是Java中的 extends 用带三角箭头的实线表示，箭头指向父类 2.实现 实现是类与接口的继承关系，也就是Java中的 implements 用带三角箭头的虚线表示，箭头指向接口 3.组合 组合是整体与部分的关系，并且部分脱离了整体就没有存在的意义，整体消失。部分也就不存在了。例如头是整体，嘴是部分，头消失了，嘴也就，没有存在的意义 用带菱形的实线箭头表示，菱形指向整体 在代码实现组合关系时，部分通常作为整体的成员变量，并且是在表示整体的类的构造方法中直接实例化表示部分的类：","text":"1.泛化 泛化是之类与父类的继承关系，也就是Java中的 extends 用带三角箭头的实线表示，箭头指向父类 2.实现 实现是类与接口的继承关系，也就是Java中的 implements 用带三角箭头的虚线表示，箭头指向接口 3.组合 组合是整体与部分的关系，并且部分脱离了整体就没有存在的意义，整体消失。部分也就不存在了。例如头是整体，嘴是部分，头消失了，嘴也就，没有存在的意义 用带菱形的实线箭头表示，菱形指向整体 在代码实现组合关系时，部分通常作为整体的成员变量，并且是在表示整体的类的构造方法中直接实例化表示部分的类： 123456public class Head &#123; private Mouth mMouth = null; public Head() &#123; mMouth = new Mouth(); &#125;&#125; 4.聚合 聚合是整体与部分的关系，部分脱离了整体还能有单独存在的意义。例如汽车是整体，引擎是部分，引擎脱离汽车还有存在的意义 用带菱形的实线虚线箭头表示，菱形指向整体 在代码实现聚合关系时，部分通常作为整体的成员变量，并且是将表示部分的类作为一个参数传递给用于表示整体的类的构造方法： 123456public class Car &#123; private Engine mEngine = null; public Car(Engine engine) &#123; this.mEngine = engine; &#125; &#125; 5.关联 关联是一种拥有关系或者说引用关系，它使一个类知道另一个类的属性和方法。例如一个老师有好多学生，学生也有好多老师，这就是双向关联；一个顾客有一个家庭住址这就是单向关联。组合以及聚合都是关联的一种，但是关联并没有尤其明显的部分与整体的关系。他们三者之间在语法上没有区别，必须考察具体的逻辑关系 用实线箭头表示，箭头指向被拥有者。 在代码实现关联关系时，一个类通常作为另一个类的成员变量： 12345678910111213public class Teacher &#123; private Student[] students; ......&#125;public class Student &#123; private Teacher[] teachers; ......&#125;public class Customer &#123; private Address address; ......&#125; 6.依赖 依赖是一种使用关系，即一个类的实现需要另一个类的协助，所以尽量不要使用双向的互相依赖关系 用虚线肩头表示，箭头指向被使用者 在代码实现依赖关系时，通常有三种方式，第一种也是最常用的一种方式是将一个类的对象作为另一个类中某个方法的参数，第二种方式是在一个类的方法中将另一个类的对象作为其局部变量，第三种方式是在一个类的方法中调用另一个类的静态方法。 他们之间的强弱关系对比： 实现=泛化&gt;组合&gt;聚合&gt;关联&gt;依赖 THE END.","categories":[{"name":"SE","slug":"SE","permalink":"http://ai.wisim.me/categories/SE/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://ai.wisim.me/tags/UML/"}]},{"title":"Ubuntu 12.04 下配置Django开发环境","slug":"2015-01-13-PythonDjangoInstall","date":"2015-01-12T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/01/13/2015-01-13-PythonDjangoInstall/","link":"","permalink":"http://ai.wisim.me/2015/01/13/2015-01-13-PythonDjangoInstall/","excerpt":"Apache安装：第一步：安装Apache2。 sudo apt-get install apache2 第二步：安装mod_wsgi。 sudo apt-get install libapache2-mod-wsgi","text":"Apache安装：第一步：安装Apache2。 sudo apt-get install apache2 第二步：安装mod_wsgi。 sudo apt-get install libapache2-mod-wsgi MySQL安装：第一步：安装MySQL server。 sudo apt-get install mysql-server 注意这个过程会要求输入密码，之后登陆mysql都要输入这个密码 第二步：安装MySQL的python接口。 sudo apt-get install python-mysqldb Django安装：Ubuntu下安装最新的django可以直接打开终端执行： pip install django 或者指定安装版本： pip install -v django==1.7.1 也可手动下载安装包再进行安装： 第一步：下载Django软件包。 可以从Django的官网下载Django-1.7.6.tar.gz 第二步：解压缩Django软件包。 第三步：安装Django软件包。 cd进入解压缩得到的文件夹，然后输入 sudo python setup.py install 安装完成！ 测试Django安装结果： 创建第一个Django项目：django-admin.py startproject DjangoApp cd DjangoApp python manage.py runserver 接着就在浏览器中打开http://127.0.0.1:8000/,会出现Django的欢迎界面了： 创建一个Django程序：在项目的根目录下执行： python manage.py startapp LV 接着就会发现目录下面新建了一个LV程序 还要记得在DjangoApp/DjangoApp/settings.py中找到INSTALLED_APPS，在其中添加LV 配置数据库：第一步：登陆mysql。 mysql -u root -p 接着再输入安装mysql时输入的密码即可 接着创建数据库，在终端继续执行： create database django_app 第二步：配置Django项目中的settings.py,在刚刚创建的DjangoApp/DjangoApp/目录下的settings.py文件中 1234567891011DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.也就是告诉Django使用mysql数据库 'NAME': 'django_app', # Or path to database file if using sqlite3.填写刚刚创建的数据库名称 # The following settings are not used with sqlite3: 'USER': 'root', #mysql用户名 'PASSWORD': '1992', #msql密码 'HOST': '127.0.0.1', # Empty for localhost through domain sockets or '127.0.0.1' for localhost through TCP.本机地址 'PORT': '3306', # Set to empty string for default.端口号 &#125;&#125; 第三步：现在自己定义一个表，并在通过Django自动在数据库中创建这个表。 首先在/DjangoApp/LV/models.py中添加： 1234567891011121314from django.db import models# Create your models here.class Article(models.Model) : title = models.CharField(max_length = 100) #title category = models.CharField(max_length = 50, blank = True) #tags date_time = models.DateTimeField(auto_now_add = True) #date content = models.TextField(blank = True, null = True) #content def __unicode__(self) : return self.title class Meta: #order by date desc ordering = ['-date_time'] 每个Django Model都继承自 django.db.models.Model都相当于一个表，而model的每一个属性都相当于这个表的一个字段 通过 Django Model API 可以执行数据库的增删改查, 而不需要写一些数据库的查询语句 第四步：在DjangoApp根目录下执行： python manage.py syncdb 然后还会提示创建Django超级用户，依次输入相yes,root,邮箱,密码即可。 ! 接着就显示创建成功了。 进入数据库即可发现，出现了一张新的表 LV_article 以后如果要创建一个新表，就不用执行python manage.py syncdb了,需要做以下几个步骤： 修改 models.py 文件 运行 python manage.py makemigrations 创建迁移语句 运行 python manage.py migrate ，将模型的改变迁移到数据库中 打开Django自带的管理界面首先在DjangoApp/DjangoApp/settings.py中INSTALLED_APPS部分添加 &#39;django.contrib.admin&#39;, #add admin function 然后在DjangoApp/DjangoApp/urls.py中修改内容，原有的注释已被删除 1234567from django.conf.urls import patterns, include, urlfrom django.contrib import adminadmin.autodiscover()urlpatterns = patterns('', url(r'^admin/', include(admin.site.urls)), #enter admin background through url) 接着在浏览器中打开http://127.0.0.1:8000/admin/，再输入创建Django超级用户时填写的用户名和密码即可成功进入管理页面： 另外可以通过安装Bootstrap来改善界面： pip install bootstrap-admin 可以看到管理页面只有Groups和Users，下面将之前创建的Article也加入到管理页面来修改DjangoApp/Lv/admin.py内容，添加Article： 1234from django.contrib import adminfrom LV.models import Article# Register your models here.admin.site.register(Article) 之后就可以直接添加Article数据了。 参考资料： Django官网:https://www.djangoproject.com/ 如何创建一个Django网站:http://blog.javachen.com/2014/01/11/how-to-create-a-django-site/ The Django Book:http://djangobook.py3k.cn/2.0/chapter02/ 开发环境和Django安装:http://andrew-liu.gitbooks.io/django-blog/content/kai_fa_huan_jing_he_django_an_zhuang.html MySql命令行:http://baike.baidu.com/link?url=U1jfiMYK86lqZL-iK1KK9F0RtcIMZD2-k2C4JCXys5B0y2RiaHUhFZzNj4purQeFm-ERDzgCgHFRAWcStD0bkgcByA5V1rNboc1_3R73253qfIsqZCDBIGFA394Zgyp3#1 Windows下安装Python以及Django的步骤： http://jingyan.baidu.com/article/466506580e7d29f549e5f8b6.html Windows如果要使用Mysql作为Django作为数据库，首先要安装这个包 /raw/attach/1505/setuptools-15.1.zip THE END.","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://ai.wisim.me/categories/PYTHON/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://ai.wisim.me/tags/Ubuntu/"}]},{"title":"Android设置模块解锁方式详细分析","slug":"2015-01-09-FrameworksSettingsUnlockMethods","date":"2015-01-08T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/01/09/2015-01-09-FrameworksSettingsUnlockMethods/","link":"","permalink":"http://ai.wisim.me/2015/01/09/2015-01-09-FrameworksSettingsUnlockMethods/","excerpt":"我们先从无，也就是不使用锁屏方式，开始分析。 1. 首先进入设置-安全界面此时对应的就是Settings模块下的 SecuritySettings.java文件，点击屏幕锁定，执行onPreferenceTreeClick方法，可以看到走的是下面这段代码： startFragment(this, &quot;com.android.settings.ChooseLockGeneric$ChooseLockGenericFragment&quot;,SET_OR_CHANGE_LOCK_METHOD_REQUEST, null); 也就是进入了下面这个界面选择屏幕锁定方式这个界面。","text":"我们先从无，也就是不使用锁屏方式，开始分析。 1. 首先进入设置-安全界面此时对应的就是Settings模块下的 SecuritySettings.java文件，点击屏幕锁定，执行onPreferenceTreeClick方法，可以看到走的是下面这段代码： startFragment(this, &quot;com.android.settings.ChooseLockGeneric$ChooseLockGenericFragment&quot;,SET_OR_CHANGE_LOCK_METHOD_REQUEST, null); 也就是进入了下面这个界面选择屏幕锁定方式这个界面。 位于 选择屏幕锁定方式 下的选择屏幕锁定方式界面中共有如下几种解锁方式： 2. 上面图片显示的这个界面对应的就是ChooseLockGeneric.java文件，所以先从它开始。它有一个内部类 ChooseLockGenericFragment extends SettingsPreferenceFragment 。 3. 在ChooseLockGenericFragment的updatePreferencesOrFinish()方法中有这样一行代码用于显示所有的解锁方式：addPreferencesFromResource(R.xml.security_settings_picker); /src/xml/security_settings_picker.xml这个文件，就是用来配置所有解锁方式的文件，来看看它的源码: 123456789101112131415&lt;PreferenceScreen xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;PreferenceScreen android:key=\"unlock_set_off\" android:title=\"@string/unlock_set_unlock_off_title\" android:persistent=\"false\"/&gt; &lt;PreferenceScreen android:key=\"unlock_set_none\" android:title=\"@string/unlock_set_unlock_none_title\" android:persistent=\"false\"/&gt; ............ &lt;PreferenceScreen android:key=\"unlock_set_fingerprint\" android:title=\"@string/unlock_set_unlock_fingerprint_title\" android:persistent=\"false\"/&gt;&lt;/PreferenceScreen&gt; 因此如果要添加一个新的解锁方式，首先在界面上添加就是要修改这个文件，这里的unlock_set_fingerprint就是我自己添加的，也就是指纹解锁。 4. 继续看ChooseLockGenericFragment的 onPreferenceTreeClick()方法，这个方法就是处理每一项的点击事件的方法。如果我们选择无，也就是没有锁屏，点亮屏幕直接进入主屏，走的就是这个if语句： 1234final String key = preference.getKey();if (KEY_UNLOCK_SET_OFF.equals(key) ) &#123; updateUnlockMethodAndFinish(DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED, true);&#125; 这里直接将事件交给了 updateUnlockMethodAndFinish(int quality, boolean disabled)方法处理。 这个方法的第一个参数表示解锁方式的等级，在android.app.admin.DevicePolicyManager.java中定义了各个解锁方式对应的等级值，从小到大，表示解锁方式安全性的由弱到强： 无和滑动两个对应的值都是PASSWORD_QUALITY_UNSPECIFIED = 0 注意这个方法的第二个参数disabled是一个boolean值，如果不使用任何解锁方式，也就是无，那么updateUnlockMethodAndFinish中的这个值就应该传入true；否则都应该传入false，所以源码中只有处理无选项的updateUnlockMethodAndFinish方法传入了true，其他都传入false。 5. 那么下面理所当然就是看updateUnlockMethodAndFinish方法了。由于我们这里分析的是无选项，所以只看它对应的代码： mChooseLockSettingsHelper.utils().clearLock(false);这行代码是用来清除所有的锁屏方式的，看一下它里面的代码： 注释也写的很清楚：Clear any lock pattern or password; 而 mChooseLockSettingsHelper.utils().setLockScreenDisabled(disabled);这个disabled值就是上面传进来的true，也就是意味着不使用任何解锁方法 6. 接着finish之后会回调 SecuritySettings 中的onActivityResult()方法。这个方法里面会调用 createPreferenceHierarchy()方法，而这个方法中的addPreferencesFromResource(resid);就是在SecuritySettings界面显示刚刚选择的解锁方式,如图： 我们来仔细看一下代码： 12345678910111213if (!mLockPatternUtils.isSecure()) &#123; // if there are multiple users, disable \"None\" setting UserManager mUm = (UserManager) getSystemService(Context.USER_SERVICE); List&lt;UserInfo&gt; users = mUm.getUsers(true); final boolean singleUser = users.size() == 1; if (singleUser &amp;&amp; mLockPatternUtils.isLockScreenDisabled()) &#123; resid = R.xml.security_settings_lockscreen; &#125; else &#123; Log.e(\"SecuritySettings\",\"SecuritySettings--&gt;createPreferenceHierarchy--&gt; security_settings_chooser()\"); resid = R.xml.security_settings_chooser; &#125;&#125;addPreferencesFromResource(resid); R.xml.security_settings_lockscreen是无对应的布局；resid = R.xml.security_settings_chooser是滑动解锁对应的布局。 看一下mLockPatternUtils.isLockScreenDisabled()这个方法： 也就是说如果是isSecure()为false，并且getLong的值不为0，就显示无。 getLong的值在刚刚的setLockScreenDisabled(disabled)中已经设置为 1 了。所以就来看看isSecure()方法： 1234567891011public boolean isSecure() &#123; long mode = getKeyguardStoredPasswordQuality(); final boolean isPattern = mode == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING; final boolean isPassword = mode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC || mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX; final boolean secure = isPattern &amp;&amp; isIphoneLockPatternEnabled() &amp;&amp; savedPatternExists() || isPassword &amp;&amp; savedPasswordExists(); return secure;&#125; 由于当前的mode是DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED，所以isPattern为false，所以isSecure()肯定返回false了。 最终我们看到的就是无这个选项了。 另外，滑动解锁与无的唯一区别就是,调用 updateUnlockMethodAndFinish(DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED, true) 是传入的是true，也就是使用锁屏，而无传入的这个值是false。 接着来看一下选择图案解锁方式的流程1. 之前的步骤都一样，所以我们从上面的步骤4开始分析。执行onPreferenceTreeClick方法之后，因为选择的是图案解锁，走的就是这个if语句： 123else if (KEY_UNLOCK_SET_PATTERN.equals(key)) &#123; updateUnlockMethodAndFinish(DevicePolicyManager.PASSWORD_QUALITY_SOMETHING, false);&#125; DevicePolicyManager.PASSWORD_QUALITY_SOMETHING的值是0x10000 2. 看一下它调用调用updateUnlockMethodAndFinish()方法，走的是哪段代码：1234567891011121314151617181920212223242526else if (quality == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING) &#123; Intent intent = new Intent(getActivity(), ChooseLockPattern.class); intent.putExtra(\"key_lock_method\", \"pattern\"); intent.putExtra(CONFIRM_CREDENTIALS, false); intent.putExtra(IphoneLockPatternUtils.LOCKSCREEN_WEAK_FALLBACK, isFallback); //M: modify for voice unlock if (isFallback) &#123; //M: add for voice unlock @&#123; String isFallbackFor = getActivity().getIntent(). getStringExtra(IphoneLockPatternUtils.LOCKSCREEN_WEAK_FALLBACK_FOR); String commandKey = getActivity().getIntent(). getStringExtra(IphoneLockPatternUtils.SETTINGS_COMMAND_KEY); String commandValue = getActivity().getIntent(). getStringExtra(IphoneLockPatternUtils.SETTINGS_COMMAND_VALUE); intent.putExtra(IphoneLockPatternUtils.SETTINGS_COMMAND_KEY, commandKey); intent.putExtra(IphoneLockPatternUtils.SETTINGS_COMMAND_VALUE, commandValue); intent.putExtra(IphoneLockPatternUtils.LOCKSCREEN_WEAK_FALLBACK_FOR, isFallbackFor); //@&#125; startActivityForResult(intent, FALLBACK_REQUEST); return; &#125; else &#123; mFinishPending = true; intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); startActivity(intent); &#125;&#125; 来看一下这段代码中的if (isFallback) {...}部分： 首先值得一提的是，如果我们选择一种安全性比较弱（介于 UNSPECIFIED 和SOMETHING之间）的解锁方式，例如语音解锁，那么我们不仅要录如自己的语音命令，还要选择一个备用的解锁方式，如图： 这里的这个isFallback就是用来判断当前这个图案解锁方式，是直接选择的呢，还是其他解锁方式的备用解锁方式。如果是直接选择的，那就直接startActivity(intent);，否则就startActivityForResult(intent, FALLBACK_REQUEST); 我们暂且先考虑直接选择图案解锁这种情形，也就是走else部分。 123intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);startActivity(intent);&#125; 以这种方式启动Activity的意思就是说，因为ChooseLockGeneric是由SecuritySettings启动的，所以ChooseLockGeneric启动ChooseLockPattern之后，ChooseLockPattern的setResult方法会将结果返回给SecuritySettings而不是ChooseLockGeneric.java,这是应该注意的。 3. 接着就是绘制两次图案了，在ChooseLockPattern中的saveChosenPatternAndFinish()方法中有这样一行代码： utils.saveIphoneLockPattern(mChosenPattern, isFallback, isFallbackFor); 看一下这个方法的内部： setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);其实就是用来标识图案解锁这种方式的，在下面的显示解锁方式时会用到。 4. 最后还是来看一下SecuritySettings.java中的createPreferenceHierarchy()方法： 首先要判断mLockPatternUtils.getKeyguardStoredPasswordQuality()的值，来看一下这个方法的具体实现： 一目了然，这个getLong获取的值就是上面我们提到的标识图案解锁的值，所以必然走的是这个case: 123case DevicePolicyManager.PASSWORD_QUALITY_SOMETHING: resid = R.xml.security_settings_pattern; break; 最终显示出来的就是我们选择了图案解锁。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android Settings模块浅析-添加新的显示选项","slug":"2015-01-07-FrameworksSettingsAddDislplayOption","date":"2015-01-06T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2015/01/07/2015-01-07-FrameworksSettingsAddDislplayOption/","link":"","permalink":"http://ai.wisim.me/2015/01/07/2015-01-07-FrameworksSettingsAddDislplayOption/","excerpt":"向Display中添加新的设置选项： mDisplayPerCategory 是加入到PERSONLIZE部分 12CheckBoxPreference PersonalNewSet = (CheckBoxPreference) createPreference(TYPE_CHECKBOX, R.string.display_personalize, KEY_LOCK_SCREEN_NOTIFICATIONS, mDisplayPerCategory); mDisplayDefCategory 是加入到DISPLAY部分 12CheckBoxPreference DisplayNewSet = (CheckBoxPreference) createPreference(TYPE_CHECKBOX, R.string.display_default, KEY_LOCK_SCREEN_NOTIFICATIONS,mDisplayDefCategory);","text":"向Display中添加新的设置选项： mDisplayPerCategory 是加入到PERSONLIZE部分 12CheckBoxPreference PersonalNewSet = (CheckBoxPreference) createPreference(TYPE_CHECKBOX, R.string.display_personalize, KEY_LOCK_SCREEN_NOTIFICATIONS, mDisplayPerCategory); mDisplayDefCategory 是加入到DISPLAY部分 12CheckBoxPreference DisplayNewSet = (CheckBoxPreference) createPreference(TYPE_CHECKBOX, R.string.display_default, KEY_LOCK_SCREEN_NOTIFICATIONS,mDisplayDefCategory); 看一下效果图，黑色边框圈出的地方就是新加的两个选项： THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android Makefile Syntax","slug":"2014-12-30-OtherMakefileSytax","date":"2014-12-29T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/12/30/2014-12-30-OtherMakefileSytax/","link":"","permalink":"http://ai.wisim.me/2014/12/30/2014-12-30-OtherMakefileSytax/","excerpt":"You can build JNI Application by NDK. In addition,if you have android source code environment,you can write a Android Makefile to build .so file and your application automatically.","text":"You can build JNI Application by NDK. In addition,if you have android source code environment,you can write a Android Makefile to build .so file and your application automatically. Here is an example of Andoird.mk in HelloJni:12345678LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_STATIC_JAVA_LIBRARIES := android-support-v4LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(call all-java-files-under, src)LOCAL_JNI_SHARED_LIBRARIES := libhelloLOCAL_PACKAGE_NAME := HelloJniinclude $(BUILD_PACKAGE) 1.LOCAL_PATH:= $(call my-dir) An Android makefile must begin with the definition of the LOCAL_PATH variable. It is used to locate source files in the development trees. The function my-dir ,provided by the build system,is used to return the path of the current directory. 2.include $(CLEAR_VARS)The CLEAR_VARS vairable is provided by build system and points to a special GNU Makefile thar will clear many LOCAL_XXX variable for you. 3.LOCAL_STATIC_JAVA_LIBRARIES := android-support-v4Use a static java library called android-support-v4 4.LOCAL_MODULE_TAGS ：=optional optional: this module will be compiled in all version user: this module will be compiled only in user version eng: only in eng version tests: only in tests version 5.LOCAL_JNI_SHARED_LIBRARIES := libhellocasUse a shared library called libhello 6.LOCAL_PACKAGE_NAME := HelloJniName of the APK to build 7.include $(BUILD_PACKAGE)Tell it to build an APK Finally,this package will generate HelloJni.apk Here is an example of Android.mk in jni folder:12345LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := libhelloLOCAL_SRC_FILES := hello.cinclude $(BUILD_SHARED_LIBRARY) 1.LOCAL_MODULE := libhello The LOCAL_MODULE variable must be defined to idenfy each module you describe in the Android.mk. The name must be unique and not contain any space. It determins the name of file which will genegrate. 2.include $(BUILD_SHARED_LIBRARY)Tell it to generate a shared library 3.LOCAL_SRC_FILES := hello.cThe LOCAL_SRC_FILES variable must contain a list file of c and/or c++ source files that will be build and assembled into the module Finally,this module will generate libhello.so If you want to use a third jar package,how to add compile command into Android.mk:For example,there is a nineoldandroids-2.4.0.jar in the /libs,then we can compile it into the application by the Android.mk as follow. 12345678910111213141516171819LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optional\\#LOCAL_SDK_VERSION := currentLOCAL_SRC_FILES := $(call all-java-files-under,src)LOCAL_PACKAGE_NAME := TodosLOCAL_CERTIFICATE := platform\\#`nineo` is a tag we define belowLOCAL_STATIC_JAVA_LIBRARIES := nineoinclude $(BUILD_PACKAGE)include $(CLEAR_VARS)\\#`libs` is the position of jar packageLOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := nineo:libs/nineoldandroids-2.4.0.jarinclude $(BUILD_MULTI_PREBUILT)\\# Use the following include to make our test apk.include $(call all-makefiles-under,$(LOCAL_PATH)) THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android应用访问硬件驱动程序","slug":"2014-12-29-NDKAccessDriver","date":"2014-12-28T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/12/29/2014-12-29-NDKAccessDriver/","link":"","permalink":"http://ai.wisim.me/2014/12/29/2014-12-29-NDKAccessDriver/","excerpt":"在应用层访问驱动程序有两种实现架构： (1).直接在使用JNI访问底层驱动，然后在Java代码中调用JNI的方法来实现最终访问驱动的目的。 (2).通过硬件抽象层来访问硬件，然后在Framework层实现访问硬件抽象层的JNI方法。 不管那种方法，都要添加新的系统级硬件访问服务。","text":"在应用层访问驱动程序有两种实现架构： (1).直接在使用JNI访问底层驱动，然后在Java代码中调用JNI的方法来实现最终访问驱动的目的。 (2).通过硬件抽象层来访问硬件，然后在Framework层实现访问硬件抽象层的JNI方法。 不管那种方法，都要添加新的系统级硬件访问服务。 1. 对于第一种架构，先来看一个简单的例子：JNI访问重力感应驱动libgsensor_jni.cpp#define LOG_TAG &quot;libproximity_jni&quot; #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; #include &lt;errno.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;utils/misc.h&gt; #include &lt;utils/Log.h&gt; #include &quot;jni.h&quot; #include &quot;JNIHelp.h&quot; #include &lt;linux/ioctl.h&gt; #define GSENSOR 0x85 #define GSENSOR_IOCTL_SET_CALIBARION _IO(GSENSOR, 0x0A) #ifdef __cplusplus extern &quot;C&quot; { #endif static jboolean gcalibrateSensor(JNIEnv *env, jobject clazz) { ALOGI(&quot;[Proximity] gcalibrateSensor\\n&quot;); int fd = open(&quot;/dev/gsensor&quot;, O_RDWR, 0); ALOGE(&quot;[Proximity] callgcalibrateSensor, fd:%d\\n&quot;, fd); if (fd &gt;= 0) { if (ioctl(fd, GSENSOR_IOCTL_SET_CALIBARION) == -1) { ALOGE(&quot;[Proximity] gcalibrateSensor 1111failed\\n&quot;); return JNI_FALSE; } close(fd); } else { ALOGE(&quot;[Proximity] gcalibrateSensor 1111 open als_ps failed\\n&quot;); return JNI_FALSE; } return JNI_TRUE; } // -------------------------------------------------------------------------- static JNINativeMethod gsensorNotify[] = { { &quot;gcalibrateSensor&quot;, &quot;()Z&quot;, (void*)gcalibrateSensor }, }; jint JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env = NULL; jint result = -1; if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) { ALOGE(&quot;GetEnv failed!&quot;); return result; } int ret = jniRegisterNativeMethods( env, &quot;com/bird/gsensor/GSensorNative&quot;, gsensorNotify, NELEM(gsensorNotify)); if (ret) { ALOGE(&quot;[Proximity] call jniRegisterNativeMethods() failed, ret:%d\\n&quot;, ret); } return JNI_VERSION_1_4; } #ifdef __cplusplus } #endif 2. 由于上面这个.cpp文件会在编译的时候生成一个动态链接库，接着定义一个Java类来加载这个动态库public class GSensorNative { static { System.loadLibrary(&quot;gsensorjni&quot;); } public native boolean gcalibrateSensor(); } 3. 最后如果要访问重力感应硬件，只要调用实例化一个GSensorNative对象，再调用它的gcalibrateSensor()即可mGCali.gcalibrateSensor(); 如果只是对于单纯某个应用要访问硬件，我们只要采用第一种架构。但是现实开发中，通常是要将访问硬件的服务添加到系统服务中去，以便系统里所有应用都可以通过调用系统服务的方式来访问硬件。由于硬件抽象层并不在本文的涉及范围之内，我们这里只讨论如何使用JNI访问硬件抽象层模块的接口。 0. /framework/base/下面新增一个包的话，要在build/core/pathmap.mk下面去注册,在FRAMEWORKS_BASE_SUBDIRS后添加新增的目录名1. 定义硬件访问服务/frameworks/base/core/java/android/os/IFingerprintService.aidlpackage android.os; interface IFingerprintService { boolean recordNewFingerprint(); boolean compareFingerprints(); } 注意：要在/framework/base/Android.mk中添加，修改LOCAL_SRC_FILES变量的值： 1234LOCAL_SRC_FILES += \\...core/java/android/os/IFingerprintService.aidl... 接口中有两个方法，一个是用于录取指纹，另一个用于比对指纹。 2. 实现硬件访问服务/framewoks/base/services/java/com/android/server/FingerprintService.javapackage com.android.server; import android.os.IFingerprintService; import android.util.Log; public class FingerprintService extends IFingerprintService.Stub { private static final String TAG = &quot;FingerprintService&quot;; private int mPtr = 0; FingerprintService(){ mPtr = init_native(); if (mPtr == 0) { Log.e(&quot;TAG&quot;,&quot;init_fail&quot;); } else { Log.e(&quot;TAG&quot;,&quot;init_success&quot;); } } public boolean recordNewFingerprint(){ if (mPtr == 0) { return false; } return recordNewFingerprint_native(); } public boolean compareFingerprints(){ if (mPtr == 0) { return false; } return compareFingerprints_native(); } private static native int init_native(); private static native boolean recordNewFingerprint_native(); private static native boolean compareFingerprints_native(); } 3. 实现硬件访问服务的JNI方法/framewoks/base/services/jni/com_android_server_FingerprintService.cpp#define LOG_TAG &quot;FingerprintServiceJNI&quot; #include &quot;jni.h&quot; #include &quot;JNIHelp.h&quot; #include &quot;android_runtime/AndroidRuntime.h&quot; #include &lt;utils/misc.h&gt; #include &lt;utils/Log.h&gt; #include &lt;hardware/hardware.h&gt; #include &lt;stdio.h&gt; namespace android { static jboolean fingerprint_recordNewFingerprint(JNIEnv* env,jobject clazz){ boolean result = false; /*录取指纹 *...... *result = recordNewFingerprint *...... */ return result; } static jboolean fingerprint_compareFingerprints(JNIEnv* env,jobject clazz){ boolean result = false; /*比对指纹 *...... *result = compareFingerprints *...... */ return result; } static jint fingerprint_init(JNIEnv* env,jobject clazz){ /*进行一些初始化工作 *...... *if(open_success) return (jint) device; *else return 0; *...... */ return 0; } static const JNINativeMethod method_table[] = { {&quot;init_native&quot;,&quot;()I&quot;,(void*)fingerprint_init}, {&quot;recordNewFingerprint_native&quot;,&quot;()Z&quot;,(void*)fingerprint_recordNewFingerprint}, {&quot;compareFingerprints_native&quot;,&quot;()Z&quot;,(void*)fingerprint_compareFingerprints} }; int register_android_server_FingerprintService (JNIEnv* env) { return jniRegisterNativeMethods(env,&quot;com/android/server/FingerprintService&quot;,method_table,NELEM(method_table)); } }; 4. 接着还要在/framewoks/base/services/jni/onload.cpp中增加register_android_server_FingerprintService函数的声明和调用，这样系统加载libandroid_servers模块时，就会调用和实现在onload.cpp文件中的JNI_OnLoad函数。这样，就可以将前面定义的三那个JNI方法注册到Java虚拟机中。namespace android { ...... int register_android_server_FingerprintService(JNIEnv* env); ...... }; using namespace android; extern &quot;C&quot; jint JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env = NULL; jint result = -1; if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) { ALOGE(&quot;GetEnv failed!&quot;); return result; } ALOG_ASSERT(env, &quot;Could not retrieve the env!&quot;); ...... register_android_server_FingerprintService(env); ...... return JNI_VERSION_1_4; } 5. 在系统中启用硬件访问服务，在/framewoks/base/services/java/com/android/server/SystemServer.java的initAndLoop方法中添加public void initAndLoop() { ...... if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) { //if (!disableNonCoreServices) { // TODO: View depends on these; mock them? if (true) { try { Slog.i(TAG, &quot;FingerprintService&quot;); ServiceManager.addService(&quot;FingerprintService&quot;, new FingerprintService()); } catch (Throwable e) { reportWtf(&quot;starting FingerprintService&quot;, e); } } } ...... } 6. 系统层的服务已经添加完毕，接着先make update-api，然后要重新编译整个源码。最终基于源码开发的应用调用这个服务。 IFingerprintService mIFingerprintService = IFingerprintService.Stub.asInterface(ServiceManager.getService(&quot;FingerprintService&quot;)); mIFingerprintService.recordNewFingerprint() THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"NDK开发起步","slug":"2014-12-27-NDKPreview","date":"2014-12-26T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/12/27/2014-12-27-NDKPreview/","link":"","permalink":"http://ai.wisim.me/2014/12/27/2014-12-27-NDKPreview/","excerpt":"Eclipse进行NDK开发HelloWorld步骤（无参数，返回String型）：1.新建一个新的工程 2.在工程目录下新建一个jni文件夹 3.在jni目录下新建一个.c文件，例如我这里新建一个hello.c文件,以及一个.mk文件，内容如下 12345LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := libhelloLOCAL_SRC_FILES := hello.cinclude $(BUILD_SHARED_LIBRARY)","text":"Eclipse进行NDK开发HelloWorld步骤（无参数，返回String型）：1.新建一个新的工程 2.在工程目录下新建一个jni文件夹 3.在jni目录下新建一个.c文件，例如我这里新建一个hello.c文件,以及一个.mk文件，内容如下 12345LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := libhelloLOCAL_SRC_FILES := hello.cinclude $(BUILD_SHARED_LIBRARY) 4.在java代码中加载hello.c,我这里是在MainActivity中加入 1234static &#123; //参数就是刚刚新建的.c文件名 System.loadLibrary(\"hello\");&#125; 5.新建一个用于获取jni内容的方法,注意native关键字，可以通过这个方法在java文件中获取到jni提供的内容 1public native String getJniContent(); 6.编写hello.c文件 1234567#include &lt;string.h&gt;#include &lt;jni.h&gt;jstringJava_com_wxp_testjni_TestJni_getJniContent(JNIEnv* env, jobject thiz) &#123; return (*env)-&gt;NewStringUTF(env, \"Hello NDK !\");&#125; 注意这里的jstring是返回String类型 方法名的命名规则是Java_packagename_classname_methodnameinjava 也就是Java_包名_使用到jni方法的类的名称_在java中定义的方法名，所有的.号都要用下划线代替。例如我这里是在MainActivity中使用到了getJniContent方法，那么.c文件中方法名应该是这样的： Java_com_wxp_testjni_MainActivity_getJniContent 7.在工程目录下执行命令ndk-build,提示生成了.so文件 再看一下工程目录下libs文件夹，确实生存了hello.so文件 8.最后看看用Eclipse运行之后打印出来的结果 上面是生成了一个动态库.so文件，接下来尝试一下生成静态库.a文件 首先在jni目录下新建一个wxpstatic.h文件，用以声明要实现的函数： 1extern int weclome(); 接着新建一个wxpstatic.h文件，实现.h文件中声明的函数： 1234#include \"wxpstatic.h\"int weclome() &#123; return 1024;&#125; 对于我们自己编写的代码来说，如果要在JNI层的.c文件中调用wxpstatic.c中的函数，可以直接通过#include &quot;wxpstatic.h&quot;，然后编写Android.mk文件：123456789101112LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS)LOCAL_MODULE := libwxpstatic LOCAL_SRC_FILES := wxpstatic.cinclude $(BUILD_STATIC_LIBRARY) #注意这里是 BUILD_STATIC_LIBRARYinclude $(CLEAR_VARS)LOCAL_MODULE := wxpjniLOCAL_SRC_FILES := wxpjni.cLOCAL_STATIC_LIBRARIES := libwxpstatic include $(BUILD_SHARED_LIBRARY) 在jni目录下执行ndk-build 如果是要使用第三方的.a文件，要将.a文件以及对应的.h文件拷贝到jni目录下。修改Android.mk文件：123456789101112LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS)LOCAL_MODULE := libwxpstaticLOCAL_SRC_FILES := libwxpstatic.a include $(PREBUILT_STATIC_LIBRARY) #注意这里是 PREBUILT_STATIC_LIBRARYinclude $(CLEAR_VARS)LOCAL_MODULE := wxpjniLOCAL_SRC_FILES := wxpjni.cLOCAL_STATIC_LIBRARIES := libwxpstatic include $(BUILD_SHARED_LIBRARY) 在jni目录下执行ndk-build 然后就可以在JNI层的代码中调用.a中的函数了。 JNI中一些常用方法随笔带int参数，返回int型.java中的方法定义： 1public native int getSum(int a,int b); 传入参数给.c中的方法： 1234jintJava_com_wxp_testjni_TestJni_getSum(JNIEnv* env, jobject thiz,jint a,jint b) &#123; return a+b;//返回两个参数的和&#125; 带int[]参数，返回int型.java中的方法定义： 1public native int getSum(int[] a); 传入参数给.c中的方法： 123456789jintJava_com_wxp_testjni_TestJni_getIntArraySum(JNIEnv* env, jobject thiz,jintArray a) &#123; //获取参数中的int数组 jint *b = (*env)-&gt;GetIntArrayElements(env, a, 0); //获取int数组的长度 jsize a_len = (*env)-&gt;GetArrayLength(env, a); return a_len;&#125; String数组操作：1234//获取String数组jobjectArray *b = (*env)-&gt;GetObjectArrayElement(env, a, 0);//获取String数组长度jsize a_len = (*env)-&gt;GetArrayLength(env, a); 注意使用for循环时： 如果写成这样：123for(int i=0;i&lt;10;i++)&#123; //......&#125; 会下面这个报错： error: ‘for’ loop initial declarations are only allowed in C99 mode 而要写成这种格式则不会：1234int i = 0;for(i=0;i&lt;10;i++)&#123; //......&#125; THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android触摸事件分发流程详细分析","slug":"2014-12-25-AndroidTouchEventAnalysis","date":"2014-12-24T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/12/25/2014-12-25-AndroidTouchEventAnalysis/","link":"","permalink":"http://ai.wisim.me/2014/12/25/2014-12-25-AndroidTouchEventAnalysis/","excerpt":"触摸事件的分发主要涉及到的就是dispatchTouchEvent,onInterceptTouchEvent,onTouchEvent这三个方法。下面通过Log来详细分析一下触摸事件的分发流程,为了更直观的现实事件的分发路径，这里我们将每个方法中都加入Log 1. 首先继承LinearLayout自定义一个 MyChildLayout然后重写它的三个方法 dispatchTouchEvent,onInterceptTouchEvent,onTouchEvent 值得注意的是，onInterceptTouchEvent方法是ViewGroup才有而View没有的 为了详细分析每一步，这里将所有的触摸事件以及相应的方法的返回值全部打印出来","text":"触摸事件的分发主要涉及到的就是dispatchTouchEvent,onInterceptTouchEvent,onTouchEvent这三个方法。下面通过Log来详细分析一下触摸事件的分发流程,为了更直观的现实事件的分发路径，这里我们将每个方法中都加入Log 1. 首先继承LinearLayout自定义一个 MyChildLayout然后重写它的三个方法 dispatchTouchEvent,onInterceptTouchEvent,onTouchEvent 值得注意的是，onInterceptTouchEvent方法是ViewGroup才有而View没有的 为了详细分析每一步，这里将所有的触摸事件以及相应的方法的返回值全部打印出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(\"wxp\", \"mylayout- dispatchTouchEvent : ACTION_DOWN\"); break; case MotionEvent.ACTION_MOVE: Log.e(\"wxp\", \"mylayout- dispatchTouchEvent : ACTION_MOVE\"); break; case MotionEvent.ACTION_UP: Log.e(\"wxp\", \"mylayout- dispatchTouchEvent : ACTION_UP\"); break; case MotionEvent.ACTION_CANCEL: Log.e(\"wxp\", \"mylayout- dispatchTouchEvent : ACTION_CANCEL\"); break; default: break; &#125; //这里默认返回值为 false,也就是事件不分发给自己而分发给子View return super.dispatchTouchEvent(ev);&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; boolean f = false; Log.e(\"wxp\", \"mylayout- onInterceptTouchEvent : \" +f); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(\"wxp\", \"mylayout- onInterceptTouchEvent : ACTION_DOWN\"); break; case MotionEvent.ACTION_MOVE: Log.e(\"wxp\", \"mylayout- onInterceptTouchEvent : ACTION_MOVE\"); break; case MotionEvent.ACTION_UP: Log.e(\"wxp\", \"mylayout- onInterceptTouchEvent : ACTION_UP\"); break; case MotionEvent.ACTION_CANCEL: Log.e(\"wxp\", \"mylayout- onInterceptTouchEvent : ACTION_CANCEL\"); break; default: break; &#125; return f;&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; boolean f = false; Log.e(\"wxp\", \"mylayout- onTouchEvent : true\"); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(\"wxp\", \"mylayout- onTouchEvent : ACTION_DOWN\"); break; case MotionEvent.ACTION_MOVE: Log.e(\"wxp\", \"mylayout- onTouchEvent : ACTION_MOVE\"); break; case MotionEvent.ACTION_UP: Log.e(\"wxp\", \"mylayout- onTouchEvent : ACTION_UP\"); break; case MotionEvent.ACTION_CANCEL: Log.e(\"wxp\", \"mylayout- onTouchEvent : ACTION_CANCEL\"); break; default: break; &#125; return f;&#125; 2. 然后继承Butoon自定义一个 MyButton,并重写它的两个个方法 dispatchTouchEvent,onTouchEventMyButton这两个方法内部的实现和 MyChildLayout 一样，接着只要改变各个方法的返回值，来观察触摸事件的传导路线即可。 3. 布局文件如下12345678910111213141516171819202122&lt;custom.MyLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/id_mylayout\" android:background=\"#056f00\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;custom.MyChildLayout android:id=\"@+id/id_childlayout\" android:background=\"#e00032\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"400dp\"&gt; &lt;custom.MyButton android:background=\"#4d69ff\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:id=\"@+id/id_btn\" android:text=\"Button\" /&gt; &lt;/custom.MyChildLayout&gt;&lt;/custom.MyLayout&gt; 效果图： 绿色部分为顶层父布局,也就是MyLinearLayout，同样是继承LinearLayout，但是这里所有的事件传导都是按照系统的默认值流程执行，我们并不做任何修改。 1234567891011121314151617@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Log.e(\"wxp\", \"MyLayout- onTouchEvent : false\"); return super.onTouchEvent(event);&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.e(\"wxp\", \"MyLayout- onInterceptTouchEvent : false\"); return super.onInterceptTouchEvent(ev);&#125;@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(\"wxp\", \"MyLayout- dispatchTouchEvent : false\"); return super.dispatchTouchEvent(ev);&#125; 红色部分为子布局，也就是MyChildLayout,我们要在这里修改事件的传导过程以观察现象。 蓝色部分是位于子布局中一个MyButton。 准备工作已经完成，下面来实际操作一下 每次操作都是点击蓝色的Button区域 1. 首先，我们将所有方法的返回值均设置成系统默认的返回值，也就是返回相应的父类方法返回值即可。看一下Log ## 这里我们借这个简单的Log来详细阐述一下长按Button这个操作所产生的触摸事件的分发流程。 首先，手指按下，ACTION_DOWN事件由顶层View也就是这里的MyLayout的dispatchTouchEvent的方法来分发，由于这里默认返回的是false，也就是不分发给自己而是继续向下分发。接着onInterceptTouchEvent方法想要拦截这个事件，但是由于系统默认的也是返回false，也就是不拦截。 于是这个ACTION_DOWN事件会分发给它的子View也就是MyChildLayout。由于ViewGroup的dispatchTouchEvent方法默认返回值是false，所以这里也和它的父控件一样，交由onInterceptTouchEvent方法来拦截。同样ViewGroup的onInterceptTouchEvent的默认返回值也是false。所以事件会继续向下分发。 知道分发到最底层的子View，也就是这里的MyButton，由于View的dispatchTouchEvent方法默认返回值为true，所以会将事件分发给自己处理，而不必向下分发。处理这个事件是在onTouchEvent中，而View的onTouchEvent默认返回值为true，也就是默认自己消费这个事件，不必向上传递。 由于我这里是长按Button，所以在ACTION_DOWN触发之后会执行Button的onLongClick方法。自此这个ACTION_DOWN事件传递完毕。 长按之后，将手指抬起，ACTION_UP事件也会按照上述的路线再次分发执行。 最终，ACTION_UP消费完成之后会执行Button的onClick方法。 从这个Log也可以清楚的表明，其实Android的一个触摸事件其实是一个单独的手指操作，例如ACTION_DOWN是一个手指按下事件，ACTION_UP是一个手指抬起事件，而并不像我们日常生活中所理解的点击一下是一个事件。 2. 由于一开始我并没有调用super.dispatchTouchEvent，而是直接将dispatchTouchEvent方法返回true or false。结果产生了一些怪异的分发路径。2.1 不如来看看在MyChildLayout不调用super.dispatchTouchEvent方法的情况下（MyChildLayout中其方法以及其MyButton中的方法均返回默认值）: （1）MyChildLayout dispatchTouchEvent方法 return false; 可以看出，这种情况下，事件虽然会分发，但是并不会执行到 MyChildLayout 的onInterceptTouchEvent方法。也不是分发给子View处理，而是会直接在Activity中的onTouchEvent中消化事件。对于Activity中的onTouchEvent方法来说，无论它的返回值是什么，这都是事件传导的终点。 （2）MyChildLayout 的 dispatchTouchEvent方法 return true; 可以看出，这种情况下，事件不会分发只会限制在 MyChildLayout 的 dispatchTouchEvent方法中直到消失，既不自己处理也不分给子View。Activity也不会处理到。 2.2 再来看看在MyChildLayout调用super.dispatchTouchEvent方法的情况下（MyChildLayout中其方法以及其MyButton中的方法均返回默认值）: (1)比如：一开始我是这样写的 12345public boolean dispatchTouchEvent(MotionEvent ev) &#123; super.dispatchTouchEvent(ev); switch (ev.getAction()) &#123; ... &#125; return false;&#125; 结果发现打出的Log是这样的： 注意图中选中的部分是MyButton- dispatchTouchEvent竟然位于MyLayout- onInterceptTouchEvent的下面 (2)然后我又把super.dispatchTouchEvent(ev)的位置换了一下： 12345public boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; ... &#125; super.dispatchTouchEvent(ev); return false;&#125; 此时我长按Button,打出的Log为： 如果我点击Button，打出的Log为： 可以看出不仅MyButton的onClick方法没有执行到,onLongClick的方法调用的顺序也混乱了。 其实上面这种写法也不能算是错误，但是这样会让事件传导路线发生混乱。如果想要事件按正确的分发路线分发一定要返回super.dispatchTouchEvent(event)，否则会产生一些奇怪的现象。 所以，虽然MyChildLayout的dispatchTouchEvent的返回值也是false，但是对比默认的分发路径，还是有很大的出入。 因此：如果想要拦截一个ViewGroup的事件，不要改变dispatchTouchEvent方法的返回值，可以直接修改onInterceptTouchEvent方法的返回值为true。 接下面我们试着来改变一下事件的分发路线1.CASE 02 : MyChildLayout- onInterceptTouchEvent return true; MyChildLayout- onTouchEvent return super.onTouchEvent(event);//false MyChildLayout中其方法以及其MyButton中的方法均返回默认值. 值得一提的是，和dispatchTouchEvent不同，在这两个方法里不管有没有调用相应的super方法，或者super方法的位置写在哪里，都不会影响事件的分发路线。 来看一下这种情况下的Log： 可以看到MyChildLayout- onInterceptTouchEvent返回true，也就是拦截了事件，交给它自己的onTouchEvent来处理。。因此事件不会分发到MyButton,理所当然Log中也就看不到MyButton的影子了。 但是由于MyChildLayout- onTouchEvent默认返回false，也就是MyChildLayout自己不消化事件，而是向上传递到它的父控件MyLayout。 同样MyLayout默认也是不消化事件，继续向上传递到Activity中。由于Activity中的onTouchEvent默认返回true，所以最终会消化事件。 同时，Activity作为事件传递的顶层，如果返回值为true表示处理了事件；如果返回值为false，事件也不会继续向上传递了，而是自此消失。 2.CASE 02 : MyChildLayout- onInterceptTouchEvent return true; MyChildLayout- onTouchEvent return true; MyChildLayout中其方法以及其MyButton中的方法均返回默认值. 来看一下这种情况下的Log： 同上：MyChildLayout- onInterceptTouchEvent返回true，拦截事件， 由于MyChildLayout- onTouchEvent返回true，也就是自己消化了事件，所以不会向再上传递到了。 3.CASE 03 : MyButton- onTouchEvent return false; MyChildLayout- onTouchEvent return true; MyButton和MyChildLayout中的其他方法均返回默认值. 不如我们先来猜想一下ACTION_DOWN事件的分发路径： 首先从MyLayout中分发到MyChildLayout，再分发到MyButton，由于MyButton-onTouchEvent return false;也就是并未消化事件。 所以事件会向上传递到MyChildLayout的onTouchEvent的方法中，由于这个方法返回了true也就是消化了事件，所以不会再向上传递了。 来看一下这种情况下的Log： 可以看出，ACTION_DOWN的分发路径和我们猜想的是一模一样的。 再来看看ACTION_UP事件。同样是从MyLayout分发下来。但是分发到MyChildLayout时，直接被它的dispatchTouchEvent分发给自己，并交由onTouchEvent处理了。 如果某个触摸事件传递到了某个View(or ViewGroup)的onToucEvent方法，但是它返回了false，那么对于这一次操作（点击或者长按之类的操作）而言，这之后所有的触摸事件都不会再分发给这个View了。 一次操作是从ACTION_DOWN事件开始的，所以每一ACTION_DOWN事件的发生相当于进行了一次初始化，因此onToucEvent方法返回false并不会影响这个View接受下一次的ACTION_DOWN事件。 所以我们再来看一下这个Log，ACTION_DOWN事件传递到了MyButton的onTouchEvent方法中，但是由于这个方法返回了false，所以ACTION_UP事件不会再分发给MyButton了。 4.CASE 04 :我们可以接着上面这个情况，再来进一步说明这种分发方式。 MyButton- onTouchEvent return false; MyChildLayout- onTouchEvent return false; MyButton和MyChildLayout中的其他方法均返回默认值. 看一下这种情况的Log： 选中部分及其上面是ACTION_DOWN的分发流程，下面是ACTION_UP的分发流程。 可以看出，由于MyButton- onTouchEvent return false;MyChildLayout- onTouchEvent return false;而MyLayout的onTouchEvent默认也是返回false。最终ACTION_DOWN事件被 ACtivity消化了。 并且，ACTION_UP事件直接交由Activity处理。 5.CASE 05 :来看看最后一种情况 MyButton- onTouchEvent return false; MyChildLayout- onTouchEvent return false; Activity- onTouchEvent return false; MyButton和MyChildLayout中的其他方法均返回默认值. 这种情况的Log和CASE04的Log是一模一样的： 也就是说，和View以及ViewGroup不同。即使Activity的onTouchEvent方法返回了false，它还是会接受到接下来的触摸事件。 如果MyButton中同时存在 onTouchEvent,onClick以及onLongClick三个方法，并且希望每个方法都能执行到的话 首先，如果已经重写了 dispatchTouchEvent方法，一定要 return super.dispatchTopuchEvent(event);千万不要直接返回 true。 其次，onTouchEvent 方法同样要 return super.onTouchEvent(event);也不能直接返回 true or false。 最后，onLongClick方法要返回false。 如下是长按Button之后的Log： 在上文的分析中其实已经提到了： onLongClick是在ACTION_DOWN之后ACTION_UP之前触发的。 而onClick是在ACTION_UP之后触发的 此外,如果在Activity中为Button设置onClickListener，那么只会执行这里的onClick方法，而不会执行Button内部的onClick方法。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Scroller 实现滑动效果以及下拉操作","slug":"2014-12-23-AndroidScroller","date":"2014-12-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/12/24/2014-12-23-AndroidScroller/","link":"","permalink":"http://ai.wisim.me/2014/12/24/2014-12-23-AndroidScroller/","excerpt":"Scroller对于处理滑动事件有着很大的帮助，有时候可以通过Scoller来实现一些手势操作，并且可以在抬起手指之后仍可平滑的移动到指定位置。和之前介绍的ViewDragHelper类似，Scroller更多的是在自定义的组件当中发挥作用 Scroller 中一些常用的方法 12345678910mScroller.getCurrX() //获取mScroller当前水平滚动的位置 mScroller.getCurrY() //获取mScroller当前竖直滚动的位置 mScroller.getFinalX() //获取mScroller最终要停止的水平位置 mScroller.getFinalY() //获取mScroller最终要停止的竖直位置 mScroller.setFinalX(int newX) //设置mScroller最终停留的水平位置，没有动画效果，直接跳到目标位置 mScroller.setFinalY(int newY) //设置mScroller最终停留的竖直位置，没有动画效果，直接跳到目标位置 //滚动，startX, startY为开始滚动的位置，dx,dy为滚动的偏移量, duration为完成滚动的时间 mScroller.startScroll(int startX, int startY, int dx, int dy) //使用默认完成时间250ms mScroller.startScroll(int startX, int startY, int dx, int dy, int duration)","text":"Scroller对于处理滑动事件有着很大的帮助，有时候可以通过Scoller来实现一些手势操作，并且可以在抬起手指之后仍可平滑的移动到指定位置。和之前介绍的ViewDragHelper类似，Scroller更多的是在自定义的组件当中发挥作用 Scroller 中一些常用的方法 12345678910mScroller.getCurrX() //获取mScroller当前水平滚动的位置 mScroller.getCurrY() //获取mScroller当前竖直滚动的位置 mScroller.getFinalX() //获取mScroller最终要停止的水平位置 mScroller.getFinalY() //获取mScroller最终要停止的竖直位置 mScroller.setFinalX(int newX) //设置mScroller最终停留的水平位置，没有动画效果，直接跳到目标位置 mScroller.setFinalY(int newY) //设置mScroller最终停留的竖直位置，没有动画效果，直接跳到目标位置 //滚动，startX, startY为开始滚动的位置，dx,dy为滚动的偏移量, duration为完成滚动的时间 mScroller.startScroll(int startX, int startY, int dx, int dy) //使用默认完成时间250ms mScroller.startScroll(int startX, int startY, int dx, int dy, int duration) mScroller.computeScrollOffset() //返回值为boolean，true说明滚动尚未完成，false说明滚动已经完成。这是一个很重要的方法，通常放在View.computeScroll()中，用来判断是否滚动是否结束。 另外值得注意的是 scrollTo(int x,int y)以及scrollBy(int x,int y)是View中的方法，而不是Scroller的方法 实现滑动效果 1. 首先我们继承 LinearLayout 实现一个ScrollerLinear类，并且实例化一个Scroller对象12345678910111213141516public class ScrollerLinear extends LienarLayout &#123; private Scroller mScroller = null; public ScrollerLinear(Context context)&#123; this(context,null); &#125; public ScrollerLinear(Context context,AttributeSet attrs) &#123; super(context,attrs); init(context); &#125; public void init (Context context) &#123; mScroller = new Scroller(contex); &#125;&#125; 2. 定义一个方法smoothScrollTo方法供对象调用来实现滑动效果1234567891011121314public void smoothScrollTo(int fx, int fy) &#123; int dx = fx - mScroller.getFinalX(); int dy = fy - mScroller.getFinalY(); Log.e(\"wxp\", \"fx : \" + fx + \" | finalX : \" + mScroller.getFinalX() + \" | curX : \" + mScroller.getCurrX()); smoothScrollBy(dx, dy);&#125;public void smoothScrollBy(int dx,int dy) &#123; //如果要设置滑动持续的时间可以使用方法mScroller.startScroll(int startX, int startY, int dx, int dy, int duration)，设置第五个参数即可 mScroller.startScroll(mScroller.getFinalX(), mScroller.getFinalY(), dx, dy); invalidate();//这里必须调用invalidate()才能保证computeScroll()会被调用，否则不一定会刷新界面，看不到滚动效果&#125; 3. 重写LinearLayout的computeScroll方法12345678public void computeScroll() &#123; if (mScroller.computeScrollOffset) &#123; scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); &#125; //同样，这里也必须调用postInvalidate()方法 postInvalidate(); super.computeScroll();&#125; 4. 在Activity中使用12//注意这里滑动的是mScrollLinear内部的内容而不是他自己。mScrollLinear.scrollTo(-100,-100); 实现下拉操作 这里要介绍另外一个类: GestureDetector 手势侦测器，借助这个类我们可以很方便的处理手势滑动，而不需要自己再去计算相关的位移之类的东西。 首先实例化一个GestureDetector对象 mDetector = new GestureDetector(context,new WxpGestureListener());实现GestureDector.OnGestureLinener接口自定义一个 WxpGestureListener 类,重写它的onDown以及onScrolle方法用于处理滑动操作。1234567891011121314public class WxpGestureListener implements GestureDector.OnGestureListener &#123; @Override public boolean onDown (MotionEvent event) &#123; //注意这个方法一定要返回true才能继续处理后续手势 return true; &#125; @Override public boolean onScroll (MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; //就是要在这个方法里处理滑动操作 smoothScrollBy(0,(int)distanceY); //默认返回false return false; &#125;&#125; 此外，还要重写 LinearLayout 的onTouchEvent方法，将滑动手势操作交由GestureDector处理1234567891011public boolean onTouchEvent(MotionEvent event) &#123; swicth(event.getAction()) &#123; case MotionEvent.ACTION_Up: //抬起手指之后返回初始位置(0,0) smoothScrollTo(0,0); break; default: return mGestureDector.onTouchEvent(event); &#125; return super.onTouchEvent(event);&#125; 效果图如下: THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"ViewDragHelper Preview","slug":"2014-12-22-AndroidViewDragHelper","date":"2014-12-21T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/12/22/2014-12-22-AndroidViewDragHelper/","link":"","permalink":"http://ai.wisim.me/2014/12/22/2014-12-22-AndroidViewDragHelper/","excerpt":"ViewDragHelper对于处理复杂的手势操作有着很大的帮助，这里通过ViewDragHelper来实现一个简单的拖动效果 通常是在自定义ViewGroup中使用ViewDragHelper1. 这里自定义一个LinearLayout1public class MyLayout extends LinearLayout &#123;...&#125; 2.如果想要拖动某个子view，可以在onFinishInflate()方法中通过findViewById来引用这个子view1mDragView = (View) findViewById(R.id.id_view);","text":"ViewDragHelper对于处理复杂的手势操作有着很大的帮助，这里通过ViewDragHelper来实现一个简单的拖动效果 通常是在自定义ViewGroup中使用ViewDragHelper1. 这里自定义一个LinearLayout1public class MyLayout extends LinearLayout &#123;...&#125; 2.如果想要拖动某个子view，可以在onFinishInflate()方法中通过findViewById来引用这个子view1mDragView = (View) findViewById(R.id.id_view); 3.若要实例化一个ViewDragHelper，需要调用ViewDragHelper.create(viewgroup,sensitivity,callback)方法，这里传入的第三个参数就是一个回调接口1ViewDragHelper mDragHeleper = ViewDragHelper.create(this,1.0f,new WxpCallback()); 4.所以要继承ViewDragHelper.Callback实现一个简单的自定义接口WxpCallback1234567891011121314151617181920212223242526272829303132class WxpCallback extends ViewDragHelper.Callback &#123; public boolean tryCaptureView(View view,int arg) &#123; //这里默认返回false，但是只有返回true时，才能拖动 return true; &#125; public onEdgeDragStarted(int edgeFlags,int pointerId) &#123; //mDragView就是要拖动的View mDragHelper.captureChildView(mDragView,pointerId); &#125; /* *实现垂直拖动 */ public int clampViewPositionVertical(View child,int top,int dy) &#123; final int topBound = getPaddingTop(); final int bottomBound = getHeight()-mDragView.getHeight(); final newTop = Math.min(Math.max(top,topBound),bottomBound); return newTop; &#125; /* *实现水平拖动 */ public int clampViewPositionHorizontal(View child,int left,int dx) &#123; final int leftBound = getPaddingLeft(); final int rightBound = getWidth() - mDragView.getWidth(); final newLeft = Math.min(Math.min(left,leftBound)rightBound); return newLeft; &#125;&#125; 5.另外还要重写ViewGrounp的onTouchEvent(event)以及onInterceptTouchEvent(event)方法12345678public boolean onInterceptTouchEvent(MotionEvent event) &#123; return mDragHelper.shouldInterceptTouchEvent(event);&#125;public boolean onTouchEvent(MotionEvent event) &#123; mDragHelper.processToucEvent(event); return true;&#125; 使用在布局文件中，将要拖动的view放在 MyLayout 中 123456789&lt;com.wxp.drag.MyLayout android:layout_width = \"match_parent\" android:layout_height = \"match_parent\" &gt; &lt;View android:id = \"@+id/id_view\" android:layout_width = \"40dp\" android:layout_height = \"40dp\" android:background = \"#6a6a6a\" /&gt;&lt;/com.wxp.drag.MyLayout&gt; THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android 屏幕 dp计算方法","slug":"2014-12-05-AndroidMeasureDP","date":"2014-12-04T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/12/05/2014-12-05-AndroidMeasureDP/","link":"","permalink":"http://ai.wisim.me/2014/12/05/2014-12-05-AndroidMeasureDP/","excerpt":"/res/目录下有时会出现values-sw320dp-hdpi/这样的目录，其实这是为了适配不同分辨率以及PPI而创建的资源。 那目录名中对应的dp值该如何计算呢？ 首先计算设备的PPI,公式如下：","text":"/res/目录下有时会出现values-sw320dp-hdpi/这样的目录，其实这是为了适配不同分辨率以及PPI而创建的资源。 那目录名中对应的dp值该如何计算呢？ 首先计算设备的PPI,公式如下： Android 根据手机ppi 分为 160 240 320 480 根据上述公式算得PPI之后从这几个值中向上取值,比如计算得到PPI为227，那就取240 最后计算设备的dp: dp= 160*(横向px)/ppi 假设计算得到的值为320，那就新建对应的资源目录/res/values-sw320dp/，另外如果是在320dp下： 854x480分辨率对应的应该是：values-sw320dp-hdpi 如果是在360dp下 960x540对应的是：values-sw320dp-hdpi1280x720对应的是：values-sw320dp-xhdpi 这仅是目前常用的一些分辨率 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android触摸事件分发流程图","slug":"2014-12-03-AndroidTouchEvent","date":"2014-12-02T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/12/03/2014-12-03-AndroidTouchEvent/","link":"","permalink":"http://ai.wisim.me/2014/12/03/2014-12-03-AndroidTouchEvent/","excerpt":"dispatchTouchEvent 表示分发事件，这里所说的分发其实是分发给这个View处理，而不是分发给子View 所以如果 dispatchTouchEvent 返回false表示不分发给这个View处理，需要拦截才能给这个View处理；返回true表示分发给这个View处理，而无需拦截。 onInterceptTouchEvent 表示拦截事件 onTouchEvent 是具体的处理事件的方法","text":"dispatchTouchEvent 表示分发事件，这里所说的分发其实是分发给这个View处理，而不是分发给子View 所以如果 dispatchTouchEvent 返回false表示不分发给这个View处理，需要拦截才能给这个View处理；返回true表示分发给这个View处理，而无需拦截。 onInterceptTouchEvent 表示拦截事件 onTouchEvent 是具体的处理事件的方法 一夜无话，按下不表 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android5.0神速模拟器配置","slug":"2014-11-27-AndroidKvm","date":"2014-11-26T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/11/27/2014-11-27-AndroidKvm/","link":"","permalink":"http://ai.wisim.me/2014/11/27/2014-11-27-AndroidKvm/","excerpt":"前言创建模拟器时，如果选择 ARM 类型，模拟器的运行时就会极其卡顿。如果选择 x86 类型，启动时会提示缺少 KVM。KVM是个很炫酷的东西，不过有坑。 1.准备工作：检查CPU是否支持 KVM1$ egrep -o '(vmx|svm)' /proc/cpuinfo 输出下面的信息说明该CPU支持安装KVM： 1vmx","text":"前言创建模拟器时，如果选择 ARM 类型，模拟器的运行时就会极其卡顿。如果选择 x86 类型，启动时会提示缺少 KVM。KVM是个很炫酷的东西，不过有坑。 1.准备工作：检查CPU是否支持 KVM1$ egrep -o '(vmx|svm)' /proc/cpuinfo 输出下面的信息说明该CPU支持安装KVM： 1vmx 2.安装软件：1$ sudo apt-get install qemu-kvm libvirt-bin virt-manager bridge-utils 3.检查是否安装成功：1$ kvm-ok 输出如下结果，表示安装成功： 12INFO: /dev/kvm existsKVM acceleration can be used 如果提示信息为： 12INFO: KVM (vmx) is disabled by your BIOS(KVM [vmx]被你的BIOS禁用)HINT: Enter your BIOS setup and enable Virtualization Technology (VT) 则需要进入的BIOS设置界面，启用虚拟化技术[VT]，设置步骤为： 4. 进入BIOS后，选择ADVANCED，然后至 PROCESSOR CONFIGURATION进去找到 INTEL (R) VIRTUALIZATION TECHNOLOGY ，设置成ENABLE，保存退出 。 验证KVM内核是否加载成功： 1lsmod | grep kvm 输出为： 12kvm_intel 137899 3kvm 455932 1 kvm_intel 5.设置模拟器如图： 6.到这里貌似都结束了，不过开头说了，有坑。看图说话 神器genymotion扑街！并且VM也不能使用了。 那么问题来了，如何解决这个冲突呢。 那就是如果要使用VM或者genymotion，就先关闭Android模拟器。。。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"翻墙教程[失效]","slug":"2014-11-26-OtherWall","date":"2014-11-25T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/11/26/2014-11-26-OtherWall/","link":"","permalink":"http://ai.wisim.me/2014/11/26/2014-11-26-OtherWall/","excerpt":"Windows 下翻墙下载翻墙软件：自由门 如图所示，一键翻墙：","text":"Windows 下翻墙下载翻墙软件：自由门 如图所示，一键翻墙： Android 下翻墙下载翻墙软件：fqrouter2 如图所示，一键翻墙： Ubuntu12.04 下翻墙参考文章：https://github.com/goagent/goagent/blob/wiki/InstallGuide.md Step 1.按照上面的步骤申请 Google App Engine 并创建appid（Application Identifier）等操作。 Step 2.下载goagent,解压到/opt中 step 3.运行gogent客户端,执行命令: 123$ cd /opt/goagent/local$ sudo apt-get insatll python-vte$ sudo ./goagent-gtk.py step 4.上传程序 1$ python uploader.py 按提示输入appid,gamil以及passwd。可能会出现错误，再重新上传。 打开/goagent/local/中的proxy.ini文件，将其中的appid修改为自己申请的appid step 5.配置浏览器 地址栏输入 Chrome://extensions/ 后按回车，打开扩展管理页，直接将 local 文件夹中的 SwitchySharp.crx 拖拽到该页面之后点击确定即可安装。接着导入SwitchySharp的配置文件SwitchyOptions.bak 在浏览器的Menu键旁选择GoAgent模式 step 6.解决SSL错误 下载 CA证书，并保存到/goagent/local/目录下。 在Chrome设置中找到管理证书选项: 导入刚刚下载的证书： THE END.","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://ai.wisim.me/categories/FAQ/"}],"tags":[]},{"title":"Java正则表达式","slug":"2014-10-16-JavaRegularExpression","date":"2014-10-15T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/10/16/2014-10-16-JavaRegularExpression/","link":"","permalink":"http://ai.wisim.me/2014/10/16/2014-10-16-JavaRegularExpression/","excerpt":"Java正则表达式简要笔记","text":"Java正则表达式简要笔记 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.regex.*;/** * 正则表达式 * * @param wxp */public class RegularExpression &#123; public static void p(Object object) &#123; System.out.println(object.toString()); &#125; /** * 匹配以某个字符串开头，任意字符串结尾的一个字符串 * 匹配规则^start.* * 其中.号匹配除\\r和\\n之外的任何单个字符 * 其中*号匹配之前的表达式零次或多次 */ public static void startWith() &#123; boolean flag = false; Pattern pattern = Pattern.compile(\"^android.*\"); Matcher matcher = pattern.matcher(\"android hello\"); flag = matcher.matches(); p(flag); &#125; /** * 以某个符号分割一串字符串 * 匹配规则[,|] * 其中 , 可以换成别的符号 */ public static void splitWith()&#123; Pattern pattern=Pattern.compile(\"[,|]\"); String [] arrays=pattern.split(\"hello,android\"); p(arrays.length); &#125; /** * 替换首次出现的匹配的字符串 * 其中matcher的replaceFirst方法返回的是替换后的整个字符串 */ public static void replaceFisrt()&#123; Pattern pattern=Pattern.compile(\"hello\"); Matcher matcher=pattern.matcher(\"hello android\"); p(matcher.replaceFirst(\"i love\")); &#125; /** * 替换所有匹配的字串 */ public static void replaceAll()&#123; Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World \"); p(matcher.replaceAll(\"Java\")); &#125; /** * 同上 */ public static void replaceAllChar()&#123; Pattern pattern = Pattern.compile(\"正则表达式\"); Matcher matcher = pattern.matcher(\"正则表达式 Hello World,正则表达式 Hello World \"); StringBuffer sbr = new StringBuffer(); while (matcher.find()) &#123; matcher.appendReplacement(sbr, \"Java\"); &#125; matcher.appendTail(sbr); System.out.println(sbr.toString()); &#125; /** *匹配IP地址 *ip地址由四个字节构成,每个字节的值在0到255之间 *其中\\d等价于[0-9],匹配一个数字字符 */ public static void matchIP()&#123; Pattern pattern=Pattern.compile(\"\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\"); Matcher matcher=pattern.matcher(\"192.168.0.1\"); p(matcher.matches()); &#125; /* public static void fontAttri()&#123; String fonfattr=\"&lt;font size=\\\"8\\\"&gt;\"; Pattern fontP=Pattern.compile(\"&lt;\\\\s*font\\\\s+([^&gt;]*)\\\\s*&gt;\"); Pattern attrP=Pattern.compile(\"([a-z]+)/s*=/s*\\\"([^\\\"]+)\\\"\"); Matcher matcher=fontP.matcher(fonfattr); p(matcher.matches()); &#125; */ /* *匹配邮箱 *CASE_INSENSITIVE表示不分大小写 *其中\\w匹配任意字符包括下划线 */ public static void matchEmail()&#123; String mail=\"wxp2014android@163.com\"; Pattern pattern=Pattern.compile(\"[\\\\w\\\\.\\\\-]+@([\\\\w\\\\-]+\\\\.)+[\\\\w\\\\-]+\",Pattern.CASE_INSENSITIVE); Matcher matcher=pattern.matcher(mail); p(matcher.matches()); &#125; public static void main(String[] args) &#123; //matchIP(); matchEmail(); &#125;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://ai.wisim.me/categories/JAVA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ai.wisim.me/tags/Java/"},{"name":"Regex","slug":"Regex","permalink":"http://ai.wisim.me/tags/Regex/"}]},{"title":"自定义View-浮动标签","slug":"2014-10-08-AndroidFloatTag","date":"2014-10-07T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/10/08/2014-10-08-AndroidFloatTag/","link":"","permalink":"http://ai.wisim.me/2014/10/08/2014-10-08-AndroidFloatTag/","excerpt":"1.继承LinearLayout自定义一个FloatTag类有如下几个成员变量 1234567891011121314151617181920212223Context mContext;/* * 放置内容，可以滑动的父布局 */ScrollView mScrollView;/* * 显示和隐藏的视图 */View mFloatTagView;/* * 控制显示或隐藏 mFloatTagView 的回调接口 */StayViewListener mStayViewListener;/* * 首次进入页面，应该是向上滑动，直到到达 mFloatTagView 的位置 * 设置一个标记，未到达时mScrollUp为true，mFloatTagView 是隐藏状态， * 到达之后mScrollUp为false， mFloatTagView 是可见状态 */ boolean mScrollUp = true;","text":"1.继承LinearLayout自定义一个FloatTag类有如下几个成员变量 1234567891011121314151617181920212223Context mContext;/* * 放置内容，可以滑动的父布局 */ScrollView mScrollView;/* * 显示和隐藏的视图 */View mFloatTagView;/* * 控制显示或隐藏 mFloatTagView 的回调接口 */StayViewListener mStayViewListener;/* * 首次进入页面，应该是向上滑动，直到到达 mFloatTagView 的位置 * 设置一个标记，未到达时mScrollUp为true，mFloatTagView 是隐藏状态， * 到达之后mScrollUp为false， mFloatTagView 是可见状态 */ boolean mScrollUp = true; 2.进行一些初始化工作1234567 //在构造方法中调用init()方法public void init(ScrollView scrollView,View floatTagView,FloatTagStateListener listener)&#123; this.mScrollView=scrollView; this.mFloatTagView=floatTagView; this.mFloatTagStateListener=listener; setOrientation(LinearLayout.VERTICAL);&#125; 3.重写computeScroll()方法 其中mScrollView.getScrollY()得到的数值是mScrollView的纵坐标距离初始原点的纵坐标（也就是0）的距离。所以，如果是网上滑动的话，这个数值会一直增大；如果向下滑动的话，这个数值会减小。而mFloatTagView.getTop()的到的是布局中固定的标签的上边缘的纵坐标，这个纵坐标是一个固定值，也就是mFloatTagView距离mScrollView顶部的距离。所以，只要mScrollView向上滑动的距离等于mFloatTagView.getTop()这个值的时候，就是mFloatTagView滑动到屏幕顶部的时候，这个时候就要把布局文件中隐藏的标签头显示出来。 12345678910111213141516171819202122@Override public void computeScroll() &#123; if(mFloatTagView!=null&amp;&amp;mScrollView!=null&amp;&amp;mStayViewListener!=null)&#123; int y = mScrollView.getScrollY(); if(up)&#123; int top = mFloatTagView.getTop(); if(y&gt;=top)&#123; //如果向上滑动到mFloatTagView的顶端则调用mStayViewListener的显示浮动标签的方法 mStayViewListener.onStayViewShow(); up = false; &#125; &#125; if(!up)&#123; int bottom = mFloatTagView.getBottom(); if(y&lt;=mFloatTagView.getTop())&#123; //如果向下滑动到stayView的顶端则调用mStayViewListener的隐藏浮动标签的方法 mStayViewListener.onStayViewGone(); up = true; &#125; &#125; &#125; &#125; 4.定义一个接口供外部使用OrderView时显示或隐藏浮动标签1234public interface FloatTagStateListener&#123; public void onFloatTagShow(); public void onFloatTagHide();&#125; 5.使用5.1 定义主布局文件中activity_main.xml 布局文件中id为id_btn_tag的View是一直显示的，就是通过得到他的上边缘坐标与mScrollView滑动距离相比较，来控制id为id_btn_float_tag的View的隐藏和显示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\" &gt; &lt;com.wxp.floattag.FloatTag android:id=\"@+id/id_ft_floattag\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;ScrollView android:id=\"@+id/id_sv_mainscrolleview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" &gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"200px\" android:src=\"@drawable/ic_launcher\" /&gt; &lt;Button android:id=\"@+id/id_btn_tag\" android:background=\"#000000\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"float_tag\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/hello_world\" /&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"2000px\" android:src=\"@drawable/ic_launcher\" /&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; &lt;/com.wxp.floattag.FloatTag&gt; &lt;Button android:id=\"@+id/id_btn_float_tag\" android:visibility=\"gone\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"#000000\" android:text=\"float_tag\" /&gt;&lt;/RelativeLayout&gt; 5.2 MainActivity.java 要在FloatTagStateListener接口的两个回调方法中控制布局文件中标签头的隐藏和显示 123456789101112131415/* * 注意：这里的第二个参数的View是固定显示的，而下面控制隐藏和显示的是另一个id为id_btn_float_tag的View */mFloatTag.init(mScrollView, findViewById(R.id.id_btn_tag), new FloatTagStateListener() &#123;@Overridepublic void onFloatTagShow() &#123; findViewById(R.id.id_btn_float_tag).setVisibility(View.VISIBLE);&#125;@Overridepublic void onFloatTagHide() &#123; findViewById(R.id.id_btn_float_tag).setVisibility(View.GONE);&#125;&#125;); 效果图: github：https://github.com/whisper92/FloatTag.git THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Ubuntu12.04系统安装和Anroid系统源码编译环境配置","slug":"2014-09-25-UbuntuUbuntu12.04Install","date":"2014-09-24T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/09/25/2014-09-25-UbuntuUbuntu12.04Install/","link":"","permalink":"http://ai.wisim.me/2014/09/25/2014-09-25-UbuntuUbuntu12.04Install/","excerpt":"准备工作： 1.备份当前系统的文件 2.导出xp虚拟机的虚拟介质，以便安装12.04之后直接恢复 一：USB启动盘制作 1.拷贝服务器上的安装镜像ubuntu-12.04-desktop-amd64.iso到本地 2.插入Ｕ盘 3.Ubuntu系统中打开 系统－系统管理－启动盘制作器 4.选择第１步中拷贝的镜像，并选择第２步中插入的Ｕ盘 5.格式化掉U盘后，点击制作就可以了","text":"准备工作： 1.备份当前系统的文件 2.导出xp虚拟机的虚拟介质，以便安装12.04之后直接恢复 一：USB启动盘制作 1.拷贝服务器上的安装镜像ubuntu-12.04-desktop-amd64.iso到本地 2.插入Ｕ盘 3.Ubuntu系统中打开 系统－系统管理－启动盘制作器 4.选择第１步中拷贝的镜像，并选择第２步中插入的Ｕ盘 5.格式化掉U盘后，点击制作就可以了 二：系统安装 1.插入Ｕ盘开机，在开机界面按F12进入启动菜单，选择U盘启动 2.进入安装界面，如果选择自定义的话，可以参考如下磁盘分配 (1)./分区，50G,方便以后重装系统 (2).SWAP分区，物理内存的2倍就行。可以先分一个分区出来，在文件系统选项里面选择swap (3).剩下的单独做一个分区，待系统安装完成后，格式化并配置自动挂载 3.安装完成后，拔掉U盘重启 三：环境配置 (1)激活root账户 A.在终端中，执行 sudo passwd root B.根据提示，输入密码，以及root账户的密码，可以一样，也可以不同 C.(12.04需要此步骤开启root账户登录) sudo gedit /etc/lightdm/lightdm.conf 在文件中添加下面这两行 greeter-show-manual-login=true allow-guest=false 另外还要检查系统设置中的自动登录，关闭自动登录选项 (2)点击屏幕右上角的电源图标，选择注销，并以root帐户登录 (3)JDK 拷贝jdk-6u32-linux-x64.bin到/usr/lib/jvm分区中 赋予可执行权限 chmod u+x jdk-6u32-linux-x64.bin 在终端中执行 ./jdk-6u32-linux-x64.bin 将JDK相关的命令配置到环境变量中 A.打开/etc/environment, gedit /etc/environment B.在Path末尾添加jdk的路径 PATH=”/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/lib/jvm/jdk1.6.0_32/bin” C.保存并退出 D.在终端执行 source /etc/environment E.然后就是要告诉系统，我们使用的sun的JDK，而非OpenJDK了： $ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.6.0_32/bin/java 300 $ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.6.0_32/bin/javac 300 $ sudo update-alternatives --config java E.敲入java -version看是否有相应输出 (4)交叉编译器 拷贝arm-eabi-4.4.3到/opt分区中 给该文件夹中的相关文件赋权限 chmod u+x -R arm-eabi-4.4.3/ 将arm 相关的命令配置到环境变量中 A.gedit /etc/environment B.Path末尾添加arm-eabi的路径 PATH=”/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/lib/jvm/jdk1.6.0_32/bin:/opt/arm-eabi-4.4.3/bin:/opt/arm-eabi-4.4.3/arm-eabi/bin” C.保存并退出 D.在终端执行 source /etc/environment E.这一步需要重启，可以稍后安装完成之后再重启 (5).gawk的安装(82以后的需要) A.拷贝gawk-4.1.0.tar.7z到/opt目录 B.chmod u+x -R gawk-4.1.0/ C.右键选择后，解压到此处 D.进入解压后的目录，依次执行如下命令 123./configuremakemake install (6)虚拟机安装及配置 A.拷贝VirtualBox-4.3.8-92456-Linux_amd64.run到/opt目录 B.chmod u+x VirtualBox-4.3.8-92456-Linux_amd64.run C. ./VirtualBox-4.3.8-92456-Linux_amd64.run D.打开虚拟机软件 1231.选择“新建”,根据提示输入该虚拟机的名字，内存大小，XP给512M就可以了，2.选择硬盘时，选择已存在的硬盘，即已经拷贝过来的XP_NEW.vdi3.之后就可以直接开机了 E.Notes已经安装好，参照桌面中的文档完成配置即可 (7)编译相关 以下过程需要联网 apt-get install build-essential libc6-dev-i386 lib32ncurses5-dev ia32-libs x11proto-core-dev libx11-dev lib32z-dev lib32readline-gplv2-dev gnupg tofrodos flex bison gperf zip curl zlib1g-dev git-core gcc-4.4 g++-4.4 g++-4.4-multilib wine mingw32 libxml2-utils (8)切换gcc版本 ls /usr/bin/gcc* /usr/bin/gcc /usr/bin/gcc-4.6 /usr/bin/gcc-4.4 增加gcc4.6和gcc4.4的可选项 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.6 46 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.4 44 如果没有第一句的话，也能行。但是系统默认的4.6版本的GCC就不能使用了。为了以后能用得着，还是加上第一句。 切换版本到gcc-4.4 $ update-alternatives --config gcc There are 2 choices for the alternative gcc (providing /usr/bin/gcc). 选择 路径 优先级 状态 ------------------------------------------------------------ * 0 /usr/bin/gcc-4.6 46 自动模式 1 /usr/bin/gcc-4.4 44 手动模式 输入1即可 其他问题(1)修复root用户音量问题 gedit /etc/default/pulseaudio 修改： PULSEAUDIO_SYSTEM_START=1 DISALLOW_MODULE_LOADING=0 将root加到pulse和pulse-access组： sudo usermod -a -G pulse-access root gpasswd -a root pulse gpasswd -a root pulse-access (2)编译如果报这个错的话：/bin/bash: xmllint: 未找到命令,终端输入： sudo apt-get install libxml2-utils (3)访问nbtemp 打开一个文件夹并全屏，顶部栏-&gt;转到-&gt;位置在文件位置处输入: smb://192.168.50.150/nbbsw_temp/ 依次三个选项为：93218—&gt;NBBD—&gt; home (4)git账户配置 git config --global user.name whisper git config --global user.email whisper@nbbsw.com git config --list (5)取消gedit创建备份文件 菜单-编辑-首选项-编辑器：在保存前创建备份文件前面的勾去掉 (6)修改文件的默认打开方式： gedit /etc/gnome/defaults.list gedit ~/.local/share/applications/mimeapps.list 在这两个文件中修改默认打开方式 (7)解决Ubuntu默认播放器无法播放视频的问题： 下载这个文件gstreamer0.10-ffmpeg_0.10.13-5_amd64.deb并手动安装即可。 (8)Ubuntu Chrome不能以根用户启动 在/usr/share/applications/checkbox-qt.desktop的快捷图标上右键，点击属性，修改命令属性，在后面加上 -user-data-dir 就OK了。 (9)解决vim无法安装问题 在/etc/apt/sources.list中添加deb http://cz.archive.ubuntu.com/ubuntu lucid main 12$ sudo apt-get update$ sudo apt-get install vim THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://ai.wisim.me/tags/Ubuntu/"}]},{"title":"Make a .9.png","slug":"2014-09-23-AndroidDraw.9png","date":"2014-09-22T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/09/23/2014-09-23-AndroidDraw.9png/","link":"","permalink":"http://ai.wisim.me/2014/09/23/2014-09-23-AndroidDraw.9png/","excerpt":".9.png is so MAGICAL and How to Make a .9.png Step 1:make a circle in photoshop like this:Picture-1:circle.png Step 2:run draw9patch.sh in sdk/tools/open the circle.png,then draw four line at the border,like this: Picture-2:draw9patch.png","text":".9.png is so MAGICAL and How to Make a .9.png Step 1:make a circle in photoshop like this:Picture-1:circle.png Step 2:run draw9patch.sh in sdk/tools/open the circle.png,then draw four line at the border,like this: Picture-2:draw9patch.png REAMRKS: 1234Top Line:stretch the place below it when horizonal drawing;Left Line:stretch the place at the right of the line when vertical drawing;Right Line:show the content at the left of the line when vertival drawing;Bottom Line:show the content above it when horizontal drawing; Step 3:use the .9.png in project: &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;pull&quot; android:id=&quot;@+id/puu_head&quot; android:gravity=&quot;center&quot; android:background=&quot;@drawable/ic&quot;/&gt; then the final effect like this: Picture-3:9effect.png And more remarkable,to be effective only use the attribute android:background.If you set the .9.png as android:src ,there is no effect unfortunately. THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Markdown Priview","slug":"2014-09-22-OtherMarkdown","date":"2014-09-21T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/09/22/2014-09-22-OtherMarkdown/","link":"","permalink":"http://ai.wisim.me/2014/09/22/2014-09-22-OtherMarkdown/","excerpt":"Markdown语法简要介绍以及SublimText的一些快捷方式 我最近已经转投 Atom了哈哈，因为Atom支持实时预览Markdown。 Markdown SummaryTitle use # to mark the title,eg:# First Page First Page List use - to mark the ul,eg:- item item1 item2 use directly 1. to mark the ol,eg:1.first item first item secondary item third item Code","text":"Markdown语法简要介绍以及SublimText的一些快捷方式 我最近已经转投 Atom了哈哈，因为Atom支持实时预览Markdown。 Markdown SummaryTitle use # to mark the title,eg:# First Page First Page List use - to mark the ul,eg:- item item1 item2 use directly 1. to mark the ol,eg:1.first item first item secondary item third item Code use &lt;code&gt; to mark a line code,eg:&lt;code&gt;$ git status&lt;/code&gt; $ git status use ` to mark a few words,eg:`i am a monkey` i am a monkey In Additionif you want to insert a ` at someplace,you can use: like this `` ` `` Reference use &gt; to to mark a reference line,eg:&gt;i love u i love u Linkeg:[whisper](whisper92.github.io) whisper Imageeg:![Image](http://whisperlog.qiniudn.com/w.png) Sublime Text set shortcut key using preiview .md in browser Preferences-&gt;Key Bindings-User { &quot;keys&quot;: [&quot;ctrl+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: { &quot;target&quot;: &quot;browser&quot;} } goto line Ctrl+G goto a file Ctrl+P goto a function Ctrl+P @ 主要快捷键列表： Ctrl+L 选择整行（按住-继续选择下行） Ctrl+KK 从光标处删除至行尾 Ctrl+Shift+K 删除整行 Ctrl+Shift+D 复制光标所在整行，插入在该行之前 Ctrl+J 合并行（已选择需要合并的多行时） Ctrl+KU 改为大写 Ctrl+KL 改为小写 Ctrl+D 选词 （按住-继续选择下个相同的字符串） Ctrl+M 光标移动至括号内开始或结束的位置 Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号） Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果） Ctrl+Shift+/ 注释已选择内容 Ctrl+Z 撤销 Ctrl+Y 恢复撤销 Ctrl+M 光标跳至对应的括号 Alt+. 闭合当前标签 Ctrl+Shift+A 选择光标位置父标签对儿 Ctrl+Shift+[ 折叠代码 Ctrl+Shift+] 展开代码 Ctrl+KT 折叠属性 Ctrl+K0 展开所有 Ctrl+U 软撤销 Ctrl+T 词互换 Tab 缩进 自动完成 Shift+Tab 去除缩进 Ctrl+Shift+↑ 与上行互换 Ctrl+Shift+↓ 与下行互换 Ctrl+K Backspace 从光标处删除至行首 Ctrl+Enter 光标后插入行 Ctrl+Shift+Enter 光标前插入行 THE END.","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://ai.wisim.me/categories/FAQ/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://ai.wisim.me/tags/Markdown/"}]},{"title":"桌面插件AppWidget深入理解-基于系统音乐播放器的桌面音乐插件","slug":"2014-08-24-AndroidWidgetDeep","date":"2014-08-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/08/24/2014-08-24-AndroidWidgetDeep/","link":"","permalink":"http://ai.wisim.me/2014/08/24/2014-08-24-AndroidWidgetDeep/","excerpt":"光有一个空壳不行，桌面插件必须要有后台的应用程序为它提供内容和服务，这样才能真正让桌面插件发挥它的优势。 1.首先来分析AppWidgetProvider中关于插件生命周期的几个方法 值得注意的是只有在onReceive(Context context, Intent intent)使用父类的onReceive方法： 123public void onReceive(Context context,Intent intent) &#123; super.onReceive(context,intent);&#125;","text":"光有一个空壳不行，桌面插件必须要有后台的应用程序为它提供内容和服务，这样才能真正让桌面插件发挥它的优势。 1.首先来分析AppWidgetProvider中关于插件生命周期的几个方法 值得注意的是只有在onReceive(Context context, Intent intent)使用父类的onReceive方法： 123public void onReceive(Context context,Intent intent) &#123; super.onReceive(context,intent);&#125; 之后如下所述的几个方法才能被成功调用，否则无效 。 public void onEnable(Context context):第一个插件添加到桌面时会调用此方法。 public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds):每向桌面添加一个插件都会调用此方法。 public void onDeleted(Context context, int[] appWidgetIds):每删除一个插件，都会调用此方法。 public void onDisabled(Context context):最后一个插件删除之后会调用此方法。 2. 另外，从Manifest.xml文件中对于WppWidgetProvider的注册就知道它本质上是一个广播接收器：12345678&lt;receiver android:name=\"com.wxp.made.MediaProvider\"&gt; &lt;intent-filter &gt; &lt;action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\"/&gt; &lt;action android:name=\"com.android.music.playstabloganged\"/&gt; &lt;action android:name=\"com.android.music.metachanged\"/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=\"android.appwidget.provider\" android:resource=\"@xml/appwidget_info\"/&gt; &lt;/receiver&gt; 所以对于音乐插件的基本思路就有了：后台播放服务每当播放或者暂停音乐时都会发送一个广播，这个广播包含了当前音乐的所有信息：播放状态（播放or暂停），作者，歌曲名，专辑名等等。只要在AppWidgetProvider中接收这个广播就可以相应的更新桌面插件的界面。如上两个就是音乐播放器放送的广播的Action，playstabloganged表示音乐播发状态的变化，metachangde表示歌曲信息的变化。 在onReceive方法中实现接收到广播之后立即更新界面的功能： 123456789101112@Overridepublic void onReceive(Context context, Intent intent) &#123; super.onReceive(context, intent); playData=(ApplicationData)context.getApplicationContext(); if(intent.getExtras()!=null)&#123; if (intent.getExtras().getLong(\"id\")!=0) &#123; bundle =intent.getExtras(); playData.setBundle(bundle); updateViews(context, bundle); &#125; &#125;&#125; 代码中playData.setBundle(bundle);用于保存当前播放音乐的信息，以便用户多次添加插件时能够正确更新桌面插件。因此在更新方法中可以直接调用已经保存了的Bundle 12345678@Overridepublic void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; playData=(ApplicationData)context.getApplicationContext(); if(playData.getBundle()!=null)&#123; updateViews(context, playData.getBundle()); &#125;&#125; 3.因为只有在播放或者暂停音乐后台服务才会发送广播，所以仅靠接收广播来判断是否有音乐在播放还不能完全解决问题。比如正在播放音乐时，用户向桌面添加了第一个插件，由于此时并未触发播放/暂停事件，也就不会发送广播，所以插件并不会接收到广播而更新界面。因此需要在onEnabled方法中开启一个新的服务来调用远程服务以获取当前音乐的状态。12Intent intent=new Intent(context, EnableService.class);context.startService(intent); 在EnableService中会使用AIDL来获取后台播放服务的一些接口 关于AIDL的使用不再赘述,可参照另一篇文章:Service初探-AIDL简单实现 在ServiceConnection的onServiceConnected方法中获取到音乐信息在再封装成bundle并发送一个广播以便插件更新界面。 123456789101112131415161718192021try &#123; boolean mplaying = mIMediaPlaybackService.isPlaying(); Long mauid=mIMediaPlaybackService.getAudioId(); String mtrack=mIMediaPlaybackService.getTrackName(); String malbum=mIMediaPlaybackService.getAlbumName(); String martist=mIMediaPlaybackService.getArtistName(); Bundle bundle=new Bundle(); bundle.putLong(\"id\", mauid); bundle.putBoolean(\"playing\", mplaying); bundle.putString(\"track\", mtrack); bundle.putString(\"album\", malbum); bundle.putString(\"artist\", martist); Intent intent=new Intent(\"com.android.music.metachanged\"); intent.putExtras(bundle); sendBroadcast(intent);&#125; catch (RemoteException e) &#123; e.printStackTrace();&#125; 4.而桌面插件触发音乐播放或者暂停事件的功能则需要通过RemoteView和PendingIntent来实现,代码如下：123456public static final String TOGGLEPAUSE_ACTION = \"com.android.music.musicservicecommand.togglepause\";ComponentName serviceName=new ComponentName(\"com.android.music\",\"com.android.music.MediaPlaybackService\");Intent intent= new Intent(TOGGLEPAUSE_ACTION);intent.setComponent(serviceName);PendingIntent pendingIntent= PendingIntent.getService(context, 0 /* no requestCode */, intent, 0 /* no flag */);RemoteViews views.setOnClickPendingIntent(R.id.control_play, pendingIntent); THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"桌面插件AppWidget初探","slug":"2014-08-15-AndroidWidgetPreview","date":"2014-08-14T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/08/15/2014-08-15-AndroidWidgetPreview/","link":"","permalink":"http://ai.wisim.me/2014/08/15/2014-08-15-AndroidWidgetPreview/","excerpt":"解析一个最基本的桌面插件的构成 1.Widget的配置文件，在/res/xml/目录下新建music_provider.xml文件123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\" android:minWidth=\"260dip\" android:minHeight=\"40dip\" android:initialLayout=\"@layout/music_layout\"&gt;&lt;/appwidget-provider&gt;","text":"解析一个最基本的桌面插件的构成 1.Widget的配置文件，在/res/xml/目录下新建music_provider.xml文件123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\" android:minWidth=\"260dip\" android:minHeight=\"40dip\" android:initialLayout=\"@layout/music_layout\"&gt;&lt;/appwidget-provider&gt; 2.Widget的布局文件 /res/layout/music_layout.xml 3.配置Manifest.xml12345678&lt;receiver android:name=\"com.wxp.widget.MusicWidgetProvider\" android:label=\"@string/app_name\"&gt; &lt;intent-filter android:name=\"android.appwidget.action.APPWIDGET_UPDATE&gt; &lt;/intent-filter&gt; &lt;mata-data android:name=\"android.appwidget.provider\" android:resource=\"@xml/music_provider\" /&gt;&lt;/receiver&gt; 4.主类MusicProvider继承AppWidgetProvider THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"BroadcastReceiver 的简单使用","slug":"2014-08-08-AndroidBroadcastReceiverPreview","date":"2014-08-07T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/08/08/2014-08-08-AndroidBroadcastReceiverPreview/","link":"","permalink":"http://ai.wisim.me/2014/08/08/2014-08-08-AndroidBroadcastReceiverPreview/","excerpt":"和 Activity 以及 Service 一样，BroadcastReceiver同属Android的四大组件。 有时候用 BroadcastReceiver 可以轻易解决很纠结的问题。 1.继承BroadcastReceiver实现一个广播接受者MyReceiver可以重写onReceive(Context context,Intent intent)方法,在方法里面通过intent.getExtras()方法获取intenet中传递过来的数据","text":"和 Activity 以及 Service 一样，BroadcastReceiver同属Android的四大组件。 有时候用 BroadcastReceiver 可以轻易解决很纠结的问题。 1.继承BroadcastReceiver实现一个广播接受者MyReceiver可以重写onReceive(Context context,Intent intent)方法,在方法里面通过intent.getExtras()方法获取intenet中传递过来的数据 2.注册广播,有两种方式(1).动态广播：通过context中的registerRecier方法来注册 123MyReceiver myReceiver=new MyReceiver();IntentFilter intentFilter=new IntentFilter(\"com.wxp.receiver.MyReceiver\");registerReceiver(myReceiver,intentFilter); 对于动态广播来说，如果Context被销毁时记得要注销广播： 123if(myReceiver!=null) &#123; unregisterReceiver(myReceiver);&#125; (2).静态广播：在AndroidManifest.xml文件中注册 12345&lt;receiver android:name=\".MyReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.wxp.receiver.MyReceiver\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 3.发送广播1234Intent intent =new Intent();intent.setAction(\"com.wxp.receiver.MyReceiver\");intent.putExtra(\"msg\",\"send by broadcast\");sendBroadcast(intent); THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Activity任务栈以及启动方式","slug":"2014-08-08-AndroidActivityLauncherMode","date":"2014-08-07T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/08/08/2014-08-08-AndroidActivityLauncherMode/","link":"","permalink":"http://ai.wisim.me/2014/08/08/2014-08-08-AndroidActivityLauncherMode/","excerpt":"简单介绍一下Task:Task是一个具有栈结构的对象，一个Task可以管理多个Activity，启动一个应用也就创建了一个与之对应的task。 首先假设在当前Activity中启动自身 123Intent intent=new Intent();intent.setClass(MainActivity.this,MainAcicity.class);startActivity(intent);","text":"简单介绍一下Task:Task是一个具有栈结构的对象，一个Task可以管理多个Activity，启动一个应用也就创建了一个与之对应的task。 首先假设在当前Activity中启动自身 123Intent intent=new Intent();intent.setClass(MainActivity.this,MainAcicity.class);startActivity(intent); Activity的启动模式一共有四种：1.standard： 无需设置,是默认的启动模式。在上述代码的情况下，不管有没有已经存在的实例，都会生成新的实例。但是这种模式并不会使用新的Task。只有按下返回键（即结束当前Activity）才会回到上一个Activity。 2.singleTop: 在上述代码的情况下，如果当前Task只有一个Activity在其中，那启动Activty时并不产生新的实例，启动的还是当前自身。如果按下返回键就会立即退出程序（因为Task中只有当前这一个Activity）。 如果当前Task有多个Activity在其中，只有在栈顶的Activity才会重复使用，也就时说如果要启动的Activity并不在栈顶，系统就会创建新的Activity实例并加载到栈顶（此时就与standard模式相同）。 举个例子：比如说想要Activity的启动顺序是A-B-C-D-D-D，如果D的launcherMode设置为singleTop,那么最终的启动顺序其实是A-B-C-D，也就是重复利用了栈顶的ActivityD。 3.singleTask: 如果要启动的Activity不存在，则创建新的实例并加到栈顶。 如果要启动的Activity已经位于栈顶，则与singleTop模式相同。 如果要启动的Activity已经存在于栈中，则会弹出这个Activty上面的所有其他Activty，使此Activity变为栈顶对象，显示到屏幕前。 举个例子：比如说想要Activity的启动顺序是A-B-C-D-A，如果A的launcherMode设置为singleTask，那么最终任务栈中只会剩下A,位于A上面的BCD都会被回收。 4.singleInstance: 首先要要注意的是采用singleInstance模式加载的Activity总是位于栈顶，并且该栈只包含这一个Activity。 如果要启动的Activity不存在，则首先创建一个新的Task，再创建目标Activity实例，并加入栈顶。 如果要启动的Activty已经存在，则无论它位于那个应用程序中，无论位于哪个Task中，系统都会把该Activity所在的Task转到前台并显示Acitivty。 有三种启动新的任务栈的方式：第一种： 动作(Action)设置为“android.intent.action.MAIN”，类别(category)设置为“android.intent.category.LAUNCHER”， 可以使这个Activity(ACT)实例称为一个任务栈的入口，拥有这种类型的intent-filter的Activity类型的图表和名字也会显示在application launcher中。 第二种： activity的launchMode采用“singleInstance”模式，另外开个一个唯一Activity的栈. 第三种： 在Intent中加入了“FLAG_ACTIVITY_NEW_TASK”。 当传递给startActivity()的Intent对象包含FLAG_ACTIVITY_NEW_TASK标记时，系统会为需要启动的activity寻找与当前activity不同的task。如果要启动的activity的affinity属性与当前所有的task的affinity属性都不相同，系统会新建一个带那个affinity属性的task，并将要启动的activity压到新建的task栈中；否则将activity压入那个affinity属性相同的栈中 taskAffinity属性：字符串取值，在一个命名空间里唯一。这个属性在以下2中情况下起作用： 1.当启动一个Activity的Intent包含了FLAG_ACTIVITY_NEW_TASK标识. 在默认情况下，新建一个Activity，会调用startActivity()方法进入Task当中。它放置到和启动它的Activity相同的back stack。但是，如果启动的Intent包含了FLAG_ACTIVITY_NEW_TASK标识，系统将为这个Activity寻找一个不同的Task。通常是新建一个新的Task。但是也未必全是这样，如果存在一与之相同taskAffinity定义的Task，那么这个Activity将运行在那里，否则新建Task。 2.当一个Activity的属性allowTaskReparenting设置为true时. 举个例子说明这个属性的作用：假设一个选择城市查看天气的Activity是一个旅游应用程序的一部分。这个Activity与这个应用中的其他Activity有相同affinity,并且设置了这个属性为true。当你的其他Activity启动这个查看天气的Activity时，它和你的Activity属于同一个Task。但是，当你的旅游应用程序再次展现在前端时，这个查看天气的Activity会重新分配到旅游应用程序的Task中，并显示天气情况。 清理任务栈有四种情形：情形一： 也是Android系统默认的情形，如果一个任务栈在很长的一段时间都被用户保持在后台的，那么系统就会将这个任务栈中除了根Activity以外的其它所有ACT全部清除掉。当用户再将任务栈切换到前台，则只能显示根activity了。 情形二： 使用alwaysRetainTaskState属性，如果将根ACT的alwaysRetainTaskState属性设置为“true”，则即便一个任务栈在很长的一段时间都被用户保持在后台的，系统也不会对这个任务栈进行清理。 情形三： 使用clearTaskOnLaunch属性，如果将根ACT的clearTaskOnLaunch属性设置为“true”，那么只要这个任务栈切换到了后台，那么系统就会将这个任务栈中除了根ACT以外的其它所有ACT全部清除掉。即和alwaysRetainTaskState的行为完全相反。 情形四： 使用finishOnTaskLaunch属性，这个属性的行为类似于clearTaskOnLaunch，但是此属性作用于单个的ACT对象，而不是整个任务栈。当这个任务栈切换到了后台，这个属性可以使任务栈清理包括根ACT在内的任何ACT对象。 跟 Task 有关的 Intent对象中设置的Flag1.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 如果设置，新的Activity不会在最近启动的Activity的列表中保存。 2.FLAG_ACTIVITY_FORWARD_RESULT 如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的Activity。 3.FLAG_ACTIVITY_NO_HISTORY 如果设置，新的Activity将不再历史stack中保留。用户一离开它，这个Activity就关闭了。这也可以通过设置noHistory特性。 4.FLAG_ACTIVITY_REORDER_TO_FRONT 如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。 例如，假设一个Task由四个Activity组成：A,B,C,D。如果D调用startActivity()来启动ActivityB，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。 5.FLAG_ACTIVITY_NEW_TASK 如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的Activity）定义了用户可以迁移的Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。 这个标志一般用于呈现“启动”类型的行为：它们提供用户一系列可以单独完成的事情，与启动它们的Activity完全无关。使用这个标志，如果正在启动的Activity的Task已经在运行的话，那么，新的Activity将不会启动；代替的，当前Task会简单的移入前台。参考FLAG_ACTIVITY_MULTIPLE_TASK标志，可以禁用这一行为。这个标志不能用于调用方对已经启动的Activity请求结果。 6.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 如果设置，这将在Task的Activity stack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。 这在你的程序有分割点的时候很有用。例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。 7.FLAG_ACTIVITY_CLEAR_TOP 如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。 例如，假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。上例中正在运行的Activity B既可以在onNewIntent()中接收到这个新的Intent，也可以把自己关闭然后重新启动来接收这个Intent。如果它的启动模式声明为“multiple”(默认值)，并且你没有在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，那么它将关闭然后重新创建；对于其它的启动模式，或者在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，都将把这个Intent投递到当前这个实例的onNewIntent()中。 这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。 参考文章： http://blog.csdn.net/ghj1976/article/details/6371549 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"自定义View-SwitchButton","slug":"2014-06-30-AndroidSwitchbutton","date":"2014-06-29T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/06/30/2014-06-30-AndroidSwitchbutton/","link":"","permalink":"http://ai.wisim.me/2014/06/30/2014-06-30-AndroidSwitchbutton/","excerpt":"系统自带的（5.0之前的）switch 实在是不好看，实际需求是要有一种直观的 开和关 的感受。下面就通过自定义view来实现一个炫酷的SwicthButton 0. 继承View实现OnTouchListener接口1234567891011121314151617181920public class Blog_SwitchButton extends View implements OnTouchListener &#123; private Bitmap bg_on, bg_off, slipper_btn; // 按下时的x和当前的x private float downX, nowX; // 记录用户是否在滑动 private boolean onSlip = false; // 当前的状态ON / OFF private boolean nowStatus = false; // 监听接口 private OnChangedListener listener; // 两个构造函数 public Blog_SwitchButton(Context context) &#123; super(context); init();&#125;public Blog_SwitchButton(Context context, AttributeSet attrs) &#123; super(context, attrs); init();&#125;","text":"系统自带的（5.0之前的）switch 实在是不好看，实际需求是要有一种直观的 开和关 的感受。下面就通过自定义view来实现一个炫酷的SwicthButton 0. 继承View实现OnTouchListener接口1234567891011121314151617181920public class Blog_SwitchButton extends View implements OnTouchListener &#123; private Bitmap bg_on, bg_off, slipper_btn; // 按下时的x和当前的x private float downX, nowX; // 记录用户是否在滑动 private boolean onSlip = false; // 当前的状态ON / OFF private boolean nowStatus = false; // 监听接口 private OnChangedListener listener; // 两个构造函数 public Blog_SwitchButton(Context context) &#123; super(context); init();&#125;public Blog_SwitchButton(Context context, AttributeSet attrs) &#123; super(context, attrs); init();&#125; 1.初始化函数，用于解析图片，以及设置监听1234567public void init() &#123; // 载入图片资源 bg_on = BitmapFactory.decodeResource(getResources(), R.drawable.on); bg_off = BitmapFactory.decodeResource(getResources(), R.drawable.off); slipper_btn = BitmapFactory.decodeResource(getResources(),R.drawable.btn); setOnTouchListener(this);&#125; 2.重写onDraw方法，绘制视图123456789101112131415161718192021222324252627282930313233343536protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Matrix matrix = new Matrix(); Paint paint = new Paint(); float x = 0; // 根据nowX设置背景，开或者关状态 if (nowX &lt; (bg_on.getWidth() / 2)) &#123; canvas.drawBitmap(bg_off, matrix, paint);// 画出关闭时的背景 &#125; else &#123; canvas.drawBitmap(bg_on, matrix, paint);// 画出打开时的背景 &#125; if (onSlip) &#123;// 是否是在滑动状态, if (nowX &gt;= bg_on.getWidth())&#123;// 是否划出指定范围,不能让滑块跑到外头,必须做这个判断 x = bg_on.getWidth() - slipper_btn.getWidth() / 2;// 减去滑块1/2的长度 &#125; else &#123; x = nowX - slipper_btn.getWidth() / 2; &#125; &#125; else &#123; if (nowStatus) &#123;// 根据当前的状态设置滑块的x值 x = bg_on.getWidth() - slipper_btn.getWidth(); &#125; else &#123; x = 0; &#125;&#125;// 对滑块滑动进行异常处理，不能让滑块出界if (x &lt; 0) &#123; x = 0;&#125; else if (x &gt; bg_on.getWidth() - slipper_btn.getWidth()) &#123; x = bg_on.getWidth() - slipper_btn.getWidth();&#125;// 画出滑块canvas.drawBitmap(slipper_btn, x, 0, paint);&#125; 3.重写onTouch方法用于处理用户到触摸事件12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; // 当用户按下时 case MotionEvent.ACTION_DOWN: &#123; if (event.getX() &gt; bg_off.getWidth()|| event.getY() &gt; bg_off.getHeight()) &#123; //如果在控件的范围之外则不处理 return false; &#125; else &#123; //如果在控件的范围之内，则设置为滑动状态 onSlip = true; downX = event.getX(); nowX = downX; &#125; break; //当用户滑动按钮时 case MotionEvent.ACTION_MOVE: &#123; nowX = event.getX(); break; &#125; //当用户抬起手指时 case MotionEvent.ACTION_UP: &#123; onSlip = false; if (event.getX() &gt;= (bg_on.getWidth() / 2)) &#123; //如果按钮此时在右侧，则为ON状态把nowState设置为true，并且要把按钮归到右侧到位置 nowStatus = true; nowX = bg_on.getWidth() - slipper_btn.getWidth(); &#125; else &#123; //如果按钮此时在左侧，则为OFF状态，按钮的位置为0 nowStatus = false; nowX = 0; &#125; if (listener != null) &#123; listener.OnChanged(Blog_SwitchButton.this, nowStatus); &#125; break; &#125; // 每次用户产生触摸事件之后都要刷新界面，重新绘制视图 invalidate(); return true;&#125; 4.定义一个回调接口.为WiperSwitch设置一个监听，供外部调用的方法1234567public interface OnChangedListener &#123; //在外部实现这个方法，可以在这个方法内部处理一些逻辑业务 public void OnChanged(Blog_SwitchButton wiperSwitch, boolean checkState);&#125;public void setOnChangedListener(OnChangedListener listener) &#123; this.listener = listener;&#125; 5.设置滑动开关的初始状态，供外部调用12345678public void setChecked(boolean checked) &#123; if (checked) &#123; nowX = bg_off.getWidth(); &#125; else &#123; nowX = 0; &#125; nowStatus = checked;&#125; 效果图如下: THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android 使用Viewpager实现主界面的不同页面之间的切换","slug":"2014-06-17-AndroidViewPager","date":"2014-06-16T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/06/17/2014-06-17-AndroidViewPager/","link":"","permalink":"http://ai.wisim.me/2014/06/17/2014-06-17-AndroidViewPager/","excerpt":"一个主界面上可以通过左右滑动来切换不同的子页面这种布局在Android应用开发中还是经常碰到的。 下面就通过Viewpager来实现这种效果","text":"一个主界面上可以通过左右滑动来切换不同的子页面这种布局在Android应用开发中还是经常碰到的。 下面就通过Viewpager来实现这种效果 1.主界面布局文件，底部是三个图片用于指示当前位置，主体部分是一个ViewPager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/secxml\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:background=\"#eee\" android:orientation=\"vertical\" &gt; &lt;RelativeLayout android:id=\"@+id/sec_bottom\" android:layout_width=\"match_parent\" android:layout_height=\"55dp\" android:layout_alignParentBottom=\"true\" android:background=\"@drawable/bottom_bar\" android:orientation=\"vertical\" &gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:paddingBottom=\"2dp\" &gt; &lt;LinearLayout android:id=\"@+id/secshow1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:gravity=\"center_horizontal\" android:orientation=\"vertical\" &gt; &lt;ImageView android:id=\"@+id/img_address\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:adjustViewBounds=\"false\" android:clickable=\"true\" android:scaleType=\"matrix\" android:src=\"@drawable/tab_address_pressed\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:text=\"头条\" android:textColor=\"#fff\" android:textSize=\"10sp\" /&gt; &lt;/LinearLayout&gt; &lt;!--第二张图片布局如上--&gt; &lt;!--第三张图片布局如上--&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/sec_bottom\" android:layout_alignParentTop=\"true\" android:orientation=\"vertical\" &gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/sectap\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" &gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 2.还有另外三个用于不同页面的布局文件3.为底部的指示图片添加监听事件，使得点击某一图片即可切换到对应的页面123456789public class MyOnClickListener implements View.OnClickListener &#123; private int index = 0; public MyOnClickListener(int i) &#123; index = i; &#125; public void onClick(View v) &#123; mTabPager.setCurrentItem(index); &#125;&#125; 4.通过LayoutInflater找到三个页面，并将他们存入一个ArrayList中1234final ArrayList&lt;View&gt; views = new ArrayList&lt;View&gt;();views.add(view1);views.add(view2);views.add(view3); 5.定义一个PagerAdapter 并设置主体部分ViewPager的Adapter1234567891011121314151617181920PagerAdapter mPagerAdapter = new PagerAdapter() &#123; public boolean isViewFromObject(View arg0, Object arg1) &#123; return arg0 == arg1;&#125;public int getCount() &#123; return views.size();&#125;public void destroyItem(View container, int position, Object object) &#123; ((ViewPager) container).removeView(views.get(position));&#125;public Object instantiateItem(View container, int position) &#123; ((ViewPager) container).addView(views.get(position)); return views.get(position);&#125;&#125;;mTabPager.setAdapter(mPagerAdapter); 6.页面切换监听事件1234567891011121314151617181920212223mTabPager.setOnPageChangeListener(new MyOnPageChangeListener()); //当滑动切换页面时，底部的指示图片会随之变化 public class MyOnPageChangeListener implements OnPageChangeListener &#123; public void onPageSelected(int arg0) &#123; switch (arg0) &#123; case 0: mTab1.setImageDrawable(getResources().getDrawable(R.drawable.tab_address_pressed)); mTab2.setImageDrawable(getResources().getDrawable(R.drawable.tab_find_frd_normal)); mTab3.setImageDrawable(getResources().getDrawable(R.drawable.tab_settings_normal)); break; case 1: //第二张图片设为高亮 break; case 2: //第三张图片设为高亮 break; &#125; &#125; public void onPageScrolled(int arg0, float arg1, int arg2) &#123;&#125; public void onPageScrollStateChanged(int arg0) &#123;&#125;&#125; 效果图如下： THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"TextView实现圆角矩形背景","slug":"2014-06-15-AndroidTextViewRoundBg","date":"2014-06-14T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/06/15/2014-06-15-AndroidTextViewRoundBg/","link":"","permalink":"http://ai.wisim.me/2014/06/15/2014-06-15-AndroidTextViewRoundBg/","excerpt":"简单实现带圆角矩形背景图片的TextView 1.在drawable中放置两张带有圆角的背景图片一张是正常状态下的背景tv_bg_normal.9.png,另一张是按下时的背景图片tv_bg_pressed.9.png.","text":"简单实现带圆角矩形背景图片的TextView 1.在drawable中放置两张带有圆角的背景图片一张是正常状态下的背景tv_bg_normal.9.png,另一张是按下时的背景图片tv_bg_pressed.9.png. 2.在drawable新建一个文件pre_bg.xml123456789101112131415&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_enabled=\"true\" android:state_selected=\"true\" android:drawable=\"@drawable/tv_bg_pressed\" /&gt; &lt;item android:state_enabled=\"true\" android:state_pressed=\"true\" android:drawable=\"@drawable/tv_bg_pressed\"/&gt; &lt;item android:drawable=\"@drawable/tv_bg_normal\"/&gt;&lt;/selector&gt; 3.设置TextView的属性12android:background=\"@drawable/pre_bg\"android:clickable=\"true\" THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android数据库 Sqlite 操作","slug":"2014-06-05-AndroidSlqite","date":"2014-06-04T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/06/05/2014-06-05-AndroidSlqite/","link":"","permalink":"http://ai.wisim.me/2014/06/05/2014-06-05-AndroidSlqite/","excerpt":"数据库在Android应用开发中扮演重要的角色，对于一下小型配置数据可以直接用SharedPreference解决，但是如果涉及到大量复杂结构数据的持久化操作，那就离不开Sqlite了 1. 继承SQLiteOpenHelper实现一个子类DBhelper2. 在类中定义要新建的数据库名、表名以及新建表的sql语句123private static final String DB_NAME=\"timo.db\";private static final String TBL_NAME=\"users\";String CREATE_TBL=\" create table users(_no integer primary key autoincrement,id text,name text,avatar text,atype txt) \";","text":"数据库在Android应用开发中扮演重要的角色，对于一下小型配置数据可以直接用SharedPreference解决，但是如果涉及到大量复杂结构数据的持久化操作，那就离不开Sqlite了 1. 继承SQLiteOpenHelper实现一个子类DBhelper2. 在类中定义要新建的数据库名、表名以及新建表的sql语句123private static final String DB_NAME=\"timo.db\";private static final String TBL_NAME=\"users\";String CREATE_TBL=\" create table users(_no integer primary key autoincrement,id text,name text,avatar text,atype txt) \"; 3. 构造函数1234public DBhelper(Context c)&#123; super(c,DB_NAME,null,2);&#125; 4. 重写onCreate方法，在其中执行新建表到sql语句12345public void onCreate(SQLiteDatabase db)&#123; this.db=db; db.execSQL(CREATE_TBL);&#125; 5. 定义增删查改到方法 插入数据 123456public void insert(ContentValues values)&#123; SQLiteDatabase db=getWritableDatabase(); db.insert(TBL_NAME,null,values); db.close&#125; 查询数据 12345public Cursor queryCursor()&#123; SQLiteDatabase db = getWritableDatabase(); Cursor c = db.query(TBL_NAME, null, null, null, null, null, null); return c;&#125; 通常我们是将查询到的数据转换成List 12345678910111213141516public List&lt;BeanUser&gt; queryList() &#123; ArrayList&lt;BeanUser&gt; Records = new ArrayList&lt;BeanUser&gt;(); Cursor c = queryCursor(); if (c.moveToFirst()) &#123; while (c.moveToNext()) &#123; BeanUser Record = new BeanUser(); Record.userId = c.getString(c.getColumnIndex(\"id\")); Record.userName = c.getString(c.getColumnIndex(\"name\")); Record.headUrl = c.getString(c.getColumnIndex(\"avatar\")); Record.accountType = c.getString(c.getColumnIndex(\"atype\")); Records.add(Record); &#125; &#125; c.close(); return Records;&#125; 删除数据 123456public void delete(String id)&#123; if (db == null) db = getWritableDatabase(); db.delete(TBL_NAME, \"id=?\", new String[] &#123; String.valueOf(id) &#125;);&#125; 附录:adb的常用命令 1.获取手机的权限 adb shell su 2.使用sqlite3 sqlite3 timo.db 3.查看当前数据库的所有表 .table 接着就可以使用sql语句操作数据了 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"Sqlite","slug":"Sqlite","permalink":"http://ai.wisim.me/tags/Sqlite/"}]},{"title":"自定义View-IndexSideBar","slug":"2014-05-27-AndroidSideIndexBar","date":"2014-05-26T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/05/27/2014-05-27-AndroidSideIndexBar/","link":"","permalink":"http://ai.wisim.me/2014/05/27/2014-05-27-AndroidSideIndexBar/","excerpt":"在一些联系人以及国家列表中经常会使用侧边栏字母导航来进行快速索引 如何自定义一个侧边栏字母导航（IndexSideBar）哩？","text":"在一些联系人以及国家列表中经常会使用侧边栏字母导航来进行快速索引 如何自定义一个侧边栏字母导航（IndexSideBar）哩？ 在继承View实现一个子类IndexSideBar1.定义用于导航的字母数组 String[] index = { &quot;#&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;,&quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot; };//省略剩下的字母 2.重写onDraw(Canvas cavas)方法，在里面绘制侧边栏导航条 12345678910111213141516171819202122public void onDraw(Canvas canvas)&#123; //获取IndexSideBar的宽度和高度 int width=getWidth(); int height=getHeight(); //获取单个字母所占的高度 int singleHeight=height/index.length; //循环绘制每一个字母 for(int i=0;i&lt;index.length;i++) &#123; if(i==choose) &#123; paint.setFakeBoldText(true);//如果某个字母是被选中则字体加粗 &#125; /*字母所在的位置的相对x坐标应该是IndexSideBar的宽度的一半减去字体宽度的一半*/ float xPos=width/2-paint.measureText(index[i])/2; float yPos=singleHeight*(i+1); canvas.drawText(index[i],xPos,yPos,paint); paint.rest(); &#125;&#125; 3.重写dispatchTouchEvent实现监听事件的判断 123456789101112131415161718192021222324252627public void dispatchTouchEvent(MotionEvent event)&#123; //获取当前点击时间的纵坐标 float y =event.getY(); //如果是滑动时，用于记录上次选中的位置 int oldchoose=choose; //根据纵坐标的位置判断索引所在的次序 int c=y/getHeight()*index.length; switch(event.getAction) &#123; case:MOTIONEVENT.ACTION_UP: //如果是抬起状态则设置一个正常的背景色 setBackgroud(normal_color); choose=-1；//每次抬起之后选中的位置都要归为未选状态，即-1 invalidate(); break; default: //如果是其他状态（点击或者滑动），则设置另一个背景色 setBackground(another_color); if(oldchoose!=c) &#123; /*如果选中位置发生了变化*/ choose=c; invalidate(); &#125; break; &#125;&#125; 4.在IndexListView中定义回调接口 123456public interface OnTouchChangeListener&#123; public void onTouchChange(String index);&#125;public void setOnTouchChangeListener(OnTouchChangeListener onTouchChangeListener)&#123; this.onTouchChangeListerner = onTouchChangeListerner;&#125; 使用IndexListView直接在布局文件中加入标签&lt;com.wxp.custom.view.IndexSideBar /&gt; 如果要监听Index的改变事件，在Activity中 123456indexSideBar.setOnTouchChangeListener(new OnTouchChangeListener()&#123; public void onTouchChange(String s)&#123; int index = adapter.getPosition(String.valueOf(s.toUpperCase().charAt(0))); listView.setSelection(index); &#125;&#125;); 或者可以为Activity实现OnTouchChangeListener接口; THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"SAE笔记","slug":"2014-05-24-OtherSAENote","date":"2014-05-23T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/05/24/2014-05-24-OtherSAENote/","link":"","permalink":"http://ai.wisim.me/2014/05/24/2014-05-24-OtherSAENote/","excerpt":"连接数据库连主库link=mysql_connect(SAE_MYSQL_HOST_M.&#39;:&#39;.SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); 连从库link=mysql_connect(SAE_MYSQL_HOST_S.&#39;:&#39;.SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); if($link) { mysql_select_db(SAE_MYSQL_DB,$link); //your code goes here }","text":"连接数据库连主库link=mysql_connect(SAE_MYSQL_HOST_M.&#39;:&#39;.SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); 连从库link=mysql_connect(SAE_MYSQL_HOST_S.&#39;:&#39;.SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); if($link) { mysql_select_db(SAE_MYSQL_DB,$link); //your code goes here } 查询操作验证用户名和密码1234567sql = \"SELECT * FROM admin WHERE id = '$id' and pass='$pass'\";res = mysql_query($sql);rows=mysql_num_rows($res);if($rows)&#123; header(\"refresh:0;url=/timo.html\");//跳转页面，注意路径 exit;&#125; 以json形式输出查询结果12345678910111213141516171819$query = mysql_query($sql);$result = mysql_fetch_array($query) or die(\"\");$rows=mysql_num_rows($query);if($rows)&#123; while($result = mysql_fetch_array($query))&#123; $array = array( 'id'=&gt;$result['id'], 'created'=&gt;$result['created'], 'description'=&gt;$result['description'], 'mime_type'=&gt;$result['mime_type'], 'name'=&gt;$result['name'], 'relative_path_cache'=&gt;$result['relative_path_cache'], 'relative_url_cache'=&gt;$result['relative_url_cache'], 'img_rl'=&gt;$URL.$result['relative_path_cache'].\"&amp;\".$result['created'] ); echo json_encode($array); &#125;&#125; 分页查询//起始行,要查询的行数 $sql = &quot;SELECT id,created,description,mime_type,name,relative_path_cache,relative_url_cache FROM g3_items LIMIT &quot;.$q_start.&quot;,11&quot;; 数据请求POSTPOST通常用于表单提交，参数以及参数值不会显示在url中。通过如下方式获取POST参数值： $q_rows = $_POST[&#39;rows&#39;]; GETGET通过url携带参数的方式请求数据。通过如下方式获取GET参数值： $q_name = $_GET[&#39;name&#39;]; THE END.","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://ai.wisim.me/categories/FAQ/"}],"tags":[{"name":"SAE","slug":"SAE","permalink":"http://ai.wisim.me/tags/SAE/"}]},{"title":"Service初探","slug":"2014-05-16-AndroidServicePreview","date":"2014-05-15T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/05/16/2014-05-16-AndroidServicePreview/","link":"","permalink":"http://ai.wisim.me/2014/05/16/2014-05-16-AndroidServicePreview/","excerpt":"可以说service能够使应用程序更有”内涵”，而不仅仅是在几个Activity之间来回跳转。service看起来比Activity要复杂一点，其实仔细研究一下还是值得的。 startService方法启动service实现要素:1.继承Service实现一个子类MyService,并在AndroidManifest.xml中注册 2.intent.setClass(this,MyService.class); 3.startService(intent);","text":"可以说service能够使应用程序更有”内涵”，而不仅仅是在几个Activity之间来回跳转。service看起来比Activity要复杂一点，其实仔细研究一下还是值得的。 startService方法启动service实现要素:1.继承Service实现一个子类MyService,并在AndroidManifest.xml中注册 2.intent.setClass(this,MyService.class); 3.startService(intent); bindService方式启动service,并与Activity进行数据交互实现要素:1.同样继承Service实现一个子类MyService,并在MyService中定义一个MyBinder继承自Binder。 然后在MyService中实例化一个MyBinder对象myBinder。 另外，可以在MyBinder中自定义方法getMessage()用于向Activity返回数据123public String getMessage()&#123; return \"I am from Service.Binder\";&#125; 2.在MyService中重写onBind方法并返回上述的myBinder对象 123public IBinder onBind(Intent intent) &#123; return mBinder;&#125; 3.在activity中实例化一个ServiceConnection对象mServiceConnection。并且在它的onServiceConnected方法中实现Activty与Service的数据交互： 1234public void onServiceConnected(ComponentName name, IBinder service) &#123; myBinder=(MyService.MyBinder)service; mSring=myBinder.getMessage();&#125; 4.要在AndroidManifest.xml文件中注册Service: &lt;service android:name=&quot;com.wxp.service.MyService&quot;&gt;&lt;/servce&gt; 5.启动service 12Intent intent=new Intent(this.MyService.class);bindService(mIntent,mServiceConnection,Context.BIND_AUTO_CREATE); 向Service传递数据例如，我们在一个BroadcastReceiver中想要向Service传递数据:12345public void onReceive(Context context,Intent intent) &#123; Intent gointent = new Intent(context, MyService.class); gointent.putExtra(\"info\", true); context.startService(gointent);&#125; 因为通过startService方法启动service，只有第一次会执行onCreate方法，如果service已经存在，以后只会重新执行onStart方法，所以这里要重写Service的onStart方法：123public void onStart(Intent intent, int startId) &#123; screenOn = intent.getBooleanExtra(\"info\", false);&#125; 这样每次接受到广播之后都会向Service中发送数据了 创建一个带有通知栏提醒的service在MyService的onCreate方法中加入 12345Notification notification = new Notification(R.drawable.ic_launcher, \"有通知到来\", System.currentTimeMillis()); Intent notificationIntent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0); notification.setLatestEventInfo(this, \"这是通知的标题\", \"这是通知的内容\",pendingIntent); startForeground(1, notification); 这样每次启动service时通知栏都会出现提醒。 注意:如果是startService启动，则stopService会关闭通知栏提醒 如果是bindService启动，则unbindService会关闭通知栏提醒 值得注意的是 service是运行在主线程，但是可以在onStartCommand()方法中开启一个新的线程执行耗时任务。也可以在MyBinder中定义的startDownload()方法中开启新线程。 AIDL简单实现服务端1.在com.wxp.aidl下新建一个aidl文件ServerAidl.aidl，注意aidl中定义的接口不能加访问权限修饰符。 123interface ServerAidl &#123; String getMessage();//自定义的方法&#125; 2.在com.wxp.aidl包下创建一个新的服务MyService.java，在MyService内部定义一个MyAidl类继承ServerAidl.Stub，并实现ServerAidl接口中定义的getMessage方法。 1234pubic class MyAidl extends ServerAidl.Stub &#123; public String getMessage() &#123;return \"i am from service\";&#125;&#125; 3.重写MyService的onBind方法，在onBind方法中返回实现一个myAidl对象 123public IBinder onBind(Intent intent) &#123; return new MyAidl();&#125; 4.在Manifest.xml中注册MyService 123456&lt;service android:name=\"com.wxp.aidl.ServerAidl\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.wxp.aidl.MyService\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 客户端1.首先要新建一个和服务器端一样的包名，即com.wxp.adil。并且将服务器端的ServerAidl.aidl文件同时复制过来。不过我实验了一下，好像不这样做也还是可以实现的啊。 2.在Activity中实例化一个ServiceConnection对象mServiceConnection,并重写它的onServiceConnected方法。 12345678ServiceConnection mServiceConnection=new ServiceConnection()&#123; public void onServiceConnected(ComponentName comName,IBinder ibinder)&#123; mIBinder=ServerAidl.Stub.asInterface(ibinder); &#125; public void onServiceDisconnected(ComponentName name) &#123; mIBinder=null; &#125;&#125; 3.接着就可以通过bindService（intent,mServiceConnection.Context.BIND_AUTO_CREATE);方法启动服务了。 值得注意的是，不能直接在bindService之后立刻调用mIBinder.getMessage()。 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Android-Universal-Image-Loader异步加载图片框架","slug":"2014-04-30-AndroidUniversalImageLoad","date":"2014-04-29T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/04/30/2014-04-30-AndroidUniversalImageLoad/","link":"","permalink":"http://ai.wisim.me/2014/04/30/2014-04-30-AndroidUniversalImageLoad/","excerpt":"简单介绍 Android-Universal-Image-Loader 这个框架的配置及使用 项目下载地址：Android-Universal-Image-Loader 导入universal-image-loader-1.9.1.jar到你的项目基本配置","text":"简单介绍 Android-Universal-Image-Loader 这个框架的配置及使用 项目下载地址：Android-Universal-Image-Loader 导入universal-image-loader-1.9.1.jar到你的项目基本配置 在AndroidManifest.xml文件中加入访问权限 12&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 继承Application实现一个子类MyApplication,并且在AndroidManif.xml的Application标签中使用MyApplication 12345678910111213141516171819public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // This configuration tuning is custom. You can tune every option, you may tune some of them, // or you can create default configuration by // ImageLoaderConfiguration.createDefault(this); // method. ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext()) .threadPriority(Thread.NORM_PRIORITY - 2) .denyCacheImageMultipleSizesInMemory() .discCacheFileNameGenerator(new Md5FileNameGenerator()) .tasksProcessingOrder(QueueProcessingType.LIFO) .enableLogging() // Not necessary in common .build(); //Initialize ImageLoader with configuration ImageLoader.getInstance().init(config); &#125;&#125; 使用:加载单个图片ImageLoader.getInstance().displayImage(imgUrl,headImageView); THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"PopupWindow概要","slug":"2014-04-28-AndroidPopupWindowPriview","date":"2014-04-27T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/04/28/2014-04-28-AndroidPopupWindowPriview/","link":"","permalink":"http://ai.wisim.me/2014/04/28/2014-04-28-AndroidPopupWindowPriview/","excerpt":"PopupWindow常用来代替Dialog做一些提示性或供用户选择的操作，在开发中还是经常遇到的。实现要素0.继承PopupWindow的一个子类 1.popwindow的布局文件 2.在MainActivity中使用 3.上下出入的动画","text":"PopupWindow常用来代替Dialog做一些提示性或供用户选择的操作，在开发中还是经常遇到的。实现要素0.继承PopupWindow的一个子类 1.popwindow的布局文件 2.在MainActivity中使用 3.上下出入的动画 0.继承PopupWindow实现它的一个子类PopWindow123456789101112131415161718public class PopWindow extends PopupWindow&#123; View popView; public PopWindow(Context context,OnClickListener itemOnClickListener)&#123; super(context); LayoutInflater inflater=(LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); popView=inflater.inflate(R.layout.pop, null); this.setContentView(popView); //设置PopupWindow弹出窗体的宽 this.setWidth(LayoutParams.FILL_PARENT); //设置PopupWindow弹出窗体的高 this.setHeight(LayoutParams.WRAP_CONTENT); //设置PopupWindow弹出窗体可点击 this.setFocusable(true); //设置PopupWindow的出入动画 this.setAnimationStyle(R.style.PopupAnimation); &#125;&#125; 1.上下出入动画在values文件夹下的styles.xml文件中定义一个包含进出动画效果的style 123456&lt;resource&gt; &lt;style name=\"PopupAnimation\" parent=\"android:Animation\"&gt; &lt;item name=\"android:windowEnterAnimation\"&gt;@anim/push_bottom_in&lt;/item&gt; &lt;item name=\"android:windowExitAnimation\"&gt;@anim/push_bottom_out&lt;/item&gt; &lt;/style&gt;&lt;/resource&gt; 在anim文件夹下实现进出动画效果的xml文件 向上渐现滑入式：push_bottom_in.xml 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;translate android:duration=\"200\" android:fromYDelta=\"100%p\" android:toYDelta=\"0\"/&gt; &lt;alpha android:fromAlpha=\"0.0\" android:toAlpha=\"1.0\" android:duration=\"200\"/&gt;&lt;/set&gt; 向下渐隐滑出式：push_bottom_out.xml 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;translate android:duration=\"200\" android:fromYDelta=\"0\" android:toYDelta=\"50%p\" /&gt; &lt;alpha android:fromAlpha=\"1.0\" android:toAlpha=\"0.0\" android:duration=\"200\"/&gt;&lt;/set&gt; 2.popwindow的布局文件 注意高度使用wrap_content 12345678910111213141516171819&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" &gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" &gt; &lt;Button android:id=\"@+id/confirm\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"confirm\" /&gt; &lt;Button android:id=\"@+id/cancle\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"cancle\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 3.在MainActivity中实例化一个PopWindow并设置它的位置popWindow.showAtLocation(MainActivity.this.findViewById(R.id.main), Gravity.BOTTOM|Gravity.CENTER_HORIZONTAL, 0, 0); THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"AndroidListView加载不同布局的思路","slug":"2014-04-25-AndroidListViewLayout","date":"2014-04-24T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/04/25/2014-04-25-AndroidListViewLayout/","link":"","permalink":"http://ai.wisim.me/2014/04/25/2014-04-25-AndroidListViewLayout/","excerpt":"使用ListView时，对于不同的数据要使用不用的布局来展示，那如何创建并夹在这些不同的布局呢？ 实现要素1.首先有多个对应不同Item的不同的布局文件 2.在Adapter中构造多个对应的Holder 3.注意在Adapter中要重写以下两个方法","text":"使用ListView时，对于不同的数据要使用不用的布局来展示，那如何创建并夹在这些不同的布局呢？ 实现要素1.首先有多个对应不同Item的不同的布局文件 2.在Adapter中构造多个对应的Holder 3.注意在Adapter中要重写以下两个方法 123456789public int getItemViewType(int position)&#123;//此处根据positon获取item，再获取item的type，并返回&#125;public int getViewTypeCount()&#123;// 返回listview中的item个数 return listview.getCount();&#125; 4.重写getView方法 1234567891011121314151617181920212223242526272829303132333435public View getView(int position, View convertView, ViewGroup viewgroup)&#123; UpdateStatusHolder holder_UpdateStatus = null; ShareStatusHolder holder_ShareStatus = null; if(convertView==null)&#123; //如果convertView为空 if (type == 1 || type == 8)&#123; //根据不同的类型inflate不同的布局，并实例化对应的holder convertView = inflater.inflate(R.layout.updatestatus, viewgroup, false); holder_UpdateStatus = new Holder_UpdateStatus(); convertView.setTag(holder_UpdateStatus); &#125; else &#123; //其他的type.... convertView = inflater.inflate(R.layout.sharestatus, viewgroup, false); holder_ShareStatus = new Holder_ShareStatusHolder(); convertView.setTag(holder_ShareStatus); &#125; &#125; else &#123; //如果convertView不空 if (type == 1 || type == 8)&#123; //也要根据type得到不同的holder holder_UpdateStatus =(Holder_UpdateStatus)convertView.getTag(); &#125; else &#123; //其他type... holder_ShareStatus =(Holder_ShareStatus)convertView.getTag(); &#125; &#125; if (type == 1 || type == 8)&#123; //根据type设置不同的holder的资源 ... &#125; else &#123;...&#125; return convertView;&#125; THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"Ubuntu 连接Android真机（华为C8813Q)","slug":"2014-04-21-AndroidUbuntuConnectAndroidDevices","date":"2014-04-20T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/04/21/2014-04-21-AndroidUbuntuConnectAndroidDevices/","link":"","permalink":"http://ai.wisim.me/2014/04/21/2014-04-21-AndroidUbuntuConnectAndroidDevices/","excerpt":"Android手机连接ubuntu之后,若已在环境变量中配置了adb,直接在终端中输入 adb devices 会显示一串????????解决方法如下：","text":"Android手机连接ubuntu之后,若已在环境变量中配置了adb,直接在终端中输入 adb devices 会显示一串????????解决方法如下： (1):手机连接上笔记本后，在手机中的usb调试一定要开启，然后在终端中键入lsusb 出现如下内容: 12345678910wxp@wxp:~$ lsusbBus 001 Device 002: ID 8087:8008 Intel Corp.Bus 002 Device 002: ID 8087:8000 Intel Corp.Bus 003 Device 002: ID 046d:c52f Logiblog, Inc. Wireless Mouse M305Bus 003 Device 011: ID 12d1:1038 Huawei Technologies Co., Ltd. Ideos (debug mode)Bus 003 Device 003: ID 04f2:b40d Chicony Electronics Co., LtdBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub 找到你的手机对应的ID，(我的是Huawei的那行) (2):接着在终端中输入 cd /etc/udev/rules.d/ 进入到此目录下，新建文档“90-android.rules” touch 90-android.rules sudo gedit 90-android.rules 进入文档后，输入以下两行内容 SUBSYSTEM ==”usb” , SYSFS{ “Huawei Technologies Co.” } ==”12d1” , MODE =”0666” SUBSYSTEM==”usb”, ENV{DEVTYPE}==”usb_device”, MODE=”0666” 注意:SYSFS后面就是填你自己的ID，我的手机是12d1 文档内容完成后赋予所有人所有权限 sudo chmod 777 90-android.rules (3):在终端中输入 sudo /etc/init.d/udev restart 对usb设备重启连接。 sudo adb kill-server 注意:如果不行则进入你的Android sdk目录下的platform-tools目录中再尝试一次。 继续： sudo adb start-server sudo adb devices 至此应该可以正常显示了，如下 123adb devicesList of devices attachedA49947CBC4AEdevice 然而华为手机可能仍不能正常显示 打开你的手机设置，找到附加设置（我的手机已经刷成MIUI了） 选择工程模式 接着选择后台设置 接着选择 USB 端口配置，默认是Normal模式 选择 Google 模式 选择好后,重新启动手机. 在ubuntu终端中输入 adb devices THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://ai.wisim.me/tags/Ubuntu/"}]},{"title":"hp pavilion 15 notebook笔记本 解决RTL8188EE无线网卡问题","slug":"2014-04-21-UbuntuNetworkAdapter","date":"2014-04-20T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/04/21/2014-04-21-UbuntuNetworkAdapter/","link":"","permalink":"http://ai.wisim.me/2014/04/21/2014-04-21-UbuntuNetworkAdapter/","excerpt":"笔记本装了Ubuntu12.04之后发现无线网用不了，折腾了好久才搞定 —！解决方法： (1):下载驱动文件linux_mac80211_0012.0207.2013.tar.bz2（大小为12799K). (2):右击压缩包-&gt;提取到此处.解压后的目录名称为:rtl_92ce_92se_92de_8723ae_88ee_linux_mac80211_001 2.0207.2013 .将该目录复制到root目录下. (3):打开终端，输入下面的命令: cd ~/rtl_92ce_92se_92de_8723ae_88ee_linux_mac80211_0012.0207.2013","text":"笔记本装了Ubuntu12.04之后发现无线网用不了，折腾了好久才搞定 —！解决方法： (1):下载驱动文件linux_mac80211_0012.0207.2013.tar.bz2（大小为12799K). (2):右击压缩包-&gt;提取到此处.解压后的目录名称为:rtl_92ce_92se_92de_8723ae_88ee_linux_mac80211_001 2.0207.2013 .将该目录复制到root目录下. (3):打开终端，输入下面的命令: cd ~/rtl_92ce_92se_92de_8723ae_88ee_linux_mac80211_0012.0207.2013 进入该目录，后键入： make 可能会出现如下错误: 12345/home/wxp/rtl_92ce_92se_92de_8723ae_88ee_linux_mac80211_0012.0207.2013/pci.h:247:15: 错误： expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘rtl_pci_probe’make[2]: *** [/home/wxp/rtl_92ce_92se_92de_8723ae_88ee_linux_mac80211_0012.0207.2013/base.o] 错误 1make[1]: *** [_module_/home/wxp/rtl_92ce_92se_92de_8723ae_88ee_linux_mac80211_0012.0207.2013] 错误 2make[1]:正在离开目录 `/usr/src/linux-headers-3.8.0-35-generic'make: *** [all] 错误 2 解决方法:在rtl_92ce_92se_92de_8723ae_88ee_linux_mac80211_0012.0207.2013目录下的pci.h的文件内容中 12#ifndef __RTL_PCI_H__#define __RTL_PCI_H__ 的后面加上： 1234#ifndef __devinit#define __devinit#define __devinitdata#endif 重新执行: make sudo make install sudo modprobe -v rtl8188ee 参考资料:http://ubuntuforums.org/showthread.php?t=2162026 THE END.","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://ai.wisim.me/categories/FAQ/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://ai.wisim.me/tags/Ubuntu/"}]},{"title":"res资源的使用","slug":"2014-04-13-AndroidResourceUse","date":"2014-04-12T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/04/13/2014-04-13-AndroidResourceUse/","link":"","permalink":"http://ai.wisim.me/2014/04/13/2014-04-13-AndroidResourceUse/","excerpt":"属性资源：attrs.xml1234567&lt;attr name=”属性名字” format=“属性值限定的字符串“&gt; &lt;定义全局的属性&gt;&lt;/attr&gt;&lt;declare-styleable name=”组件名称” &lt;attr name=”属性名字” format=“属性值限定的字符串“/&gt; &lt; attr name=”全局定义的属性名称”/&gt;&lt;/ declare-styleable &gt; 值得注意的是定义属性 需要定义自己的命名空间 原则上命名空间可以随便取但是 也有一定规则 命名空间必须以http://schemas.android.com/apk/res/ 开头 后面是所要引用的R文件所在的路径 也就是包名 属性值限定的字符串的意思是属性的取值限定的类型 如reference 引用资源id类型 string float 等等 最后要在所要引用该属性的布局文件中加上自己的命名空间","text":"属性资源：attrs.xml1234567&lt;attr name=”属性名字” format=“属性值限定的字符串“&gt; &lt;定义全局的属性&gt;&lt;/attr&gt;&lt;declare-styleable name=”组件名称” &lt;attr name=”属性名字” format=“属性值限定的字符串“/&gt; &lt; attr name=”全局定义的属性名称”/&gt;&lt;/ declare-styleable &gt; 值得注意的是定义属性 需要定义自己的命名空间 原则上命名空间可以随便取但是 也有一定规则 命名空间必须以http://schemas.android.com/apk/res/ 开头 后面是所要引用的R文件所在的路径 也就是包名 属性值限定的字符串的意思是属性的取值限定的类型 如reference 引用资源id类型 string float 等等 最后要在所要引用该属性的布局文件中加上自己的命名空间 使用方式 -CustomAttributes ： 12345AttributeSet的一个对象先有 假设是attrs//获得属性数组对象TypedArray typedArray=Context.obtainStyledAttributes（atts，R.styleable.组件名称）;//获得&lt;declare-styleable&gt;标签下的属性值resourceid= typedArray.getResourceId（R.styleable.组件名称_属性名称,default_value）; (布局)在视图的布局文件 加入命名空间 如app 那么引用的就是app：属性名称=“属性值” 菜单资源：/menu目录123456789101112131415&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;item android:属性 /&gt; &lt;item android:属性 /&gt; &lt;group id&gt; &lt;item android:属性 /&gt; &lt;item android:属性 /&gt; &lt;menu&gt; &lt;item android:属性 /&gt; &lt;item android:属性 /&gt; &lt;group id&gt; &lt;item android:属性 /&gt; &lt;item android:属性 /&gt; &lt;/group&gt; &lt;/group&gt;&lt;/menu&gt; 上面是一个完整的菜单方式 根据要求可以删减比如说不需要设置子菜单项中间那个 menu的标签就不需要的 有的需要组 也可以删去 但是item内不可以有item值得注意的是 命名空间 可以是安卓默认的 也可以是自己定义的 设置的属性 主要是菜单的属性 与在布局文件定义类似Menu 标签没有任何属性 除了第一个跟标签需要命名空间 其他的不要 当然 菜单资源的文件 要以&lt;menu&gt; 为root标签 不是以&lt;resource&gt; item的属性如下 id 菜单项的id menuCategory 菜单项的种类 如设置成system 表示系统菜单 放在其他的后面 orderInCategory 同种类菜单排列顺序 title 菜单项的显示文本 titleCondensed 菜单项的短标题 如果菜单项文本太长 会显示该值 icon 菜单项图片的id alphabeticShortCut 菜单项的字母快捷键 numericShortCut 菜单项数字快捷键 checkable 菜单项是否带复选框 checked 如果菜单项带复选框 表示该复选框是否被默认选中 visible 菜单项是否可见 enabled 菜单项是否可用 group的属性如下 id 菜单组的id menuCategory 与item相同 只是作用域在菜单组 orderInCategory 与item相同 只是作用域在菜单组 visible 菜单组里的所有菜单项是否可见 enable 菜单组里所有菜单是否可用 CheckableBehavior 设置该菜单组上显示的选择组件 如果为all 显示checkbox 如果为single 显示Radio Button 如果为none 正常显示菜单 不会显示选择组件（check box Radio Button） 使用方式：如果是在onCreateOptionsMenu(Menu menu) 或者 onCreteContextMenu（）的回调方法里装载资源文件 MenuInflater menuinflater=getMenuInflater（）menuinflater.inflate（R.menu.菜单资源文件的名称） 如果是onCreteContextMenu里 要在onCreate（）方法里将上下文菜单注册到某个组件上 registerForContextMenu（某个组件的名称） 数组资源：arrays.xml 定义形式： 12345678&lt;数组类型-array name=”array_name”&gt; &lt;item&gt; array_value1 &lt;/item&gt; &lt;item&gt; array_value2 &lt;/item&gt;&lt;/数组类型-array&gt; 使用方式: String []abc=getResource().getStringArray(R.array.array_name) eg: 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string-array name=\"countries\"&gt; &lt;item &gt;中国&lt;/item&gt; &lt;item &gt;美国&lt;/item&gt; &lt;/string-array&gt; &lt;integer-array name=\"numbs\"&gt; &lt;item &gt;1&lt;/item&gt; &lt;item &gt;2&lt;/item&gt; &lt;/integer-array&gt;&lt;/resources&gt; xml资源:使用方式1XmlResourceParser xml=getResources().getXml(R.xml.xml_file_name); raw资源:使用方式123InputStream read= getResources().openRawResource（R.raw.file_name）;OutputStream write= getResources().openRawResource（R.raw.file_name）; assets资源:使用方式123InputStream read=getAssets（）.open（“文件的名称“）//如果assets下还有个文件目录 也要把目录名写上用 / 隔开 如abc/a.txtOutputStream write=getAssets（）.open（“文件的名称“） THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"bash note","slug":"2014-04-20-UbuntuBashNote","date":"2014-04-11T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/04/12/2014-04-20-UbuntuBashNote/","link":"","permalink":"http://ai.wisim.me/2014/04/12/2014-04-20-UbuntuBashNote/","excerpt":"bash命令 命令与文件补全功能： ([tab] 按键的好处) 使用 [tab] 按键的时机依据 [tab] 接在命令后或参数后而有所不同。 [Tab] 接在一串命令的第一个字的后面，则为命令补全；[Tab] 接在一串命令的第二个字以后时，则为『文件补齐』！ 所以说，如果我想要知道我的环境中，所有可以运行的命令有几个？ 就直接在 bash 的提示字符后面连续按两次 [tab] 按键就能够显示所有的可运行命令了。那如果想要知道系统当中所有以 c 为开头的命令呢？就按下 c[tab][tab]就好啦！","text":"bash命令 命令与文件补全功能： ([tab] 按键的好处) 使用 [tab] 按键的时机依据 [tab] 接在命令后或参数后而有所不同。 [Tab] 接在一串命令的第一个字的后面，则为命令补全；[Tab] 接在一串命令的第二个字以后时，则为『文件补齐』！ 所以说，如果我想要知道我的环境中，所有可以运行的命令有几个？ 就直接在 bash 的提示字符后面连续按两次 [tab] 按键就能够显示所有的可运行命令了。那如果想要知道系统当中所有以 c 为开头的命令呢？就按下 c[tab][tab]就好啦！ vim1234567891011121314a 在光标后面插入；i 直接在当前位置插入；x 删除单个字符；gg:跳转到文件首行G:跳转到文件尾行&#123;:跳转到上一个空行处&#125;:跳转到下一个空行处shift+o:在光标的上面插入新的一行shift+O:在光标到下面插入新的一行0:跳转到本行开头$:跳转到本行结尾yy:复制本行p:在下行粘贴内容P:在上面一行粘贴内容 bash脚本 一个命令的运行成功与否，可以使用 $? 这个变量来观察～ 那么我们也可以利用 exit 这个命令来让程序中断，并且回传一个数值给系统。 1234#!/bin/bash#Programecho -e \"helloworld\\a\\n\"exit 0 上例使用 exit 0 ，这代表离开 script 并且回传一个 0 给系统， 所以我运行完这个 script 后，若接著下达 echo $? 则可得到 0 的值！ 利用这个 exit n (n 是数字) 的功能，我们还可以自订错误信息， 让这支程序变得更加的 smart 呢！ Ubuntu开机自动挂在分区 0.查看分区： 12sudo fdisk -lvim mount_one.sh 1.新建一个mount_one.sh脚本文件，内容为： mount /dev/sdb1 /media/one 2.在rc.local文件中添加mount_one.sh的路径 1vim /etc/rc.local 在exit 0上面添加 /root/mount_one.sh THE END.","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://ai.wisim.me/categories/FAQ/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://ai.wisim.me/tags/Ubuntu/"}]},{"title":"Android打包应用lint error","slug":"2014-06-06-AndroidLintError","date":"2014-04-05T16:00:00.000Z","updated":"2018-07-24T06:24:34.000Z","comments":true,"path":"2014/04/06/2014-06-06-AndroidLintError/","link":"","permalink":"http://ai.wisim.me/2014/04/06/2014-06-06-AndroidLintError/","excerpt":"Eclipse打包apk时出现的一个小错误…有时候最终打包应用时会显示如下错误 解决方法如下：","text":"Eclipse打包apk时出现的一个小错误…有时候最终打包应用时会显示如下错误 解决方法如下： Step 1： Eclipse顶部菜单栏Windows-&gt;Preferences-&gt;Android-&gt;Lint Error Checking 原本Run full error check…前面是有勾的。把勾取消。 Step 2： 右击工程-&gt;Android Tools-&gt;Clear Lint Markers Step 3： 接着再按正常步骤打包应用 THE END.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://ai.wisim.me/categories/ANDROID/"}],"tags":[]},{"title":"常用的Latex公式","slug":"1970-01-01-01","date":"1969-12-31T16:00:00.000Z","updated":"2018-09-06T11:43:06.000Z","comments":true,"path":"1970/01/01/1970-01-01-01/","link":"","permalink":"http://ai.wisim.me/1970/01/01/1970-01-01-01/","excerpt":"空格直接是 1\\:","text":"空格直接是 1\\: 1. 极限$\\lim _{\\tiny{x\\rightarrow \\infty} }( b^{\\tiny{\\dfrac {1} {n}}}-1)$ 1$\\lim _&#123;\\tiny&#123;x\\rightarrow \\infty&#125; &#125;(...)$ 2. 字体大小(1) 极小的字体 1\\tiny 3. 角标(1) 右上角 : $b^{\\tiny{\\dfrac {1} {n}}}$ 1$b^&#123;\\tiny&#123;...&#125;&#125;$ (2) 右下角 : $b_{\\tiny{\\dfrac {1} {n}}}$ 1$b_&#123;\\tiny&#123;\\dfrac &#123;1&#125; &#123;n&#125;&#125;&#125;$ (3) 大帽 : $\\widehat{y}$ 1$\\widehat&#123;y&#125;$ (4) 小帽 : $\\hat{y}$ 1$\\hat&#123;y&#125;$ (5) 大波浪 : $\\widetilde{y}$ 1$\\widetilde&#123;y&#125;$ (6) 小波浪 : $\\tilde{y}$ 1$\\tilde&#123;y&#125;$ 4. 分数形式(1) $\\dfrac{a}{b}$1$\\dfrac&#123;...&#125;&#123;...&#125;$ 5. 希腊字母 字母 源码 $\\pi$ \\pi $\\alpha$ \\alpha $\\beta$ \\beta $\\theta$ \\theta $\\varepsilon$ \\varepsilon $\\delta$ \\delta $\\eta$ \\eta $\\lambda$ \\lambda $\\xi$ \\xi $\\tau$ \\tau $\\psi$ \\psi $\\phi$ \\phi $\\sigma$ \\sigma $\\gamma$ \\gamma 6. 数学符号 符号 说明 源码 $\\leq$ 小于等于 \\leq $\\geq$ 大于等于 \\geq $\\neq$ 不等于 \\neq $\\in$ 在区间内 \\in $\\times$ 叉乘 \\times $\\cdot$ 点乘 \\cdot $\\sum ^{n}_{i=0} {i\\cdot n}$ 累加 \\sum ^{...}_{...} {...} $\\Delta x_{i}$ delta \\Delta $\\frac{\\partial f(x,y)}{\\partial x}$ 偏导数 \\frac{\\partial f(x,y)}{\\partial x} $\\nabla f(x,y) $ 梯度 \\nabla f(x,y) $\\int _{a}^{b}$ 积分 \\int _{a}^{b} $\\vec a$ 向量 \\vec a $\\overline{X}$ 顶部横线（均值） \\overline{X} 7. 换行和对齐例子： \\begin{array}{ll} a & =b+c\\\\ & =d+e\\\\ \\end{array}源码： 123456$$\\begin&#123;array&#125;&#123;ll&#125; a&amp; =b+c\\\\ &amp; =d+e\\\\\\end&#123;array&#125; $$ 说明： 整个代码块以 \\begin{array}{ll} 开头，\\end{array}结尾。每一行以 &amp; 开头，\\\\结尾。 THE END.","categories":[{"name":"MATH","slug":"MATH","permalink":"http://ai.wisim.me/categories/MATH/"}],"tags":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://ai.wisim.me/tags/TOOLS/"}]}]}